{
  "version": 3,
  "sources": ["../../src/agentType.ts", "../../src/agentType.ts", "../../src/powerPlatformCloud.ts", "../../src/connectionSettings.ts", "../../../../node_modules/eventsource-parser/src/errors.ts", "../../../../node_modules/eventsource-parser/src/parse.ts", "../../../../node_modules/eventsource-client/src/constants.ts", "../../../../node_modules/eventsource-client/src/client.ts", "../../../../node_modules/eventsource-client/src/default.ts", "../../../../node_modules/ms/index.js", "../../../../node_modules/debug/src/common.js", "../../../../node_modules/debug/src/browser.js", "../../../agents-activity/src/logger.ts", "../../src/strategies/prebuiltBotStrategy.ts", "../../src/strategies/publishedBotStrategy.ts", "../../src/powerPlatformEnvironment.ts", "../../../../node_modules/zod/v3/helpers/util.cjs", "../../../../node_modules/zod/v3/ZodError.cjs", "../../../../node_modules/zod/v3/locales/en.cjs", "../../../../node_modules/zod/v3/errors.cjs", "../../../../node_modules/zod/v3/helpers/parseUtil.cjs", "../../../../node_modules/zod/v3/helpers/typeAliases.cjs", "../../../../node_modules/zod/v3/helpers/errorUtil.cjs", "../../../../node_modules/zod/v3/types.cjs", "../../../../node_modules/zod/v3/external.cjs", "../../../../node_modules/zod/index.cjs", "../../../agents-activity/src/action/actionTypes.ts", "../../../agents-activity/src/action/semanticActionStateTypes.ts", "../../../agents-activity/src/attachment/attachmentLayoutTypes.ts", "../../../agents-activity/src/conversation/channels.ts", "../../../agents-activity/src/conversation/endOfConversationCodes.ts", "../../../agents-activity/src/conversation/membershipSourceTypes.ts", "../../../agents-activity/src/conversation/membershipTypes.ts", "../../../agents-activity/src/conversation/roleTypes.ts", "../../../agents-activity/src/entity/AIEntity.ts", "../../../agents-activity/src/invoke/adaptiveCardInvokeAction.ts", "../../../../node_modules/uuid/dist/cjs-browser/max.js", "../../../../node_modules/uuid/dist/cjs-browser/nil.js", "../../../../node_modules/uuid/dist/cjs-browser/regex.js", "../../../../node_modules/uuid/dist/cjs-browser/validate.js", "../../../../node_modules/uuid/dist/cjs-browser/parse.js", "../../../../node_modules/uuid/dist/cjs-browser/stringify.js", "../../../../node_modules/uuid/dist/cjs-browser/rng.js", "../../../../node_modules/uuid/dist/cjs-browser/v1.js", "../../../../node_modules/uuid/dist/cjs-browser/v1ToV6.js", "../../../../node_modules/uuid/dist/cjs-browser/md5.js", "../../../../node_modules/uuid/dist/cjs-browser/v35.js", "../../../../node_modules/uuid/dist/cjs-browser/v3.js", "../../../../node_modules/uuid/dist/cjs-browser/native.js", "../../../../node_modules/uuid/dist/cjs-browser/v4.js", "../../../../node_modules/uuid/dist/cjs-browser/sha1.js", "../../../../node_modules/uuid/dist/cjs-browser/v5.js", "../../../../node_modules/uuid/dist/cjs-browser/v6.js", "../../../../node_modules/uuid/dist/cjs-browser/v6ToV1.js", "../../../../node_modules/uuid/dist/cjs-browser/v7.js", "../../../../node_modules/uuid/dist/cjs-browser/version.js", "../../../../node_modules/uuid/dist/cjs-browser/index.js", "../../../agents-activity/src/entity/entity.ts", "../../../agents-activity/src/action/semanticAction.ts", "../../../agents-activity/src/action/cardAction.ts", "../../../agents-activity/src/action/suggestedActions.ts", "../../../agents-activity/src/activityEventNames.ts", "../../../agents-activity/src/activityImportance.ts", "../../../agents-activity/src/activityTypes.ts", "../../../agents-activity/src/attachment/attachment.ts", "../../../agents-activity/src/conversation/channelAccount.ts", "../../../agents-activity/src/conversation/conversationAccount.ts", "../../../agents-activity/src/conversation/conversationReference.ts", "../../../agents-activity/src/deliveryModes.ts", "../../../agents-activity/src/inputHints.ts", "../../../agents-activity/src/messageReactionTypes.ts", "../../../agents-activity/src/messageReaction.ts", "../../../agents-activity/src/textFormatTypes.ts", "../../../agents-activity/src/textHighlight.ts", "../../../agents-activity/src/activity.ts", "../../../agents-activity/src/callerIdConstants.ts", "../../../agents-activity/src/activityTreatments.ts", "../../../agents-activity/src/index.ts", "../../src/executeTurnRequest.ts", "../../package.json", "../../src/browser/os.ts", "../../src/copilotStudioClient.ts", "../../../../node_modules/rxjs/src/internal/util/isFunction.ts", "../../../../node_modules/rxjs/src/internal/util/createErrorClass.ts", "../../../../node_modules/rxjs/src/internal/util/UnsubscriptionError.ts", "../../../../node_modules/rxjs/src/internal/util/arrRemove.ts", "../../../../node_modules/rxjs/src/internal/Subscription.ts", "../../../../node_modules/rxjs/src/internal/config.ts", "../../../../node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts", "../../../../node_modules/rxjs/src/internal/util/reportUnhandledError.ts", "../../../../node_modules/rxjs/src/internal/util/noop.ts", "../../../../node_modules/rxjs/src/internal/NotificationFactories.ts", "../../../../node_modules/rxjs/src/internal/util/errorContext.ts", "../../../../node_modules/rxjs/src/internal/Subscriber.ts", "../../../../node_modules/rxjs/src/internal/symbol/observable.ts", "../../../../node_modules/rxjs/src/internal/util/identity.ts", "../../../../node_modules/rxjs/src/internal/util/pipe.ts", "../../../../node_modules/rxjs/src/internal/Observable.ts", "../../../../node_modules/rxjs/src/internal/util/lift.ts", "../../../../node_modules/rxjs/src/internal/operators/OperatorSubscriber.ts", "../../../../node_modules/rxjs/src/internal/operators/refCount.ts", "../../../../node_modules/rxjs/src/internal/observable/ConnectableObservable.ts", "../../../../node_modules/rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../../../node_modules/rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../../../node_modules/rxjs/src/internal/observable/dom/animationFrames.ts", "../../../../node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../../../node_modules/rxjs/src/internal/Subject.ts", "../../../../node_modules/rxjs/src/internal/BehaviorSubject.ts", "../../../../node_modules/rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../../../node_modules/rxjs/src/internal/ReplaySubject.ts", "../../../../node_modules/rxjs/src/internal/AsyncSubject.ts", "../../../../node_modules/rxjs/src/internal/scheduler/Action.ts", "../../../../node_modules/rxjs/src/internal/scheduler/intervalProvider.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AsyncAction.ts", "../../../../node_modules/rxjs/src/internal/util/Immediate.ts", "../../../../node_modules/rxjs/src/internal/scheduler/immediateProvider.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AsapAction.ts", "../../../../node_modules/rxjs/src/internal/Scheduler.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AsapScheduler.ts", "../../../../node_modules/rxjs/src/internal/scheduler/asap.ts", "../../../../node_modules/rxjs/src/internal/scheduler/async.ts", "../../../../node_modules/rxjs/src/internal/scheduler/QueueAction.ts", "../../../../node_modules/rxjs/src/internal/scheduler/QueueScheduler.ts", "../../../../node_modules/rxjs/src/internal/scheduler/queue.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../../../node_modules/rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../../../node_modules/rxjs/src/internal/scheduler/animationFrame.ts", "../../../../node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../../../node_modules/rxjs/src/internal/observable/empty.ts", "../../../../node_modules/rxjs/src/internal/util/isScheduler.ts", "../../../../node_modules/rxjs/src/internal/util/args.ts", "../../../../node_modules/rxjs/src/internal/util/isArrayLike.ts", "../../../../node_modules/rxjs/src/internal/util/isPromise.ts", "../../../../node_modules/rxjs/src/internal/util/isInteropObservable.ts", "../../../../node_modules/rxjs/src/internal/util/isAsyncIterable.ts", "../../../../node_modules/rxjs/src/internal/util/throwUnobservableError.ts", "../../../../node_modules/rxjs/src/internal/symbol/iterator.ts", "../../../../node_modules/rxjs/src/internal/util/isIterable.ts", "../../../../node_modules/rxjs/src/internal/util/isReadableStreamLike.ts", "../../../../node_modules/rxjs/src/internal/observable/innerFrom.ts", "../../../../node_modules/rxjs/src/internal/util/executeSchedule.ts", "../../../../node_modules/rxjs/src/internal/operators/observeOn.ts", "../../../../node_modules/rxjs/src/internal/operators/subscribeOn.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduleObservable.ts", "../../../../node_modules/rxjs/src/internal/scheduled/schedulePromise.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduleArray.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduleIterable.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../../../node_modules/rxjs/src/internal/scheduled/scheduled.ts", "../../../../node_modules/rxjs/src/internal/observable/from.ts", "../../../../node_modules/rxjs/src/internal/observable/of.ts", "../../../../node_modules/rxjs/src/internal/observable/throwError.ts", "../../../../node_modules/rxjs/src/internal/Notification.ts", "../../../../node_modules/rxjs/src/internal/util/isObservable.ts", "../../../../node_modules/rxjs/src/internal/util/EmptyError.ts", "../../../../node_modules/rxjs/src/internal/lastValueFrom.ts", "../../../../node_modules/rxjs/src/internal/firstValueFrom.ts", "../../../../node_modules/rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../../../node_modules/rxjs/src/internal/util/NotFoundError.ts", "../../../../node_modules/rxjs/src/internal/util/SequenceError.ts", "../../../../node_modules/rxjs/src/internal/util/isDate.ts", "../../../../node_modules/rxjs/src/internal/operators/timeout.ts", "../../../../node_modules/rxjs/src/internal/operators/map.ts", "../../../../node_modules/rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../../../node_modules/rxjs/src/internal/observable/bindCallbackInternals.ts", "../../../../node_modules/rxjs/src/internal/observable/bindCallback.ts", "../../../../node_modules/rxjs/src/internal/observable/bindNodeCallback.ts", "../../../../node_modules/rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../../../node_modules/rxjs/src/internal/util/createObject.ts", "../../../../node_modules/rxjs/src/internal/observable/combineLatest.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeInternals.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeMap.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeAll.ts", "../../../../node_modules/rxjs/src/internal/operators/concatAll.ts", "../../../../node_modules/rxjs/src/internal/observable/concat.ts", "../../../../node_modules/rxjs/src/internal/observable/defer.ts", "../../../../node_modules/rxjs/src/internal/observable/connectable.ts", "../../../../node_modules/rxjs/src/internal/observable/forkJoin.ts", "../../../../node_modules/rxjs/src/internal/observable/fromEvent.ts", "../../../../node_modules/rxjs/src/internal/observable/fromEventPattern.ts", "../../../../node_modules/rxjs/src/internal/observable/generate.ts", "../../../../node_modules/rxjs/src/internal/observable/iif.ts", "../../../../node_modules/rxjs/src/internal/observable/timer.ts", "../../../../node_modules/rxjs/src/internal/observable/interval.ts", "../../../../node_modules/rxjs/src/internal/observable/merge.ts", "../../../../node_modules/rxjs/src/internal/observable/never.ts", "../../../../node_modules/rxjs/src/internal/util/argsOrArgArray.ts", "../../../../node_modules/rxjs/src/internal/observable/onErrorResumeNext.ts", "../../../../node_modules/rxjs/src/internal/observable/pairs.ts", "../../../../node_modules/rxjs/src/internal/util/not.ts", "../../../../node_modules/rxjs/src/internal/operators/filter.ts", "../../../../node_modules/rxjs/src/internal/observable/partition.ts", "../../../../node_modules/rxjs/src/internal/observable/race.ts", "../../../../node_modules/rxjs/src/internal/observable/range.ts", "../../../../node_modules/rxjs/src/internal/observable/using.ts", "../../../../node_modules/rxjs/src/internal/observable/zip.ts", "../../../../node_modules/rxjs/dist/cjs/internal/types.js", "../../../../node_modules/rxjs/src/internal/operators/audit.ts", "../../../../node_modules/rxjs/src/internal/operators/auditTime.ts", "../../../../node_modules/rxjs/src/internal/operators/buffer.ts", "../../../../node_modules/rxjs/src/internal/operators/bufferCount.ts", "../../../../node_modules/rxjs/src/internal/operators/bufferTime.ts", "../../../../node_modules/rxjs/src/internal/operators/bufferToggle.ts", "../../../../node_modules/rxjs/src/internal/operators/bufferWhen.ts", "../../../../node_modules/rxjs/src/internal/operators/catchError.ts", "../../../../node_modules/rxjs/src/internal/operators/scanInternals.ts", "../../../../node_modules/rxjs/src/internal/operators/reduce.ts", "../../../../node_modules/rxjs/src/internal/operators/toArray.ts", "../../../../node_modules/rxjs/src/internal/operators/joinAllInternals.ts", "../../../../node_modules/rxjs/src/internal/operators/combineLatestAll.ts", "../../../../node_modules/rxjs/src/internal/operators/combineAll.ts", "../../../../node_modules/rxjs/src/internal/operators/combineLatest.ts", "../../../../node_modules/rxjs/src/internal/operators/combineLatestWith.ts", "../../../../node_modules/rxjs/src/internal/operators/concatMap.ts", "../../../../node_modules/rxjs/src/internal/operators/concatMapTo.ts", "../../../../node_modules/rxjs/src/internal/operators/concat.ts", "../../../../node_modules/rxjs/src/internal/operators/concatWith.ts", "../../../../node_modules/rxjs/src/internal/observable/fromSubscribable.ts", "../../../../node_modules/rxjs/src/internal/operators/connect.ts", "../../../../node_modules/rxjs/src/internal/operators/count.ts", "../../../../node_modules/rxjs/src/internal/operators/debounce.ts", "../../../../node_modules/rxjs/src/internal/operators/debounceTime.ts", "../../../../node_modules/rxjs/src/internal/operators/defaultIfEmpty.ts", "../../../../node_modules/rxjs/src/internal/operators/take.ts", "../../../../node_modules/rxjs/src/internal/operators/ignoreElements.ts", "../../../../node_modules/rxjs/src/internal/operators/mapTo.ts", "../../../../node_modules/rxjs/src/internal/operators/delayWhen.ts", "../../../../node_modules/rxjs/src/internal/operators/delay.ts", "../../../../node_modules/rxjs/src/internal/operators/dematerialize.ts", "../../../../node_modules/rxjs/src/internal/operators/distinct.ts", "../../../../node_modules/rxjs/src/internal/operators/distinctUntilChanged.ts", "../../../../node_modules/rxjs/src/internal/operators/distinctUntilKeyChanged.ts", "../../../../node_modules/rxjs/src/internal/operators/throwIfEmpty.ts", "../../../../node_modules/rxjs/src/internal/operators/elementAt.ts", "../../../../node_modules/rxjs/src/internal/operators/endWith.ts", "../../../../node_modules/rxjs/src/internal/operators/every.ts", "../../../../node_modules/rxjs/src/internal/operators/exhaustMap.ts", "../../../../node_modules/rxjs/src/internal/operators/exhaustAll.ts", "../../../../node_modules/rxjs/src/internal/operators/exhaust.ts", "../../../../node_modules/rxjs/src/internal/operators/expand.ts", "../../../../node_modules/rxjs/src/internal/operators/finalize.ts", "../../../../node_modules/rxjs/src/internal/operators/find.ts", "../../../../node_modules/rxjs/src/internal/operators/findIndex.ts", "../../../../node_modules/rxjs/src/internal/operators/first.ts", "../../../../node_modules/rxjs/src/internal/operators/groupBy.ts", "../../../../node_modules/rxjs/src/internal/operators/isEmpty.ts", "../../../../node_modules/rxjs/src/internal/operators/takeLast.ts", "../../../../node_modules/rxjs/src/internal/operators/last.ts", "../../../../node_modules/rxjs/src/internal/operators/materialize.ts", "../../../../node_modules/rxjs/src/internal/operators/max.ts", "../../../../node_modules/rxjs/src/internal/operators/flatMap.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeMapTo.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeScan.ts", "../../../../node_modules/rxjs/src/internal/operators/merge.ts", "../../../../node_modules/rxjs/src/internal/operators/mergeWith.ts", "../../../../node_modules/rxjs/src/internal/operators/min.ts", "../../../../node_modules/rxjs/src/internal/operators/multicast.ts", "../../../../node_modules/rxjs/src/internal/operators/onErrorResumeNextWith.ts", "../../../../node_modules/rxjs/src/internal/operators/pairwise.ts", "../../../../node_modules/rxjs/src/internal/operators/pluck.ts", "../../../../node_modules/rxjs/src/internal/operators/publish.ts", "../../../../node_modules/rxjs/src/internal/operators/publishBehavior.ts", "../../../../node_modules/rxjs/src/internal/operators/publishLast.ts", "../../../../node_modules/rxjs/src/internal/operators/publishReplay.ts", "../../../../node_modules/rxjs/src/internal/operators/raceWith.ts", "../../../../node_modules/rxjs/src/internal/operators/repeat.ts", "../../../../node_modules/rxjs/src/internal/operators/repeatWhen.ts", "../../../../node_modules/rxjs/src/internal/operators/retry.ts", "../../../../node_modules/rxjs/src/internal/operators/retryWhen.ts", "../../../../node_modules/rxjs/src/internal/operators/sample.ts", "../../../../node_modules/rxjs/src/internal/operators/sampleTime.ts", "../../../../node_modules/rxjs/src/internal/operators/scan.ts", "../../../../node_modules/rxjs/src/internal/operators/sequenceEqual.ts", "../../../../node_modules/rxjs/src/internal/operators/share.ts", "../../../../node_modules/rxjs/src/internal/operators/shareReplay.ts", "../../../../node_modules/rxjs/src/internal/operators/single.ts", "../../../../node_modules/rxjs/src/internal/operators/skip.ts", "../../../../node_modules/rxjs/src/internal/operators/skipLast.ts", "../../../../node_modules/rxjs/src/internal/operators/skipUntil.ts", "../../../../node_modules/rxjs/src/internal/operators/skipWhile.ts", "../../../../node_modules/rxjs/src/internal/operators/startWith.ts", "../../../../node_modules/rxjs/src/internal/operators/switchMap.ts", "../../../../node_modules/rxjs/src/internal/operators/switchAll.ts", "../../../../node_modules/rxjs/src/internal/operators/switchMapTo.ts", "../../../../node_modules/rxjs/src/internal/operators/switchScan.ts", "../../../../node_modules/rxjs/src/internal/operators/takeUntil.ts", "../../../../node_modules/rxjs/src/internal/operators/takeWhile.ts", "../../../../node_modules/rxjs/src/internal/operators/tap.ts", "../../../../node_modules/rxjs/src/internal/operators/throttle.ts", "../../../../node_modules/rxjs/src/internal/operators/throttleTime.ts", "../../../../node_modules/rxjs/src/internal/operators/timeInterval.ts", "../../../../node_modules/rxjs/src/internal/operators/timeoutWith.ts", "../../../../node_modules/rxjs/src/internal/operators/timestamp.ts", "../../../../node_modules/rxjs/src/internal/operators/window.ts", "../../../../node_modules/rxjs/src/internal/operators/windowCount.ts", "../../../../node_modules/rxjs/src/internal/operators/windowTime.ts", "../../../../node_modules/rxjs/src/internal/operators/windowToggle.ts", "../../../../node_modules/rxjs/src/internal/operators/windowWhen.ts", "../../../../node_modules/rxjs/src/internal/operators/withLatestFrom.ts", "../../../../node_modules/rxjs/src/internal/operators/zipAll.ts", "../../../../node_modules/rxjs/src/internal/operators/zip.ts", "../../../../node_modules/rxjs/src/internal/operators/zipWith.ts", "../../../../node_modules/rxjs/src/index.ts", "../../src/copilotStudioWebChat.ts", "../../src/executeTurnRequest.ts", "../../src/powerPlatformCloud.ts", "../../src/powerPlatformEnvironment.ts", "../../src/index.ts"],
  "sourcesContent": ["/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Enum representing the type of agent.\r\n */\r\nexport enum AgentType {\r\n  /**\r\n   * Represents a published agent.\r\n   */\r\n  Published = 'Published',\r\n  /**\r\n   * Represents a prebuilt agent.\r\n   */\r\n  Prebuilt = 'Prebuilt',\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Enum representing the type of agent.\r\n */\r\nexport enum AgentType {\r\n  /**\r\n   * Represents a published agent.\r\n   */\r\n  Published = 'Published',\r\n  /**\r\n   * Represents a prebuilt agent.\r\n   */\r\n  Prebuilt = 'Prebuilt',\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Enum representing different Power Platform cloud environments.\r\n */\r\nexport enum PowerPlatformCloud {\r\n  /**\r\n   * Unknown cloud environment.\r\n   */\r\n  Unknown = 'Unknown',\r\n  /**\r\n   * Experimental cloud environment.\r\n   */\r\n  Exp = 'Exp',\r\n  /**\r\n   * Development cloud environment.\r\n   */\r\n  Dev = 'Dev',\r\n  /**\r\n   * Test cloud environment.\r\n   */\r\n  Test = 'Test',\r\n  /**\r\n   * Pre-production cloud environment.\r\n   */\r\n  Preprod = 'Preprod',\r\n  /**\r\n   * First release cloud environment.\r\n   */\r\n  FirstRelease = 'FirstRelease',\r\n  /**\r\n   * Production cloud environment.\r\n   */\r\n  Prod = 'Prod',\r\n  /**\r\n   * Government cloud environment.\r\n   */\r\n  Gov = 'Gov',\r\n  /**\r\n   * High security cloud environment.\r\n   */\r\n  High = 'High',\r\n  /**\r\n   * Department of Defense cloud environment.\r\n   */\r\n  DoD = 'DoD',\r\n  /**\r\n   * Mooncake cloud environment.\r\n   */\r\n  Mooncake = 'Mooncake',\r\n  /**\r\n   * Ex cloud environment.\r\n   */\r\n  Ex = 'Ex',\r\n  /**\r\n   * Rx cloud environment.\r\n   */\r\n  Rx = 'Rx',\r\n  /**\r\n   * Private cloud environment.\r\n   */\r\n  Prv = 'Prv',\r\n  /**\r\n   * Local cloud environment.\r\n   */\r\n  Local = 'Local',\r\n  /**\r\n   * French government cloud environment.\r\n   */\r\n  GovFR = 'GovFR',\r\n  /**\r\n   * Other cloud environment.\r\n   */\r\n  Other = 'Other',\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AgentType } from './agentType'\r\nimport { CopilotStudioConnectionSettings } from './copilotStudioConnectionSettings'\r\nimport { PowerPlatformCloud } from './powerPlatformCloud'\r\n\r\n/**\r\n * Configuration options for establishing a connection to Copilot Studio.\r\n */\r\nabstract class ConnectionOptions implements Omit<CopilotStudioConnectionSettings, 'cloud' | 'copilotAgentType'> {\r\n  /** The client ID of the application. */\r\n  public appClientId: string = ''\r\n  /** The tenant ID of the application. */\r\n  public tenantId: string = ''\r\n  /** The login authority to use for the connection */\r\n  public authority?: string = ''\r\n  /** The environment ID of the application. */\r\n  public environmentId: string = ''\r\n  /** The identifier of the agent. */\r\n  public agentIdentifier: string = ''\r\n  /** The cloud environment of the application. */\r\n  public cloud?: PowerPlatformCloud | keyof typeof PowerPlatformCloud\r\n  /** The custom Power Platform cloud URL, if any. */\r\n  public customPowerPlatformCloud?: string\r\n  /** The type of the Copilot agent. */\r\n  public copilotAgentType?: AgentType | keyof typeof AgentType\r\n  /** The URL to connect directly to Copilot Studio endpoint */\r\n  public directConnectUrl?: string\r\n  /** Flag to use the experimental endpoint if available */\r\n  public useExperimentalEndpoint?: boolean = false\r\n}\r\n\r\n/**\r\n * Represents the settings required to establish a connection to Copilot Studio.\r\n */\r\nexport class ConnectionSettings extends ConnectionOptions {\r\n  /** The cloud environment of the application. */\r\n  public cloud?: PowerPlatformCloud\r\n  /** The type of the Copilot agent. */\r\n  public copilotAgentType?: AgentType\r\n\r\n  /**\r\n   * Default constructor for the ConnectionSettings class.\r\n   */\r\n  constructor ()\r\n\r\n  /**\r\n   * Creates an instance of ConnectionSettings.\r\n   * @param options Represents the settings required to establish a direct connection to the engine.\r\n   */\r\n  constructor (options: ConnectionOptions)\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  constructor (options?: ConnectionOptions) {\r\n    super()\r\n\r\n    if (!options) {\r\n      return\r\n    }\r\n\r\n    const cloud = options.cloud ?? PowerPlatformCloud.Prod\r\n    const copilotAgentType = options.copilotAgentType ?? AgentType.Published\r\n    const authority = options.authority && options.authority.trim() !== ''\r\n      ? options.authority\r\n      : 'https://login.microsoftonline.com'\r\n\r\n    if (!Object.values(PowerPlatformCloud).includes(cloud as PowerPlatformCloud)) {\r\n      throw new Error(`Invalid PowerPlatformCloud: '${cloud}'. Supported values: ${Object.values(PowerPlatformCloud).join(', ')}`)\r\n    }\r\n\r\n    if (!Object.values(AgentType).includes(copilotAgentType as AgentType)) {\r\n      throw new Error(`Invalid AgentType: '${copilotAgentType}'. Supported values: ${Object.values(AgentType).join(', ')}`)\r\n    }\r\n\r\n    Object.assign(this, { ...options, cloud, copilotAgentType, authority })\r\n  }\r\n}\r\n\r\n/**\r\n * Loads the connection settings for Copilot Studio from environment variables.\r\n * @returns The connection settings.\r\n */\r\nexport const loadCopilotStudioConnectionSettingsFromEnv: () => ConnectionSettings = () => {\r\n  return new ConnectionSettings({\r\n    appClientId: process.env.appClientId ?? '',\r\n    tenantId: process.env.tenantId ?? '',\r\n    authority: process.env.authorityEndpoint ?? 'https://login.microsoftonline.com',\r\n    environmentId: process.env.environmentId ?? '',\r\n    agentIdentifier: process.env.agentIdentifier ?? '',\r\n    cloud: process.env.cloud as PowerPlatformCloud,\r\n    customPowerPlatformCloud: process.env.customPowerPlatformCloud,\r\n    copilotAgentType: process.env.copilotAgentType as AgentType,\r\n    directConnectUrl: process.env.directConnectUrl,\r\n    useExperimentalEndpoint: process.env.useExperimentalEndpoint?.toLowerCase() === 'true'\r\n  })\r\n}\r\n", "/**\n * The type of error that occurred.\n * @public\n */\nexport type ErrorType = 'invalid-retry' | 'unknown-field'\n\n/**\n * Error thrown when encountering an issue during parsing.\n *\n * @public\n */\nexport class ParseError extends Error {\n  /**\n   * The type of error that occurred.\n   */\n  type: ErrorType\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the field name.\n   */\n  field?: string | undefined\n\n  /**\n   * In the case of an unknown field encountered in the stream, this will be the value of the field.\n   */\n  value?: string | undefined\n\n  /**\n   * The line that caused the error, if available.\n   */\n  line?: string | undefined\n\n  constructor(\n    message: string,\n    options: {type: ErrorType; field?: string; value?: string; line?: string},\n  ) {\n    super(message)\n    this.name = 'ParseError'\n    this.type = options.type\n    this.field = options.field\n    this.value = options.value\n    this.line = options.line\n  }\n}\n", "/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n */\nimport {ParseError} from './errors.ts'\nimport type {EventSourceParser, ParserCallbacks} from './types.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction noop(_arg: unknown) {\n  // intentional noop\n}\n\n/**\n * Creates a new EventSource parser.\n *\n * @param callbacks - Callbacks to invoke on different parsing events:\n *   - `onEvent` when a new event is parsed\n *   - `onError` when an error occurs\n *   - `onRetry` when a new reconnection interval has been sent from the server\n *   - `onComment` when a comment is encountered in the stream\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(callbacks: ParserCallbacks): EventSourceParser {\n  if (typeof callbacks === 'function') {\n    throw new TypeError(\n      '`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?',\n    )\n  }\n\n  const {onEvent = noop, onError = noop, onRetry = noop, onComment} = callbacks\n\n  let incompleteLine = ''\n\n  let isFirstChunk = true\n  let id: string | undefined\n  let data = ''\n  let eventType = ''\n\n  function feed(newChunk: string) {\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, '') : newChunk\n\n    // If there was a previous incomplete line, append it to the new chunk,\n    // so we may process it together as a new (hopefully complete) chunk.\n    const [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`)\n\n    for (const line of complete) {\n      parseLine(line)\n    }\n\n    incompleteLine = incomplete\n    isFirstChunk = false\n  }\n\n  function parseLine(line: string) {\n    // If the line is empty (a blank line), dispatch the event\n    if (line === '') {\n      dispatchEvent()\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:), ignore the line.\n    if (line.startsWith(':')) {\n      if (onComment) {\n        onComment(line.slice(line.startsWith(': ') ? 2 : 1))\n      }\n      return\n    }\n\n    // If the line contains a U+003A COLON character (:)\n    const fieldSeparatorIndex = line.indexOf(':')\n    if (fieldSeparatorIndex !== -1) {\n      // Collect the characters on the line before the first U+003A COLON character (:),\n      // and let `field` be that string.\n      const field = line.slice(0, fieldSeparatorIndex)\n\n      // Collect the characters on the line after the first U+003A COLON character (:),\n      // and let `value` be that string. If value starts with a U+0020 SPACE character,\n      // remove it from value.\n      const offset = line[fieldSeparatorIndex + 1] === ' ' ? 2 : 1\n      const value = line.slice(fieldSeparatorIndex + offset)\n\n      processField(field, value, line)\n      return\n    }\n\n    // Otherwise, the string is not empty but does not contain a U+003A COLON character (:)\n    // Process the field using the whole line as the field name, and an empty string as the field value.\n    // ðŸ‘† This is according to spec. That means that a line that has the value `data` will result in\n    // a newline being added to the current `data` buffer, for instance.\n    processField(line, '', line)\n  }\n\n  function processField(field: string, value: string, line: string) {\n    // Field names must be compared literally, with no case folding performed.\n    switch (field) {\n      case 'event':\n        // Set the `event type` buffer to field value\n        eventType = value\n        break\n      case 'data':\n        // Append the field value to the `data` buffer, then append a single U+000A LINE FEED(LF)\n        // character to the `data` buffer.\n        data = `${data}${value}\\n`\n        break\n      case 'id':\n        // If the field value does not contain U+0000 NULL, then set the `ID` buffer to\n        // the field value. Otherwise, ignore the field.\n        id = value.includes('\\0') ? undefined : value\n        break\n      case 'retry':\n        // If the field value consists of only ASCII digits, then interpret the field value as an\n        // integer in base ten, and set the event stream's reconnection time to that integer.\n        // Otherwise, ignore the field.\n        if (/^\\d+$/.test(value)) {\n          onRetry(parseInt(value, 10))\n        } else {\n          onError(\n            new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n              type: 'invalid-retry',\n              value,\n              line,\n            }),\n          )\n        }\n        break\n      default:\n        // Otherwise, the field is ignored.\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}â€¦` : field}\"`,\n            {type: 'unknown-field', field, value, line},\n          ),\n        )\n        break\n    }\n  }\n\n  function dispatchEvent() {\n    const shouldDispatch = data.length > 0\n    if (shouldDispatch) {\n      onEvent({\n        id,\n        event: eventType || undefined,\n        // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n        // then remove the last character from the data buffer.\n        data: data.endsWith('\\n') ? data.slice(0, -1) : data,\n      })\n    }\n\n    // Reset for the next event\n    id = undefined\n    data = ''\n    eventType = ''\n  }\n\n  function reset(options: {consume?: boolean} = {}) {\n    if (incompleteLine && options.consume) {\n      parseLine(incompleteLine)\n    }\n\n    isFirstChunk = true\n    id = undefined\n    data = ''\n    eventType = ''\n    incompleteLine = ''\n  }\n\n  return {feed, reset}\n}\n\n/**\n * For the given `chunk`, split it into lines according to spec, and return any remaining incomplete line.\n *\n * @param chunk - The chunk to split into lines\n * @returns A tuple containing an array of complete lines, and any remaining incomplete line\n * @internal\n */\nfunction splitLines(chunk: string): [complete: Array<string>, incomplete: string] {\n  /**\n   * According to the spec, a line is terminated by either:\n   * - U+000D CARRIAGE RETURN U+000A LINE FEED (CRLF) character pair\n   * - a single U+000A LINE FEED(LF) character not preceded by a U+000D CARRIAGE RETURN(CR) character\n   * - a single U+000D CARRIAGE RETURN(CR) character not followed by a U+000A LINE FEED(LF) character\n   */\n  const lines: Array<string> = []\n  let incompleteLine = ''\n  let searchIndex = 0\n\n  while (searchIndex < chunk.length) {\n    // Find next line terminator\n    const crIndex = chunk.indexOf('\\r', searchIndex)\n    const lfIndex = chunk.indexOf('\\n', searchIndex)\n\n    // Determine line end\n    let lineEnd = -1\n    if (crIndex !== -1 && lfIndex !== -1) {\n      // CRLF case\n      lineEnd = Math.min(crIndex, lfIndex)\n    } else if (crIndex !== -1) {\n      // CR at the end of a chunk might be part of a CRLF sequence that spans chunks,\n      // so we shouldn't treat it as a line terminator (yet)\n      if (crIndex === chunk.length - 1) {\n        lineEnd = -1\n      } else {\n        lineEnd = crIndex\n      }\n    } else if (lfIndex !== -1) {\n      lineEnd = lfIndex\n    }\n\n    // Extract line if terminator found\n    if (lineEnd === -1) {\n      // No terminator found, rest is incomplete\n      incompleteLine = chunk.slice(searchIndex)\n      break\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd)\n      lines.push(line)\n\n      // Move past line terminator\n      searchIndex = lineEnd + 1\n      if (chunk[searchIndex - 1] === '\\r' && chunk[searchIndex] === '\\n') {\n        searchIndex++\n      }\n    }\n  }\n\n  return [lines, incompleteLine]\n}\n", "// ReadyStates, mirrors WhatWG spec, but uses strings instead of numbers.\n// Why make it harder to read than it needs to be?\n\n/**\n * ReadyState representing a connection that is connecting or has been scheduled to reconnect.\n * @public\n */\nexport const CONNECTING = 'connecting'\n\n/**\n * ReadyState representing a connection that is open, eg connected.\n * @public\n */\nexport const OPEN = 'open'\n\n/**\n * ReadyState representing a connection that has been closed (manually, or due to an error).\n * @public\n */\nexport const CLOSED = 'closed'\n", "import {createParser} from 'eventsource-parser'\n\nimport type {EnvAbstractions, EventSourceAsyncValueResolver} from './abstractions.js'\nimport {CLOSED, CONNECTING, OPEN} from './constants.js'\nimport type {\n  EventSourceClient,\n  EventSourceMessage,\n  EventSourceOptions,\n  FetchLike,\n  FetchLikeInit,\n  FetchLikeResponse,\n  ReadyState,\n} from './types.js'\n\n/**\n * Intentional noop function for eased control flow\n */\nconst noop = () => {\n  /* intentional noop */\n}\n\n/**\n * Creates a new EventSource client. Used internally by the environment-specific entry points,\n * and should not be used directly by consumers.\n *\n * @param optionsOrUrl - Options for the client, or an URL/URL string.\n * @param abstractions - Abstractions for the environments.\n * @returns A new EventSource client instance\n * @internal\n */\nexport function createEventSource(\n  optionsOrUrl: EventSourceOptions | string | URL,\n  {getStream}: EnvAbstractions,\n): EventSourceClient {\n  const options =\n    typeof optionsOrUrl === 'string' || optionsOrUrl instanceof URL\n      ? {url: optionsOrUrl}\n      : optionsOrUrl\n  const {\n    onMessage,\n    onComment = noop,\n    onConnect = noop,\n    onDisconnect = noop,\n    onScheduleReconnect = noop,\n  } = options\n  const {fetch, url, initialLastEventId} = validate(options)\n  const requestHeaders = {...options.headers} // Prevent post-creation mutations to headers\n\n  const onCloseSubscribers: (() => void)[] = []\n  const subscribers: ((event: EventSourceMessage) => void)[] = onMessage ? [onMessage] : []\n  const emit = (event: EventSourceMessage) => subscribers.forEach((fn) => fn(event))\n  const parser = createParser({onEvent, onRetry, onComment})\n\n  // Client state\n  let request: Promise<unknown> | null\n  let currentUrl = url.toString()\n  let controller = new AbortController()\n  let lastEventId = initialLastEventId\n  let reconnectMs = 2000\n  let reconnectTimer: ReturnType<typeof setTimeout> | undefined\n  let readyState: ReadyState = CLOSED\n\n  // Let's go!\n  connect()\n\n  return {\n    close,\n    connect,\n    [Symbol.iterator]: () => {\n      throw new Error(\n        'EventSource does not support synchronous iteration. Use `for await` instead.',\n      )\n    },\n    [Symbol.asyncIterator]: getEventIterator,\n    get lastEventId() {\n      return lastEventId\n    },\n    get url() {\n      return currentUrl\n    },\n    get readyState() {\n      return readyState\n    },\n  }\n\n  function connect() {\n    if (request) {\n      return\n    }\n\n    readyState = CONNECTING\n    controller = new AbortController()\n    request = fetch(url, getRequestOptions())\n      .then(onFetchResponse)\n      .catch((err: Error & {type: string}) => {\n        request = null\n\n        // We expect abort errors when the user manually calls `close()` - ignore those\n        if (err.name === 'AbortError' || err.type === 'aborted' || controller.signal.aborted) {\n          return\n        }\n\n        scheduleReconnect()\n      })\n  }\n\n  function close() {\n    readyState = CLOSED\n    controller.abort()\n    parser.reset()\n    clearTimeout(reconnectTimer)\n    onCloseSubscribers.forEach((fn) => fn())\n  }\n\n  function getEventIterator(): AsyncGenerator<EventSourceMessage, void> {\n    const pullQueue: EventSourceAsyncValueResolver[] = []\n    const pushQueue: EventSourceMessage[] = []\n\n    function pullValue() {\n      return new Promise<IteratorResult<EventSourceMessage, void>>((resolve) => {\n        const value = pushQueue.shift()\n        if (value) {\n          resolve({value, done: false})\n        } else {\n          pullQueue.push(resolve)\n        }\n      })\n    }\n\n    const pushValue = function (value: EventSourceMessage) {\n      const resolve = pullQueue.shift()\n      if (resolve) {\n        resolve({value, done: false})\n      } else {\n        pushQueue.push(value)\n      }\n    }\n\n    function unsubscribe() {\n      subscribers.splice(subscribers.indexOf(pushValue), 1)\n      while (pullQueue.shift()) {}\n      while (pushQueue.shift()) {}\n    }\n\n    function onClose() {\n      const resolve = pullQueue.shift()\n      if (!resolve) {\n        return\n      }\n\n      resolve({done: true, value: undefined})\n      unsubscribe()\n    }\n\n    onCloseSubscribers.push(onClose)\n    subscribers.push(pushValue)\n\n    return {\n      next() {\n        return readyState === CLOSED ? this.return() : pullValue()\n      },\n      return() {\n        unsubscribe()\n        return Promise.resolve({done: true, value: undefined})\n      },\n      throw(error) {\n        unsubscribe()\n        return Promise.reject(error)\n      },\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  function scheduleReconnect() {\n    onScheduleReconnect({delay: reconnectMs})\n    if (controller.signal.aborted) {\n      return\n    }\n    readyState = CONNECTING\n    reconnectTimer = setTimeout(connect, reconnectMs)\n  }\n\n  async function onFetchResponse(response: FetchLikeResponse) {\n    onConnect()\n    parser.reset()\n\n    const {body, redirected, status} = response\n\n    // HTTP 204 means \"close the connection, no more data will be sent\"\n    if (status === 204) {\n      onDisconnect()\n      close()\n      return\n    }\n\n    if (!body) {\n      throw new Error('Missing response body')\n    }\n\n    if (redirected) {\n      currentUrl = response.url\n    }\n\n    // Ensure that the response stream is a web stream\n    // @todo Figure out a way to make this work without casting\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const stream = getStream(body as any)\n    const decoder = new TextDecoder()\n\n    const reader = stream.getReader()\n    let open = true\n\n    readyState = OPEN\n\n    do {\n      const {done, value} = await reader.read()\n      if (value) {\n        parser.feed(decoder.decode(value, {stream: !done}))\n      }\n\n      if (!done) {\n        continue\n      }\n\n      open = false\n      request = null\n      parser.reset()\n\n      // EventSources never close unless explicitly handled with `.close()`:\n      // Implementors should send an `done`/`complete`/`disconnect` event and\n      // explicitly handle it in client code, or send an HTTP 204.\n      scheduleReconnect()\n\n      // Calling scheduleReconnect() prior to onDisconnect() allows consumers to\n      // explicitly call .close() before the reconnection is performed.\n      onDisconnect()\n    } while (open)\n  }\n\n  function onEvent(msg: EventSourceMessage) {\n    if (typeof msg.id === 'string') {\n      lastEventId = msg.id\n    }\n\n    emit(msg)\n  }\n\n  function onRetry(ms: number) {\n    reconnectMs = ms\n  }\n\n  function getRequestOptions(): FetchLikeInit {\n    // @todo allow interception of options, but don't allow overriding signal\n    const {mode, credentials, body, method, redirect, referrer, referrerPolicy} = options\n    const lastEvent = lastEventId ? {'Last-Event-ID': lastEventId} : undefined\n    const headers = {Accept: 'text/event-stream', ...requestHeaders, ...lastEvent}\n    return {\n      mode,\n      credentials,\n      body,\n      method,\n      redirect,\n      referrer,\n      referrerPolicy,\n      headers,\n      cache: 'no-store',\n      signal: controller.signal,\n    }\n  }\n}\n\nfunction validate(options: EventSourceOptions): {\n  fetch: FetchLike\n  url: string | URL\n  initialLastEventId: string | undefined\n} {\n  const fetch = options.fetch || globalThis.fetch\n  if (!isFetchLike(fetch)) {\n    throw new Error('No fetch implementation provided, and one was not found on the global object.')\n  }\n\n  if (typeof AbortController !== 'function') {\n    throw new Error('Missing AbortController implementation')\n  }\n\n  const {url, initialLastEventId} = options\n\n  if (typeof url !== 'string' && !(url instanceof URL)) {\n    throw new Error('Invalid URL provided - must be string or URL instance')\n  }\n\n  if (typeof initialLastEventId !== 'string' && initialLastEventId !== undefined) {\n    throw new Error('Invalid initialLastEventId provided - must be string or undefined')\n  }\n\n  return {fetch, url, initialLastEventId}\n}\n\n// This is obviously naive, but hard to probe for full compatibility\nfunction isFetchLike(fetch: FetchLike | typeof globalThis.fetch): fetch is FetchLike {\n  return typeof fetch === 'function'\n}\n", "import type {EnvAbstractions} from './abstractions.js'\nimport {createEventSource as createSource} from './client.js'\nimport type {EventSourceClient, EventSourceOptions} from './types.js'\n\nexport * from './constants.js'\nexport * from './types.js'\n\n/**\n * Default \"abstractions\", eg when all the APIs are globally available\n */\nconst defaultAbstractions: EnvAbstractions = {\n  getStream,\n}\n\n/**\n * Creates a new EventSource client.\n *\n * @param optionsOrUrl - Options for the client, or an URL/URL string.\n * @returns A new EventSource client instance\n * @public\n */\nexport function createEventSource(\n  optionsOrUrl: EventSourceOptions | URL | string,\n): EventSourceClient {\n  return createSource(optionsOrUrl, defaultAbstractions)\n}\n\n/**\n * Returns a ReadableStream (Web Stream) from either an existing ReadableStream.\n * Only defined because of environment abstractions - is actually a 1:1 (passthrough).\n *\n * @param body - The body to convert\n * @returns A ReadableStream\n * @private\n */\nfunction getStream(\n  body: NodeJS.ReadableStream | ReadableStream<Uint8Array>,\n): ReadableStream<Uint8Array> {\n  if (!(body instanceof ReadableStream)) {\n    throw new Error('Invalid stream, expected a web ReadableStream')\n  }\n\n  return body\n}\n", "/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n", "\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n", "/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport createDebug, { Debugger } from 'debug'\r\n\r\nconst loggerLevels = [\r\n  'info',\r\n  'warn',\r\n  'error',\r\n  'debug',\r\n] as const\r\n\r\ntype LoggerLevels = typeof loggerLevels[number]\r\n\r\n/**\r\n * Logger class that provides colored logging functionality using the debug package.\r\n * Supports different log levels: info, warn, error, and debug.\r\n */\r\nexport class Logger {\r\n  private loggers: { [K in LoggerLevels]: Debugger } = {} as any\r\n\r\n  /**\r\n   * Creates a new Logger instance with the specified namespace.\r\n   * @param namespace The namespace to use for the logger\r\n   */\r\n  constructor (namespace: string = '') {\r\n    this.initializeLoggers(namespace)\r\n  }\r\n\r\n  private initializeLoggers (namespace: string) {\r\n    for (const level of loggerLevels) {\r\n      const logger = createDebug(`${namespace}:${level}`)\r\n      logger.color = this.getPlatformColor(level)\r\n      this.loggers[level] = logger\r\n    }\r\n  }\r\n\r\n  private getPlatformColor (level: LoggerLevels): string {\r\n    const platform = typeof window !== 'undefined' ? 'browser' : 'node'\r\n    const colors = {\r\n      node: {\r\n        info: '2', // Green\r\n        warn: '3', // Yellow\r\n        error: '1', // Red\r\n        debug: '4', // Blue\r\n      },\r\n      browser: {\r\n        info: '#33CC99', // Green\r\n        warn: '#CCCC33', // Yellow\r\n        error: '#CC3366', // Red\r\n        debug: '#0066FF', // Blue\r\n      },\r\n    }\r\n\r\n    return colors[platform][level]\r\n  }\r\n\r\n  /**\r\n   * Logs an informational message.\r\n   * @param message The message to log\r\n   * @param args Additional arguments to include in the log\r\n   */\r\n  info (message: string, ...args: any[]) {\r\n    this.loggers.info(message, ...args)\r\n  }\r\n\r\n  /**\r\n   * Logs a warning message.\r\n   * @param message The message to log\r\n   * @param args Additional arguments to include in the log\r\n   */\r\n  warn (message: string, ...args: any[]) {\r\n    this.loggers.warn(message, ...args)\r\n  }\r\n\r\n  /**\r\n   * Logs an error message.\r\n   * @param message The message to log\r\n   * @param args Additional arguments to include in the log\r\n   */\r\n  error (message: string, ...args: any[]) {\r\n    this.loggers.error(message, ...args)\r\n  }\r\n\r\n  /**\r\n   * Logs a debug message.\r\n   * @param message The message to log\r\n   * @param args Additional arguments to include in the log\r\n   */\r\n  debug (message: string, ...args: any[]) {\r\n    this.loggers.debug(message, ...args)\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a new Logger instance with the specified namespace.\r\n * @param namespace The namespace to use for the logger\r\n * @returns A new Logger instance\r\n */\r\nexport function debug (namespace: string): Logger {\r\n  return new Logger(namespace)\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Strategy } from './strategy'\r\n\r\nexport interface PrebuiltBotStrategySettings {\r\n  readonly host: URL;\r\n  readonly identifier: string;\r\n}\r\n\r\nexport class PrebuiltBotStrategy implements Strategy {\r\n  private readonly API_VERSION = '2022-03-01-preview'\r\n  private baseURL: URL\r\n\r\n  constructor (settings: PrebuiltBotStrategySettings) {\r\n    const { identifier, host } = settings\r\n\r\n    this.baseURL = new URL(\r\n      `/copilotstudio/prebuilt/authenticated/bots/${identifier}`,\r\n      host\r\n    )\r\n    this.baseURL.searchParams.append('api-version', this.API_VERSION)\r\n  }\r\n\r\n  public getConversationUrl (conversationId?: string): string {\r\n    const conversationUrl = new URL(this.baseURL.href)\r\n    conversationUrl.pathname = `${conversationUrl.pathname}/conversations`\r\n\r\n    if (conversationId) {\r\n      conversationUrl.pathname = `${conversationUrl.pathname}/${conversationId}`\r\n    }\r\n\r\n    return conversationUrl.href\r\n  }\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Strategy } from './strategy'\r\n\r\nexport interface PublishedBotStrategySettings {\r\n  readonly host: URL;\r\n  readonly schema: string;\r\n}\r\n\r\nexport class PublishedBotStrategy implements Strategy {\r\n  private readonly API_VERSION = '2022-03-01-preview'\r\n  private baseURL: URL\r\n\r\n  constructor (settings: PublishedBotStrategySettings) {\r\n    const { schema, host } = settings\r\n\r\n    this.baseURL = new URL(\r\n      `/copilotstudio/dataverse-backed/authenticated/bots/${schema}`,\r\n      host\r\n    )\r\n    this.baseURL.searchParams.append('api-version', this.API_VERSION)\r\n  }\r\n\r\n  public getConversationUrl (conversationId?: string): string {\r\n    const conversationUrl = new URL(this.baseURL.href)\r\n    conversationUrl.pathname = `${conversationUrl.pathname}/conversations`\r\n\r\n    if (conversationId) {\r\n      conversationUrl.pathname = `${conversationUrl.pathname}/${conversationId}`\r\n    }\r\n\r\n    return conversationUrl.href\r\n  }\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AgentType } from './agentType'\r\nimport { ConnectionSettings } from './connectionSettings'\r\nimport { debug } from '@microsoft/agents-activity/logger'\r\nimport { PowerPlatformCloud } from './powerPlatformCloud'\r\nimport { PrebuiltBotStrategy } from './strategies/prebuiltBotStrategy'\r\nimport { PublishedBotStrategy } from './strategies/publishedBotStrategy'\r\n\r\nconst logger = debug('copilot-studio:power-platform')\r\n\r\n/**\r\n * Generates the connection URL for Copilot Studio.\r\n * @param settings - The connection settings.\r\n * @param conversationId - Optional conversation ID.\r\n * @returns The connection URL.\r\n * @throws Will throw an error if required settings are missing or invalid.\r\n */\r\nexport function getCopilotStudioConnectionUrl (\r\n  settings: ConnectionSettings,\r\n  conversationId?: string\r\n): string {\r\n  if (settings.directConnectUrl?.trim()) {\r\n    logger.debug(`Using direct connection: ${settings.directConnectUrl}`)\r\n    if (!isValidUri(settings.directConnectUrl)) {\r\n      throw new Error('directConnectUrl must be a valid URL')\r\n    }\r\n\r\n    // FIX for Missing Tenant ID\r\n    if (settings.directConnectUrl.toLowerCase().includes('tenants/00000000-0000-0000-0000-000000000000')) {\r\n      logger.debug(`Direct connection cannot be used, forcing default settings flow. Tenant ID is missing in the URL: ${settings.directConnectUrl}`)\r\n      // Direct connection cannot be used, ejecting and forcing the normal settings flow:\r\n      return getCopilotStudioConnectionUrl({ ...settings, directConnectUrl: '' }, conversationId)\r\n    }\r\n\r\n    return createURL(settings.directConnectUrl, conversationId).href\r\n  }\r\n\r\n  const cloudSetting = settings.cloud ?? PowerPlatformCloud.Prod\r\n  const agentType = settings.copilotAgentType ?? AgentType.Published\r\n\r\n  logger.debug(`Using cloud setting: ${cloudSetting}`)\r\n  logger.debug(`Using agent type: ${agentType}`)\r\n\r\n  if (!settings.environmentId?.trim()) {\r\n    throw new Error('EnvironmentId must be provided')\r\n  }\r\n\r\n  if (!settings.agentIdentifier?.trim()) {\r\n    throw new Error('AgentIdentifier must be provided')\r\n  }\r\n\r\n  if (cloudSetting === PowerPlatformCloud.Other) {\r\n    if (!settings.customPowerPlatformCloud?.trim()) {\r\n      throw new Error('customPowerPlatformCloud must be provided when PowerPlatformCloud is Other')\r\n    } else if (isValidUri(settings.customPowerPlatformCloud)) {\r\n      logger.debug(`Using custom Power Platform cloud: ${settings.customPowerPlatformCloud}`)\r\n    } else {\r\n      throw new Error(\r\n        'customPowerPlatformCloud must be a valid URL'\r\n      )\r\n    }\r\n  }\r\n\r\n  const host = getEnvironmentEndpoint(cloudSetting, settings.environmentId, settings.customPowerPlatformCloud)\r\n\r\n  const strategy = {\r\n    [AgentType.Published]: () => new PublishedBotStrategy({\r\n      host,\r\n      schema: settings.agentIdentifier!,\r\n    }),\r\n    [AgentType.Prebuilt]: () => new PrebuiltBotStrategy({\r\n      host,\r\n      identifier: settings.agentIdentifier!,\r\n    }),\r\n  }[agentType]()\r\n\r\n  const url = strategy.getConversationUrl(conversationId)\r\n  logger.debug(`Generated Copilot Studio connection URL: ${url}`)\r\n  return url\r\n}\r\n\r\n/**\r\n * Returns the Power Platform API Audience.\r\n * @param settings - Configuration Settings to use.\r\n * @param cloud - Optional Power Platform Cloud Hosting Agent.\r\n * @param cloudBaseAddress - Optional Power Platform API endpoint to use if Cloud is configured as \"other\".\r\n * @param directConnectUrl - Optional DirectConnection URL to a given Copilot Studio agent, if provided all other settings are ignored.\r\n * @returns The Power Platform Audience.\r\n * @throws Will throw an error if required settings are missing or invalid.\r\n */\r\nexport function getTokenAudience (\r\n  settings?: ConnectionSettings,\r\n  cloud: PowerPlatformCloud = PowerPlatformCloud.Unknown,\r\n  cloudBaseAddress: string = '',\r\n  directConnectUrl: string = ''): string {\r\n  if (!directConnectUrl && !settings?.directConnectUrl) {\r\n    if (cloud === PowerPlatformCloud.Other && !cloudBaseAddress) {\r\n      throw new Error('cloudBaseAddress must be provided when PowerPlatformCloudCategory is Other')\r\n    }\r\n    if (!settings && cloud === PowerPlatformCloud.Unknown) {\r\n      throw new Error('Either settings or cloud must be provided')\r\n    }\r\n    if (settings && settings.cloud && settings.cloud !== PowerPlatformCloud.Unknown) {\r\n      cloud = settings.cloud\r\n    }\r\n    if (cloud === PowerPlatformCloud.Other) {\r\n      if (cloudBaseAddress && isValidUri(cloudBaseAddress)) {\r\n        cloud = PowerPlatformCloud.Other\r\n      } else if (settings?.customPowerPlatformCloud && isValidUri(settings!.customPowerPlatformCloud)) {\r\n        cloud = PowerPlatformCloud.Other\r\n        cloudBaseAddress = settings.customPowerPlatformCloud\r\n      } else {\r\n        throw new Error('Either CustomPowerPlatformCloud or cloudBaseAddress must be provided when PowerPlatformCloudCategory is Other')\r\n      }\r\n    }\r\n    cloudBaseAddress ??= 'api.unknown.powerplatform.com'\r\n    return `https://${getEndpointSuffix(cloud, cloudBaseAddress)}/.default`\r\n  } else {\r\n    if (!directConnectUrl) {\r\n      directConnectUrl = settings?.directConnectUrl ?? ''\r\n    }\r\n    if (directConnectUrl && isValidUri(directConnectUrl)) {\r\n      if (decodeCloudFromURI(new URL(directConnectUrl)) === PowerPlatformCloud.Unknown) {\r\n        const cloudToTest: PowerPlatformCloud = settings?.cloud ?? cloud\r\n\r\n        if (cloudToTest === PowerPlatformCloud.Other || cloudToTest === PowerPlatformCloud.Unknown) {\r\n          throw new Error('Unable to resolve the PowerPlatform Cloud from DirectConnectUrl. The Token Audience resolver requires a specific PowerPlatformCloudCategory.')\r\n        }\r\n        if ((cloudToTest as PowerPlatformCloud) !== PowerPlatformCloud.Unknown) {\r\n          return `https://${getEndpointSuffix(cloudToTest, '')}/.default`\r\n        } else {\r\n          throw new Error('Unable to resolve the PowerPlatform Cloud from DirectConnectUrl. The Token Audience resolver requires a specific PowerPlatformCloudCategory.')\r\n        }\r\n      }\r\n      return `https://${getEndpointSuffix(decodeCloudFromURI(new URL(directConnectUrl)), '')}/.default`\r\n    } else {\r\n      throw new Error('DirectConnectUrl must be provided when DirectConnectUrl is set')\r\n    }\r\n  }\r\n}\r\nfunction isValidUri (uri: string): boolean {\r\n  try {\r\n    const absoluteUrl = uri.startsWith('http') ? uri : `https://${uri}`\r\n    const newUri = new URL(absoluteUrl)\r\n    return !!newUri\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction createURL (base: string, conversationId?: string): URL {\r\n  const url = new URL(base)\r\n\r\n  if (!url.searchParams.has('api-version')) {\r\n    url.searchParams.append('api-version', '2022-03-01-preview')\r\n  }\r\n\r\n  if (url.pathname.endsWith('/')) {\r\n    url.pathname = url.pathname.slice(0, -1)\r\n  }\r\n\r\n  if (url.pathname.includes('/conversations')) {\r\n    url.pathname = url.pathname.substring(0, url.pathname.indexOf('/conversations'))\r\n  }\r\n\r\n  url.pathname = `${url.pathname}/conversations`\r\n  if (conversationId) {\r\n    url.pathname = `${url.pathname}/${conversationId}`\r\n  }\r\n\r\n  return url\r\n}\r\n\r\nfunction getEnvironmentEndpoint (\r\n  cloud: PowerPlatformCloud,\r\n  environmentId: string,\r\n  cloudBaseAddress?: string\r\n): URL {\r\n  if (cloud === PowerPlatformCloud.Other && (!cloudBaseAddress || !cloudBaseAddress.trim())) {\r\n    throw new Error('cloudBaseAddress must be provided when PowerPlatformCloud is Other')\r\n  }\r\n\r\n  cloudBaseAddress = cloudBaseAddress ?? 'api.unknown.powerplatform.com'\r\n\r\n  const normalizedResourceId = environmentId.toLowerCase().replaceAll('-', '')\r\n  const idSuffixLength = getIdSuffixLength(cloud)\r\n  const hexPrefix = normalizedResourceId.substring(0, normalizedResourceId.length - idSuffixLength)\r\n  const hexSuffix = normalizedResourceId.substring(normalizedResourceId.length - idSuffixLength)\r\n\r\n  return new URL(`https://${hexPrefix}.${hexSuffix}.environment.${getEndpointSuffix(cloud, cloudBaseAddress)}`)\r\n}\r\n\r\nfunction getEndpointSuffix (\r\n  category: PowerPlatformCloud,\r\n  cloudBaseAddress: string\r\n): string {\r\n  switch (category) {\r\n    case PowerPlatformCloud.Local:\r\n      return 'api.powerplatform.localhost'\r\n    case PowerPlatformCloud.Exp:\r\n      return 'api.exp.powerplatform.com'\r\n    case PowerPlatformCloud.Dev:\r\n      return 'api.dev.powerplatform.com'\r\n    case PowerPlatformCloud.Prv:\r\n      return 'api.prv.powerplatform.com'\r\n    case PowerPlatformCloud.Test:\r\n      return 'api.test.powerplatform.com'\r\n    case PowerPlatformCloud.Preprod:\r\n      return 'api.preprod.powerplatform.com'\r\n    case PowerPlatformCloud.FirstRelease:\r\n    case PowerPlatformCloud.Prod:\r\n      return 'api.powerplatform.com'\r\n    case PowerPlatformCloud.GovFR:\r\n      return 'api.gov.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.Gov:\r\n      return 'api.gov.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.High:\r\n      return 'api.high.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.DoD:\r\n      return 'api.appsplatform.us'\r\n    case PowerPlatformCloud.Mooncake:\r\n      return 'api.powerplatform.partner.microsoftonline.cn'\r\n    case PowerPlatformCloud.Ex:\r\n      return 'api.powerplatform.eaglex.ic.gov'\r\n    case PowerPlatformCloud.Rx:\r\n      return 'api.powerplatform.microsoft.scloud'\r\n    case PowerPlatformCloud.Other:\r\n      return cloudBaseAddress\r\n    default:\r\n      throw new Error(`Invalid cluster category value: ${category}`)\r\n  }\r\n}\r\n\r\nfunction getIdSuffixLength (cloud: PowerPlatformCloud): number {\r\n  switch (cloud) {\r\n    case PowerPlatformCloud.FirstRelease:\r\n    case PowerPlatformCloud.Prod:\r\n      return 2\r\n    default:\r\n      return 1\r\n  }\r\n}\r\n\r\nfunction decodeCloudFromURI (uri: URL): PowerPlatformCloud {\r\n  const host = uri.host.toLowerCase()\r\n\r\n  switch (host) {\r\n    case 'api.powerplatform.localhost':\r\n      return PowerPlatformCloud.Local\r\n    case 'api.exp.powerplatform.com':\r\n      return PowerPlatformCloud.Exp\r\n    case 'api.dev.powerplatform.com':\r\n      return PowerPlatformCloud.Dev\r\n    case 'api.prv.powerplatform.com':\r\n      return PowerPlatformCloud.Prv\r\n    case 'api.test.powerplatform.com':\r\n      return PowerPlatformCloud.Test\r\n    case 'api.preprod.powerplatform.com':\r\n      return PowerPlatformCloud.Preprod\r\n    case 'api.powerplatform.com':\r\n      return PowerPlatformCloud.Prod\r\n    case 'api.gov.powerplatform.microsoft.us':\r\n      return PowerPlatformCloud.GovFR\r\n    case 'api.high.powerplatform.microsoft.us':\r\n      return PowerPlatformCloud.High\r\n    case 'api.appsplatform.us':\r\n      return PowerPlatformCloud.DoD\r\n    case 'api.powerplatform.partner.microsoftonline.cn':\r\n      return PowerPlatformCloud.Mooncake\r\n    default:\r\n      return PowerPlatformCloud.Unknown\r\n  }\r\n}\r\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;\nvar util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (exports.util = util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (exports.objectUtil = objectUtil = {}));\nexports.ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return exports.ZodParsedType.undefined;\n        case \"string\":\n            return exports.ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;\n        case \"boolean\":\n            return exports.ZodParsedType.boolean;\n        case \"function\":\n            return exports.ZodParsedType.function;\n        case \"bigint\":\n            return exports.ZodParsedType.bigint;\n        case \"symbol\":\n            return exports.ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return exports.ZodParsedType.array;\n            }\n            if (data === null) {\n                return exports.ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return exports.ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return exports.ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return exports.ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return exports.ZodParsedType.date;\n            }\n            return exports.ZodParsedType.object;\n        default:\n            return exports.ZodParsedType.unknown;\n    }\n};\nexports.getParsedType = getParsedType;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;\nconst util_js_1 = require(\"./helpers/util.cjs\");\nexports.ZodIssueCode = util_js_1.util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexports.quotelessJson = quotelessJson;\nclass ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util_js_1.util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nexports.ZodError = ZodError;\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ZodError_js_1 = require(\"../ZodError.cjs\");\nconst util_js_1 = require(\"../helpers/util.cjs\");\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodError_js_1.ZodIssueCode.invalid_type:\n            if (issue.received === util_js_1.ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_js_1.util.jsonStringifyReplacer)}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util_js_1.util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util_js_1.util.joinValues(issue.options)}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util_js_1.util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util_js_1.util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodError_js_1.ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_js_1.ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodError_js_1.ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodError_js_1.ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodError_js_1.ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodError_js_1.ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util_js_1.util.assertNever(issue);\n    }\n    return { message };\n};\nexports.default = errorMap;\n", "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultErrorMap = void 0;\nexports.setErrorMap = setErrorMap;\nexports.getErrorMap = getErrorMap;\nconst en_js_1 = __importDefault(require(\"./locales/en.cjs\"));\nexports.defaultErrorMap = en_js_1.default;\nlet overrideErrorMap = en_js_1.default;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n", "\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.EMPTY_PATH = exports.makeIssue = void 0;\nexports.addIssueToContext = addIssueToContext;\nconst errors_js_1 = require(\"../errors.cjs\");\nconst en_js_1 = __importDefault(require(\"../locales/en.cjs\"));\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexports.makeIssue = makeIssue;\nexports.EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = (0, errors_js_1.getErrorMap)();\n    const issue = (0, exports.makeIssue)({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === en_js_1.default ? undefined : en_js_1.default, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return exports.INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return exports.INVALID;\n            if (value.status === \"aborted\")\n                return exports.INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexports.ParseStatus = ParseStatus;\nexports.INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nexports.DIRTY = DIRTY;\nconst OK = (value) => ({ status: \"valid\", value });\nexports.OK = OK;\nconst isAborted = (x) => x.status === \"aborted\";\nexports.isAborted = isAborted;\nconst isDirty = (x) => x.status === \"dirty\";\nexports.isDirty = isDirty;\nconst isValid = (x) => x.status === \"valid\";\nexports.isValid = isValid;\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\nexports.isAsync = isAsync;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.errorUtil = void 0;\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (exports.errorUtil = errorUtil = {}));\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.discriminatedUnion = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;\nexports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = void 0;\nexports.datetimeRegex = datetimeRegex;\nexports.custom = custom;\nconst ZodError_js_1 = require(\"./ZodError.cjs\");\nconst errors_js_1 = require(\"./errors.cjs\");\nconst errorUtil_js_1 = require(\"./helpers/errorUtil.cjs\");\nconst parseUtil_js_1 = require(\"./helpers/parseUtil.cjs\");\nconst util_js_1 = require(\"./helpers/util.cjs\");\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if ((0, parseUtil_js_1.isValid)(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError_js_1.ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return (0, util_js_1.getParsedType)(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: (0, util_js_1.getParsedType)(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new parseUtil_js_1.ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: (0, util_js_1.getParsedType)(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if ((0, parseUtil_js_1.isAsync)(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return (0, parseUtil_js_1.isValid)(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => (0, parseUtil_js_1.isValid)(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: (0, util_js_1.getParsedType)(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await ((0, parseUtil_js_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodError_js_1.ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nexports.ZodType = ZodType;\nexports.Schema = ZodType;\nexports.ZodSchema = ZodType;\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const status = new parseUtil_js_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                            code: ZodError_js_1.ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                            code: ZodError_js_1.ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"email\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"emoji\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"uuid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cuid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"ulid\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"url\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"regex\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"duration\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"ip\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"jwt\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"cidr\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"base64\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        validation: \"base64url\",\n                        code: ZodError_js_1.ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodError_js_1.ZodIssueCode.invalid_string,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil_js_1.errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil_js_1.errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil_js_1.errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil_js_1.errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil_js_1.errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodString = ZodString;\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        let ctx = undefined;\n        const status = new parseUtil_js_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util_js_1.util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_js_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util_js_1.util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nexports.ZodNumber = ZodNumber;\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new parseUtil_js_1.ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n            code: ZodError_js_1.ZodIssueCode.invalid_type,\n            expected: util_js_1.ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return parseUtil_js_1.INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil_js_1.errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil_js_1.errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil_js_1.errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nexports.ZodBigInt = ZodBigInt;\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodBoolean = ZodBoolean;\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_date,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const status = new parseUtil_js_1.ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util_js_1.util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil_js_1.errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nexports.ZodDate = ZodDate;\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodSymbol = ZodSymbol;\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodUndefined = ZodUndefined;\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodNull = ZodNull;\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodAny = ZodAny;\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodUnknown = ZodUnknown;\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        (0, parseUtil_js_1.addIssueToContext)(ctx, {\n            code: ZodError_js_1.ZodIssueCode.invalid_type,\n            expected: util_js_1.ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return parseUtil_js_1.INVALID;\n    }\n}\nexports.ZodNever = ZodNever;\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n}\nexports.ZodVoid = ZodVoid;\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: tooBig ? ZodError_js_1.ZodIssueCode.too_big : ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return parseUtil_js_1.ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return parseUtil_js_1.ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodArray = ZodArray;\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util_js_1.util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                        code: ZodError_js_1.ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return parseUtil_js_1.ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil_js_1.errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil_js_1.errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util_js_1.util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util_js_1.util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util_js_1.util.objectKeys(this.shape));\n    }\n}\nexports.ZodObject = ZodObject;\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError_js_1.ZodError(result.ctx.common.issues));\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError_js_1.ZodError(issues));\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nexports.ZodUnion = ZodUnion;\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util_js_1.util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;\nfunction mergeValues(a, b) {\n    const aType = (0, util_js_1.getParsedType)(a);\n    const bType = (0, util_js_1.getParsedType)(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === util_js_1.ZodParsedType.object && bType === util_js_1.ZodParsedType.object) {\n        const bKeys = util_js_1.util.objectKeys(b);\n        const sharedKeys = util_js_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === util_js_1.ZodParsedType.array && bType === util_js_1.ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === util_js_1.ZodParsedType.date && bType === util_js_1.ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if ((0, parseUtil_js_1.isAborted)(parsedLeft) || (0, parseUtil_js_1.isAborted)(parsedRight)) {\n                return parseUtil_js_1.INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.invalid_intersection_types,\n                });\n                return parseUtil_js_1.INVALID;\n            }\n            if ((0, parseUtil_js_1.isDirty)(parsedLeft) || (0, parseUtil_js_1.isDirty)(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nexports.ZodIntersection = ZodIntersection;\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.array) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return parseUtil_js_1.ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nexports.ZodTuple = ZodTuple;\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.object) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return parseUtil_js_1.ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return parseUtil_js_1.ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexports.ZodRecord = ZodRecord;\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.map) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return parseUtil_js_1.INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return parseUtil_js_1.INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nexports.ZodMap = ZodMap;\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.set) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                    code: ZodError_js_1.ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil_js_1.errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nexports.ZodSet = ZodSet;\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.function) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return (0, parseUtil_js_1.makeIssue)({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_js_1.ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return (0, parseUtil_js_1.makeIssue)({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, (0, errors_js_1.getErrorMap)(), errors_js_1.defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodError_js_1.ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_js_1.OK)(async function (...args) {\n                const error = new ZodError_js_1.ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return (0, parseUtil_js_1.OK)(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError_js_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError_js_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexports.ZodFunction = ZodFunction;\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nexports.ZodLazy = ZodLazy;\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nexports.ZodLiteral = ZodLiteral;\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                expected: util_js_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nexports.ZodEnum = ZodEnum;\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util_js_1.util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.string && ctx.parsedType !== util_js_1.ZodParsedType.number) {\n            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                expected: util_js_1.util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util_js_1.util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util_js_1.util.objectValues(nativeEnumValues);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                received: ctx.data,\n                code: ZodError_js_1.ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return (0, parseUtil_js_1.OK)(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nexports.ZodNativeEnum = ZodNativeEnum;\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== util_js_1.ZodParsedType.promise && ctx.common.async === false) {\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        const promisified = ctx.parsedType === util_js_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return (0, parseUtil_js_1.OK)(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nexports.ZodPromise = ZodPromise;\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                (0, parseUtil_js_1.addIssueToContext)(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    if (result.status === \"dirty\")\n                        return (0, parseUtil_js_1.DIRTY)(result.value);\n                    if (status.value === \"dirty\")\n                        return (0, parseUtil_js_1.DIRTY)(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (result.status === \"dirty\")\n                    return (0, parseUtil_js_1.DIRTY)(result.value);\n                if (status.value === \"dirty\")\n                    return (0, parseUtil_js_1.DIRTY)(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return parseUtil_js_1.INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!(0, parseUtil_js_1.isValid)(base))\n                    return parseUtil_js_1.INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!(0, parseUtil_js_1.isValid)(base))\n                        return parseUtil_js_1.INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util_js_1.util.assertNever(effect);\n    }\n}\nexports.ZodEffects = ZodEffects;\nexports.ZodTransformer = ZodEffects;\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_js_1.ZodParsedType.undefined) {\n            return (0, parseUtil_js_1.OK)(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodOptional = ZodOptional;\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === util_js_1.ZodParsedType.null) {\n            return (0, parseUtil_js_1.OK)(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodNullable = ZodNullable;\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === util_js_1.ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nexports.ZodDefault = ZodDefault;\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if ((0, parseUtil_js_1.isAsync)(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError_js_1.ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError_js_1.ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nexports.ZodCatch = ZodCatch;\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== util_js_1.ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            (0, parseUtil_js_1.addIssueToContext)(ctx, {\n                code: ZodError_js_1.ZodIssueCode.invalid_type,\n                expected: util_js_1.ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return parseUtil_js_1.INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nexports.ZodNaN = ZodNaN;\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexports.BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexports.ZodBranded = ZodBranded;\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return parseUtil_js_1.INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return (0, parseUtil_js_1.DIRTY)(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return parseUtil_js_1.INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexports.ZodPipeline = ZodPipeline;\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if ((0, parseUtil_js_1.isValid)(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return (0, parseUtil_js_1.isAsync)(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nexports.ZodReadonly = ZodReadonly;\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nfunction custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexports.late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nexports.instanceof = instanceOfType;\nconst stringType = ZodString.create;\nexports.string = stringType;\nconst numberType = ZodNumber.create;\nexports.number = numberType;\nconst nanType = ZodNaN.create;\nexports.nan = nanType;\nconst bigIntType = ZodBigInt.create;\nexports.bigint = bigIntType;\nconst booleanType = ZodBoolean.create;\nexports.boolean = booleanType;\nconst dateType = ZodDate.create;\nexports.date = dateType;\nconst symbolType = ZodSymbol.create;\nexports.symbol = symbolType;\nconst undefinedType = ZodUndefined.create;\nexports.undefined = undefinedType;\nconst nullType = ZodNull.create;\nexports.null = nullType;\nconst anyType = ZodAny.create;\nexports.any = anyType;\nconst unknownType = ZodUnknown.create;\nexports.unknown = unknownType;\nconst neverType = ZodNever.create;\nexports.never = neverType;\nconst voidType = ZodVoid.create;\nexports.void = voidType;\nconst arrayType = ZodArray.create;\nexports.array = arrayType;\nconst objectType = ZodObject.create;\nexports.object = objectType;\nconst strictObjectType = ZodObject.strictCreate;\nexports.strictObject = strictObjectType;\nconst unionType = ZodUnion.create;\nexports.union = unionType;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nexports.discriminatedUnion = discriminatedUnionType;\nconst intersectionType = ZodIntersection.create;\nexports.intersection = intersectionType;\nconst tupleType = ZodTuple.create;\nexports.tuple = tupleType;\nconst recordType = ZodRecord.create;\nexports.record = recordType;\nconst mapType = ZodMap.create;\nexports.map = mapType;\nconst setType = ZodSet.create;\nexports.set = setType;\nconst functionType = ZodFunction.create;\nexports.function = functionType;\nconst lazyType = ZodLazy.create;\nexports.lazy = lazyType;\nconst literalType = ZodLiteral.create;\nexports.literal = literalType;\nconst enumType = ZodEnum.create;\nexports.enum = enumType;\nconst nativeEnumType = ZodNativeEnum.create;\nexports.nativeEnum = nativeEnumType;\nconst promiseType = ZodPromise.create;\nexports.promise = promiseType;\nconst effectsType = ZodEffects.create;\nexports.effect = effectsType;\nexports.transformer = effectsType;\nconst optionalType = ZodOptional.create;\nexports.optional = optionalType;\nconst nullableType = ZodNullable.create;\nexports.nullable = nullableType;\nconst preprocessType = ZodEffects.createWithPreprocess;\nexports.preprocess = preprocessType;\nconst pipelineType = ZodPipeline.create;\nexports.pipeline = pipelineType;\nconst ostring = () => stringType().optional();\nexports.ostring = ostring;\nconst onumber = () => numberType().optional();\nexports.onumber = onumber;\nconst oboolean = () => booleanType().optional();\nexports.oboolean = oboolean;\nexports.coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexports.NEVER = parseUtil_js_1.INVALID;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./errors.cjs\"), exports);\n__exportStar(require(\"./helpers/parseUtil.cjs\"), exports);\n__exportStar(require(\"./helpers/typeAliases.cjs\"), exports);\n__exportStar(require(\"./helpers/util.cjs\"), exports);\n__exportStar(require(\"./types.cjs\"), exports);\n__exportStar(require(\"./ZodError.cjs\"), exports);\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.z = void 0;\nconst z = __importStar(require(\"./v3/external.cjs\"));\nexports.z = z;\n__exportStar(require(\"./v3/external.cjs\"), exports);\nexports.default = z;\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing the types of actions.\r\n */\r\nexport enum ActionTypes {\r\n  /**\r\n   * Opens a URL in the default browser.\r\n   */\r\n  OpenUrl = 'openUrl',\r\n\r\n  /**\r\n   * Sends a message back to the bot as a simple string.\r\n   */\r\n  ImBack = 'imBack',\r\n\r\n  /**\r\n   * Sends a message back to the bot with additional data.\r\n   */\r\n  PostBack = 'postBack',\r\n\r\n  /**\r\n   * Plays an audio file.\r\n   */\r\n  PlayAudio = 'playAudio',\r\n\r\n  /**\r\n   * Plays a video file.\r\n   */\r\n  PlayVideo = 'playVideo',\r\n\r\n  /**\r\n   * Displays an image.\r\n   */\r\n  ShowImage = 'showImage',\r\n\r\n  /**\r\n   * Downloads a file.\r\n   */\r\n  DownloadFile = 'downloadFile',\r\n\r\n  /**\r\n   * Initiates a sign-in process.\r\n   */\r\n  Signin = 'signin',\r\n\r\n  /**\r\n   * Initiates a phone call.\r\n   */\r\n  Call = 'call',\r\n\r\n  /**\r\n   * Sends a message back to the bot with additional metadata.\r\n   */\r\n  MessageBack = 'messageBack',\r\n\r\n  /**\r\n   * Opens an application.\r\n   */\r\n  OpenApp = 'openApp',\r\n}\r\n\r\n/**\r\n * Zod schema for validating ActionTypes.\r\n */\r\nexport const actionTypesZodSchema = z.enum(['openUrl', 'imBack', 'postBack', 'playAudio', 'showImage', 'downloadFile', 'signin', 'call', 'messageBack', 'openApp'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing the state types of a semantic action.\r\n */\r\nexport enum SemanticActionStateTypes {\r\n  /**\r\n   * Indicates the start of a semantic action.\r\n   */\r\n  Start = 'start',\r\n\r\n  /**\r\n   * Indicates the continuation of a semantic action.\r\n   */\r\n  Continue = 'continue',\r\n\r\n  /**\r\n   * Indicates the completion of a semantic action.\r\n   */\r\n  Done = 'done',\r\n}\r\n\r\n/**\r\n * Zod schema for validating SemanticActionStateTypes.\r\n */\r\nexport const semanticActionStateTypesZodSchema = z.enum(['start', 'continue', 'done'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing the layout types for attachments.\r\n */\r\nexport enum AttachmentLayoutTypes {\r\n  /**\r\n   * Displays attachments in a list format.\r\n   */\r\n  List = 'list',\r\n\r\n  /**\r\n   * Displays attachments in a carousel format.\r\n   */\r\n  Carousel = 'carousel',\r\n}\r\n\r\n/**\r\n * Zod schema for validating attachment layout types.\r\n */\r\nexport const attachmentLayoutTypesZodSchema = z.enum(['list', 'carousel'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Enum representing the different channels an agent can communicate through.\r\n */\r\nexport enum Channels {\r\n  /**\r\n   * Represents the Alexa channel.\r\n   */\r\n  Alexa = 'alexa',\r\n\r\n  /**\r\n   * Represents the Console channel.\r\n   */\r\n  Console = 'console',\r\n\r\n  /**\r\n   * Represents the Directline channel.\r\n   */\r\n  Directline = 'directline',\r\n\r\n  /**\r\n   * Represents the Directline Speech channel.\r\n   */\r\n  DirectlineSpeech = 'directlinespeech',\r\n\r\n  /**\r\n   * Represents the Email channel.\r\n   */\r\n  Email = 'email',\r\n\r\n  /**\r\n   * Represents the Emulator channel.\r\n   */\r\n  Emulator = 'emulator',\r\n\r\n  /**\r\n   * Represents the Facebook channel.\r\n   */\r\n  Facebook = 'facebook',\r\n\r\n  /**\r\n   * Represents the GroupMe channel.\r\n   */\r\n  Groupme = 'groupme',\r\n\r\n  /**\r\n   * Represents the Line channel.\r\n   */\r\n  Line = 'line',\r\n\r\n  /**\r\n   * Represents the Microsoft Teams channel.\r\n   */\r\n  Msteams = 'msteams',\r\n\r\n  /**\r\n   * Represents the Omnichannel.\r\n   */\r\n  Omni = 'omnichannel',\r\n\r\n  /**\r\n   * Represents the Outlook channel.\r\n   */\r\n  Outlook = 'outlook',\r\n\r\n  /**\r\n   * Represents the Skype channel.\r\n   */\r\n  Skype = 'skype',\r\n\r\n  /**\r\n   * Represents the Slack channel.\r\n   */\r\n  Slack = 'slack',\r\n\r\n  /**\r\n   * Represents the SMS channel.\r\n   */\r\n  Sms = 'sms',\r\n\r\n  /**\r\n   * Represents the Telegram channel.\r\n   */\r\n  Telegram = 'telegram',\r\n\r\n  /**\r\n   * Represents the Telephony channel.\r\n   */\r\n  Telephony = 'telephony',\r\n\r\n  /**\r\n   * Represents the Test channel.\r\n   */\r\n  Test = 'test',\r\n\r\n  /**\r\n   * Represents the Webchat channel.\r\n   */\r\n  Webchat = 'webchat',\r\n}\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing the different end of conversation codes.\r\n */\r\nexport enum EndOfConversationCodes {\r\n  /**\r\n   * The end of conversation reason is unknown.\r\n   */\r\n  Unknown = 'unknown',\r\n\r\n  /**\r\n   * The conversation completed successfully.\r\n   */\r\n  CompletedSuccessfully = 'completedSuccessfully',\r\n\r\n  /**\r\n   * The user cancelled the conversation.\r\n   */\r\n  UserCancelled = 'userCancelled',\r\n\r\n  /**\r\n   * The agent timed out during the conversation.\r\n   */\r\n  AgentTimedOut = 'agentTimedOut',\r\n\r\n  /**\r\n   * The agent issued an invalid message.\r\n   */\r\n  AgentIssuedInvalidMessage = 'agentIssuedInvalidMessage',\r\n\r\n  /**\r\n   * The channel failed during the conversation.\r\n   */\r\n  ChannelFailed = 'channelFailed',\r\n}\r\n\r\n/**\r\n * Zod schema for validating end of conversation codes.\r\n */\r\nexport const endOfConversationCodesZodSchema = z.enum(['unknown', 'completedSuccessfully', 'userCancelled', 'agentTimedOut', 'agentIssuedInvalidMessage', 'channelFailed'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum defining the type of roster the user is a member of.\r\n */\r\nexport enum MembershipSourceTypes {\r\n  /**\r\n   * The source is that of a channel and the user is a member of that channel.\r\n   */\r\n  Channel = 'channel',\r\n\r\n  /**\r\n   * The source is that of a team and the user is a member of that team.\r\n   */\r\n  Team = 'team',\r\n}\r\n\r\n/**\r\n * Zod schema for validating membership source types.\r\n */\r\nexport const membershipSourceTypeZodSchema = z.enum(['channel', 'team'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum expressing the users relationship to the current channel.\r\n */\r\nexport enum MembershipTypes {\r\n  /**\r\n   * The user is a direct member of a channel.\r\n   */\r\n  Direct = 'direct',\r\n\r\n  /**\r\n   * The user is a member of a channel through a group.\r\n   */\r\n  Transitive = 'transitive',\r\n}\r\n\r\n/**\r\n * Zod schema for validating membership source types.\r\n */\r\nexport const membershipTypeZodSchema = z.enum(['direct', 'transitive'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing the different role types in a conversation.\r\n */\r\nexport enum RoleTypes {\r\n  /**\r\n   * Represents a user in the conversation.\r\n   */\r\n  User = 'user',\r\n\r\n  /**\r\n   * Represents an agent or bot in the conversation.\r\n   */\r\n  Agent = 'bot',\r\n\r\n  /**\r\n   * Represents a skill in the conversation.\r\n   */\r\n  Skill = 'skill',\r\n}\r\n\r\n/**\r\n * Zod schema for validating role types.\r\n */\r\nexport const roleTypeZodSchema = z.enum(['user', 'bot', 'skill'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Activity } from '../activity'\r\nimport { Entity } from './entity'\r\n\r\n/**\r\n * Supported icon names for client citations. These icons are displayed in Teams to help users\r\n * identify the type of content being referenced in AI-generated responses.\r\n */\r\nexport type ClientCitationIconName =\r\n  /** Microsoft Word document icon */\r\n  | 'Microsoft Word'\r\n  /** Microsoft Excel spreadsheet icon */\r\n  | 'Microsoft Excel'\r\n  /** Microsoft PowerPoint presentation icon */\r\n  | 'Microsoft PowerPoint'\r\n  /** Microsoft OneNote notebook icon */\r\n  | 'Microsoft OneNote'\r\n  /** Microsoft SharePoint site or document icon */\r\n  | 'Microsoft SharePoint'\r\n  /** Microsoft Visio diagram icon */\r\n  | 'Microsoft Visio'\r\n  /** Microsoft Loop component icon */\r\n  | 'Microsoft Loop'\r\n  /** Microsoft Whiteboard icon */\r\n  | 'Microsoft Whiteboard'\r\n  /** Adobe Illustrator vector graphics icon */\r\n  | 'Adobe Illustrator'\r\n  /** Adobe Photoshop image editing icon */\r\n  | 'Adobe Photoshop'\r\n  /** Adobe InDesign layout design icon */\r\n  | 'Adobe InDesign'\r\n  /** Adobe Flash multimedia icon */\r\n  | 'Adobe Flash'\r\n  /** Sketch design tool icon */\r\n  | 'Sketch'\r\n  /** Source code file icon */\r\n  | 'Source Code'\r\n  /** Generic image file icon */\r\n  | 'Image'\r\n  /** Animated GIF image icon */\r\n  | 'GIF'\r\n  /** Video file icon */\r\n  | 'Video'\r\n  /** Audio/sound file icon */\r\n  | 'Sound'\r\n  /** ZIP archive file icon */\r\n  | 'ZIP'\r\n  /** Plain text file icon */\r\n  | 'Text'\r\n  /** PDF document icon */\r\n  | 'PDF'\r\n\r\n/**\r\n *  Represents a Teams client citation to be included in a message.\r\n *\r\n * @remarks\r\n * [Learn more about Bot messages with AI-generated content](https://learn.microsoft.com/microsoftteams/platform/bots/how-to/bot-messages-ai-generated-content?tabs=before%2Cbotmessage)\r\n */\r\nexport interface ClientCitation {\r\n  /**\r\n   * Required; must be \"Claim\"\r\n   */\r\n  '@type': 'Claim';\r\n\r\n  /**\r\n   * Required. Number and position of the citation.\r\n   */\r\n  position: number;\r\n  /**\r\n   * Optional; if provided, the citation will be displayed in the message.\r\n   */\r\n  appearance: {\r\n    /**\r\n     * Required; Must be 'DigitalDocument'\r\n     */\r\n    '@type': 'DigitalDocument';\r\n\r\n    /**\r\n     * Name of the document. (max length 80)\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Stringified adaptive card with additional information about the citation.\r\n     * It is rendered within the modal.\r\n     */\r\n    text?: string;\r\n\r\n    /**\r\n     * URL of the document. This will make the name of the citation clickable and direct the user to the specified URL.\r\n     */\r\n    url?: string;\r\n\r\n    /**\r\n     * Extract of the referenced content. (max length 160)\r\n     */\r\n    abstract: string;\r\n\r\n    /**\r\n     * Encoding format of the `citation.appearance.text` field.\r\n     */\r\n    encodingFormat?: 'application/vnd.microsoft.card.adaptive';\r\n\r\n    /**\r\n     * Information about the citation\u2019s icon.\r\n     */\r\n    image?: {\r\n      '@type': 'ImageObject';\r\n\r\n      /**\r\n       * The image/icon name\r\n       */\r\n      name: ClientCitationIconName;\r\n    };\r\n\r\n    /**\r\n     * Optional; set by developer. (max length 3) (max keyword length 28)\r\n     */\r\n    keywords?: string[];\r\n\r\n    /**\r\n     * Optional sensitivity content information.\r\n     */\r\n    usageInfo?: SensitivityUsageInfo;\r\n  };\r\n}\r\n\r\n/**\r\n * Sensitivity usage info for content sent to the user.\r\n *\r\n * @remarks\r\n * This is used to provide information about the content to the user. See {@link ClientCitation} for more information.\r\n */\r\nexport interface SensitivityUsageInfo {\r\n  /**\r\n   * Must be \"https://schema.org/Message\"\r\n   */\r\n  type: 'https://schema.org/Message';\r\n\r\n  /**\r\n   * Required; Set to CreativeWork;\r\n   */\r\n  '@type': 'CreativeWork';\r\n\r\n  /**\r\n   * Sensitivity description of the content\r\n   */\r\n  description?: string;\r\n\r\n  /**\r\n   * Sensitivity title of the content\r\n   */\r\n  name: string;\r\n\r\n  /**\r\n   * Optional; ignored in Teams.\r\n   */\r\n  position?: number;\r\n\r\n  /**\r\n    * Optional; if provided, the content is considered sensitive and should be handled accordingly.\r\n    */\r\n  pattern?: {\r\n    /**\r\n     * Set to DefinedTerm\r\n     */\r\n    '@type': 'DefinedTerm';\r\n\r\n    inDefinedTermSet: string;\r\n\r\n    /**\r\n     * Color\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * e.g. #454545\r\n     */\r\n    termCode: string;\r\n  };\r\n}\r\n\r\nexport interface AIEntity extends Entity {\r\n  /**\r\n   * Required as 'https://schema.org/Message'\r\n   */\r\n  type: 'https://schema.org/Message';\r\n\r\n  /**\r\n   * Required as 'Message\r\n   */\r\n  '@type': 'Message';\r\n\r\n  /**\r\n   * Required as 'https://schema.org\r\n   */\r\n  '@context': 'https://schema.org';\r\n\r\n  /**\r\n   * Must be left blank. This is for Bot Framework schema.\r\n   */\r\n  '@id': '';\r\n\r\n  /**\r\n   * Indicate that the content was generated by AI.\r\n   */\r\n  additionalType: ['AIGeneratedContent'];\r\n\r\n  /**\r\n   * Optional; if citations object is included, the  sent activity will include the citations, referenced in the activity text.\r\n   */\r\n  citation?: ClientCitation[];\r\n\r\n  /**\r\n   * Optional; if usage_info object is included, the sent activity will include the sensitivity usage information.\r\n   */\r\n  usageInfo?: SensitivityUsageInfo;\r\n}\r\n\r\n/**\r\n * Adds an AI entity to an activity to indicate that the content was generated by AI.\r\n *\r\n * @param activity - The activity to which the AI entity will be added. The activity's entities array will be initialized if it doesn't exist.\r\n * @param citations - Optional array of client citations to include with the AI-generated content.\r\n *                   Citations provide references to sources used in generating the content and are displayed in Teams.\r\n * @param usageInfo - Optional sensitivity usage information that provides context about the content's sensitivity level.\r\n *                   This helps users understand any special handling requirements for the content.\r\n *\r\n * @remarks\r\n * This function enhances the activity with metadata that helps clients (like Microsoft Teams)\r\n * understand that the content is AI-generated and optionally includes citations and sensitivity information.\r\n *\r\n * @example\r\n * ```typescript\r\n * import { Activity } from '../activity';\r\n * import { addAIToActivity, ClientCitation } from './AIEntity';\r\n *\r\n * const activity: Activity = {\r\n *   type: 'message',\r\n *   text: 'Based on the documents, here are the key findings...'\r\n * };\r\n *\r\n * const citations: ClientCitation[] = [{\r\n *   '@type': 'Claim',\r\n *   position: 1,\r\n *   appearance: {\r\n *     '@type': 'DigitalDocument',\r\n *     name: 'Research Report 2024',\r\n *     abstract: 'Key findings from the annual research report',\r\n *     url: 'https://example.com/report.pdf',\r\n *     image: {\r\n *       '@type': 'ImageObject',\r\n *       name: 'PDF'\r\n *     }\r\n *   }\r\n * }];\r\n *\r\n * // Add AI entity with citations\r\n * addAIToActivity(activity, citations);\r\n * ```\r\n */\r\nexport const addAIToActivity = (\r\n  activity: Activity,\r\n  citations?: ClientCitation[],\r\n  usageInfo?: SensitivityUsageInfo\r\n): void => {\r\n  const aiEntity: AIEntity = {\r\n    type: 'https://schema.org/Message',\r\n    '@type': 'Message',\r\n    '@context': 'https://schema.org',\r\n    '@id': '',\r\n    additionalType: ['AIGeneratedContent'],\r\n    citation: citations,\r\n    usageInfo\r\n  }\r\n  activity.entities ??= []\r\n  activity.entities.push(aiEntity)\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Represents an adaptive card invoke action.\r\n */\r\nexport interface AdaptiveCardInvokeAction {\r\n  /**\r\n   * The type of the action.\r\n   */\r\n  type: string\r\n  /**\r\n   * The unique identifier of the action.\r\n   */\r\n  id?: string\r\n  /**\r\n   * The verb associated with the action.\r\n   */\r\n  verb: string\r\n  /**\r\n   * Additional data associated with the action.\r\n   */\r\n  data: Record<string, any>\r\n}\r\n\r\n/**\r\n * Zod schema for validating an adaptive card invoke action.\r\n */\r\nexport const adaptiveCardInvokeActionZodSchema = z.object({\r\n  type: z.string().min(1),\r\n  id: z.string().optional(),\r\n  verb: z.string().min(1),\r\n  data: z.record(z.string().min(1), z.any())\r\n})\r\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = '00000000-0000-0000-0000-000000000000';\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst regex_js_1 = require(\"./regex.js\");\nfunction validate(uuid) {\n    return typeof uuid === 'string' && regex_js_1.default.test(uuid);\n}\nexports.default = validate;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_js_1 = require(\"./validate.js\");\nfunction parse(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexports.default = parse;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsafeStringify = void 0;\nconst validate_js_1 = require(\"./validate.js\");\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nexports.unsafeStringify = unsafeStringify;\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexports.default = stringify;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\nexports.default = rng;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateV1State = void 0;\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nconst _state = {};\nfunction v1(options, buf, offset) {\n    let bytes;\n    const isV6 = options?._v6 ?? false;\n    if (options) {\n        const optionsKeys = Object.keys(options);\n        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {\n            options = undefined;\n        }\n    }\n    if (options) {\n        bytes = v1Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV1State(_state, now, rnds);\n        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV1State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.nsecs ??= 0;\n    if (now === state.msecs) {\n        state.nsecs++;\n        if (state.nsecs >= 10000) {\n            state.node = undefined;\n            state.nsecs = 0;\n        }\n    }\n    else if (now > state.msecs) {\n        state.nsecs = 0;\n    }\n    else if (now < state.msecs) {\n        state.node = undefined;\n    }\n    if (!state.node) {\n        state.node = rnds.slice(10, 16);\n        state.node[0] |= 0x01;\n        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    }\n    state.msecs = now;\n    return state;\n}\nexports.updateV1State = updateV1State;\nfunction v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    nsecs ??= 0;\n    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    node ??= rnds.slice(10, 16);\n    msecs += 12219292800000;\n    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    buf[offset++] = (tl >>> 24) & 0xff;\n    buf[offset++] = (tl >>> 16) & 0xff;\n    buf[offset++] = (tl >>> 8) & 0xff;\n    buf[offset++] = tl & 0xff;\n    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;\n    buf[offset++] = (tmh >>> 8) & 0xff;\n    buf[offset++] = tmh & 0xff;\n    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;\n    buf[offset++] = (tmh >>> 16) & 0xff;\n    buf[offset++] = (clockseq >>> 8) | 0x80;\n    buf[offset++] = clockseq & 0xff;\n    for (let n = 0; n < 6; ++n) {\n        buf[offset++] = node[n];\n    }\n    return buf;\n}\nexports.default = v1;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v1ToV6(uuid) {\n    const v1Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v6Bytes = _v1ToV6(v1Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;\n}\nexports.default = v1ToV6;\nfunction _v1ToV6(v1Bytes) {\n    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction md5(bytes) {\n    const words = uint8ToUint32(bytes);\n    const md5Bytes = wordsToMd5(words, bytes.length * 8);\n    return uint32ToUint8(md5Bytes);\n}\nfunction uint32ToUint8(input) {\n    const bytes = new Uint8Array(input.length * 4);\n    for (let i = 0; i < input.length * 4; i++) {\n        bytes[i] = (input[i >> 2] >>> ((i % 4) * 8)) & 0xff;\n    }\n    return bytes;\n}\nfunction getOutputLength(inputLength8) {\n    return (((inputLength8 + 64) >>> 9) << 4) + 14 + 1;\n}\nfunction wordsToMd5(x, len) {\n    const xpad = new Uint32Array(getOutputLength(len)).fill(0);\n    xpad.set(x);\n    xpad[len >> 5] |= 0x80 << len % 32;\n    xpad[xpad.length - 1] = len;\n    x = xpad;\n    let a = 1732584193;\n    let b = -271733879;\n    let c = -1732584194;\n    let d = 271733878;\n    for (let i = 0; i < x.length; i += 16) {\n        const olda = a;\n        const oldb = b;\n        const oldc = c;\n        const oldd = d;\n        a = md5ff(a, b, c, d, x[i], 7, -680876936);\n        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n        b = md5gg(b, c, d, a, x[i], 20, -373897302);\n        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n        d = md5hh(d, a, b, c, x[i], 11, -358537222);\n        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n        a = md5ii(a, b, c, d, x[i], 6, -198630844);\n        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n        a = safeAdd(a, olda);\n        b = safeAdd(b, oldb);\n        c = safeAdd(c, oldc);\n        d = safeAdd(d, oldd);\n    }\n    return Uint32Array.of(a, b, c, d);\n}\nfunction uint8ToUint32(input) {\n    if (input.length === 0) {\n        return new Uint32Array();\n    }\n    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);\n    for (let i = 0; i < input.length; i++) {\n        output[i >> 2] |= (input[i] & 0xff) << ((i % 4) * 8);\n    }\n    return output;\n}\nfunction safeAdd(x, y) {\n    const lsw = (x & 0xffff) + (y & 0xffff);\n    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n}\nfunction bitRotateLeft(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n}\nfunction md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\nfunction md5ff(a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t);\n}\nfunction md5gg(a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t);\n}\nfunction md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\nexports.default = md5;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = exports.stringToBytes = void 0;\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexports.stringToBytes = stringToBytes;\nexports.DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? (0, parse_js_1.default)(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = (0, parse_js_1.default)(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports.default = v35;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = void 0;\nconst md5_js_1 = require(\"./md5.js\");\nconst v35_js_1 = require(\"./v35.js\");\nvar v35_js_2 = require(\"./v35.js\");\nObject.defineProperty(exports, \"DNS\", { enumerable: true, get: function () { return v35_js_2.DNS; } });\nObject.defineProperty(exports, \"URL\", { enumerable: true, get: function () { return v35_js_2.URL; } });\nfunction v3(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x30, md5_js_1.default, value, namespace, buf, offset);\n}\nv3.DNS = v35_js_1.DNS;\nv3.URL = v35_js_1.URL;\nexports.default = v3;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexports.default = { randomUUID };\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst native_js_1 = require(\"./native.js\");\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v4(options, buf, offset) {\n    if (native_js_1.default.randomUUID && !buf && !options) {\n        return native_js_1.default.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0, rng_js_1.default)();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(rnds);\n}\nexports.default = v4;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction f(s, x, y, z) {\n    switch (s) {\n        case 0:\n            return (x & y) ^ (~x & z);\n        case 1:\n            return x ^ y ^ z;\n        case 2:\n            return (x & y) ^ (x & z) ^ (y & z);\n        case 3:\n            return x ^ y ^ z;\n    }\n}\nfunction ROTL(x, n) {\n    return (x << n) | (x >>> (32 - n));\n}\nfunction sha1(bytes) {\n    const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n    const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n    const newBytes = new Uint8Array(bytes.length + 1);\n    newBytes.set(bytes);\n    newBytes[bytes.length] = 0x80;\n    bytes = newBytes;\n    const l = bytes.length / 4 + 2;\n    const N = Math.ceil(l / 16);\n    const M = new Array(N);\n    for (let i = 0; i < N; ++i) {\n        const arr = new Uint32Array(16);\n        for (let j = 0; j < 16; ++j) {\n            arr[j] =\n                (bytes[i * 64 + j * 4] << 24) |\n                    (bytes[i * 64 + j * 4 + 1] << 16) |\n                    (bytes[i * 64 + j * 4 + 2] << 8) |\n                    bytes[i * 64 + j * 4 + 3];\n        }\n        M[i] = arr;\n    }\n    M[N - 1][14] = ((bytes.length - 1) * 8) / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = ((bytes.length - 1) * 8) & 0xffffffff;\n    for (let i = 0; i < N; ++i) {\n        const W = new Uint32Array(80);\n        for (let t = 0; t < 16; ++t) {\n            W[t] = M[i][t];\n        }\n        for (let t = 16; t < 80; ++t) {\n            W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n        }\n        let a = H[0];\n        let b = H[1];\n        let c = H[2];\n        let d = H[3];\n        let e = H[4];\n        for (let t = 0; t < 80; ++t) {\n            const s = Math.floor(t / 20);\n            const T = (ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t]) >>> 0;\n            e = d;\n            d = c;\n            c = ROTL(b, 30) >>> 0;\n            b = a;\n            a = T;\n        }\n        H[0] = (H[0] + a) >>> 0;\n        H[1] = (H[1] + b) >>> 0;\n        H[2] = (H[2] + c) >>> 0;\n        H[3] = (H[3] + d) >>> 0;\n        H[4] = (H[4] + e) >>> 0;\n    }\n    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);\n}\nexports.default = sha1;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.URL = exports.DNS = void 0;\nconst sha1_js_1 = require(\"./sha1.js\");\nconst v35_js_1 = require(\"./v35.js\");\nvar v35_js_2 = require(\"./v35.js\");\nObject.defineProperty(exports, \"DNS\", { enumerable: true, get: function () { return v35_js_2.DNS; } });\nObject.defineProperty(exports, \"URL\", { enumerable: true, get: function () { return v35_js_2.URL; } });\nfunction v5(value, namespace, buf, offset) {\n    return (0, v35_js_1.default)(0x50, sha1_js_1.default, value, namespace, buf, offset);\n}\nv5.DNS = v35_js_1.DNS;\nv5.URL = v35_js_1.URL;\nexports.default = v5;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stringify_js_1 = require(\"./stringify.js\");\nconst v1_js_1 = require(\"./v1.js\");\nconst v1ToV6_js_1 = require(\"./v1ToV6.js\");\nfunction v6(options, buf, offset) {\n    options ??= {};\n    offset ??= 0;\n    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));\n    bytes = (0, v1ToV6_js_1.default)(bytes);\n    if (buf) {\n        for (let i = 0; i < 16; i++) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return (0, stringify_js_1.unsafeStringify)(bytes);\n}\nexports.default = v6;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parse_js_1 = require(\"./parse.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nfunction v6ToV1(uuid) {\n    const v6Bytes = typeof uuid === 'string' ? (0, parse_js_1.default)(uuid) : uuid;\n    const v1Bytes = _v6ToV1(v6Bytes);\n    return typeof uuid === 'string' ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;\n}\nexports.default = v6ToV1;\nfunction _v6ToV1(v6Bytes) {\n    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateV7State = void 0;\nconst rng_js_1 = require(\"./rng.js\");\nconst stringify_js_1 = require(\"./stringify.js\");\nconst _state = {};\nfunction v7(options, buf, offset) {\n    let bytes;\n    if (options) {\n        bytes = v7Bytes(options.random ?? options.rng?.() ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = (0, rng_js_1.default)();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);\n}\nfunction updateV7State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.seq ??= 0;\n    if (now > state.msecs) {\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        state.seq = (state.seq + 1) | 0;\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nexports.updateV7State = updateV7State;\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    buf[offset++] = (seq >>> 20) & 0xff;\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    buf[offset++] = (seq >>> 6) & 0xff;\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\nexports.default = v7;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst validate_js_1 = require(\"./validate.js\");\nfunction version(uuid) {\n    if (!(0, validate_js_1.default)(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    return parseInt(uuid.slice(14, 15), 16);\n}\nexports.default = version;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;\nvar max_js_1 = require(\"./max.js\");\nObject.defineProperty(exports, \"MAX\", { enumerable: true, get: function () { return max_js_1.default; } });\nvar nil_js_1 = require(\"./nil.js\");\nObject.defineProperty(exports, \"NIL\", { enumerable: true, get: function () { return nil_js_1.default; } });\nvar parse_js_1 = require(\"./parse.js\");\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parse_js_1.default; } });\nvar stringify_js_1 = require(\"./stringify.js\");\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return stringify_js_1.default; } });\nvar v1_js_1 = require(\"./v1.js\");\nObject.defineProperty(exports, \"v1\", { enumerable: true, get: function () { return v1_js_1.default; } });\nvar v1ToV6_js_1 = require(\"./v1ToV6.js\");\nObject.defineProperty(exports, \"v1ToV6\", { enumerable: true, get: function () { return v1ToV6_js_1.default; } });\nvar v3_js_1 = require(\"./v3.js\");\nObject.defineProperty(exports, \"v3\", { enumerable: true, get: function () { return v3_js_1.default; } });\nvar v4_js_1 = require(\"./v4.js\");\nObject.defineProperty(exports, \"v4\", { enumerable: true, get: function () { return v4_js_1.default; } });\nvar v5_js_1 = require(\"./v5.js\");\nObject.defineProperty(exports, \"v5\", { enumerable: true, get: function () { return v5_js_1.default; } });\nvar v6_js_1 = require(\"./v6.js\");\nObject.defineProperty(exports, \"v6\", { enumerable: true, get: function () { return v6_js_1.default; } });\nvar v6ToV1_js_1 = require(\"./v6ToV1.js\");\nObject.defineProperty(exports, \"v6ToV1\", { enumerable: true, get: function () { return v6ToV1_js_1.default; } });\nvar v7_js_1 = require(\"./v7.js\");\nObject.defineProperty(exports, \"v7\", { enumerable: true, get: function () { return v7_js_1.default; } });\nvar validate_js_1 = require(\"./validate.js\");\nObject.defineProperty(exports, \"validate\", { enumerable: true, get: function () { return validate_js_1.default; } });\nvar version_js_1 = require(\"./version.js\");\nObject.defineProperty(exports, \"version\", { enumerable: true, get: function () { return version_js_1.default; } });\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Represents a generic Entity.\r\n */\r\nexport interface Entity {\r\n  /**\r\n   * The type of the entity.\r\n   */\r\n  type: string\r\n  /**\r\n   * Additional properties of the entity.\r\n   */\r\n  [key: string]: unknown\r\n}\r\n\r\n/**\r\n * Zod schema for validating Entity objects.\r\n */\r\nexport const entityZodSchema = z.object({\r\n  type: z.string().min(1)\r\n}).passthrough()\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { Entity, entityZodSchema } from '../entity/entity'\r\nimport { SemanticActionStateTypes, semanticActionStateTypesZodSchema } from './semanticActionStateTypes'\r\n\r\n/**\r\n * Represents a semantic action.\r\n */\r\nexport interface SemanticAction {\r\n  /**\r\n   * Unique identifier for the semantic action.\r\n   */\r\n  id: string\r\n  /**\r\n   * State of the semantic action.\r\n   */\r\n  state: SemanticActionStateTypes | string\r\n  /**\r\n   * Entities associated with the semantic action.\r\n   */\r\n  entities: { [propertyName: string]: Entity }\r\n}\r\n\r\n/**\r\n * Zod schema for validating SemanticAction.\r\n */\r\nexport const semanticActionZodSchema = z.object({\r\n  id: z.string().min(1),\r\n  state: z.union([semanticActionStateTypesZodSchema, z.string().min(1)]),\r\n  entities: z.record(entityZodSchema)\r\n})\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { ActionTypes, actionTypesZodSchema } from './actionTypes'\r\n\r\n/**\r\n * Represents a card action.\r\n */\r\nexport interface CardAction {\r\n  /**\r\n   * Type of the action.\r\n   */\r\n  type: ActionTypes | string\r\n  /**\r\n   * Title of the action.\r\n   */\r\n  title: string\r\n  /**\r\n   * URL of the image associated with the action.\r\n   */\r\n  image?: string\r\n  /**\r\n   * Text associated with the action.\r\n   */\r\n  text?: string\r\n  /**\r\n   * Display text for the action.\r\n   */\r\n  displayText?: string\r\n  /**\r\n   * Value associated with the action.\r\n   */\r\n  value?: any\r\n  /**\r\n   * Channel-specific data associated with the action.\r\n   */\r\n  channelData?: unknown\r\n  /**\r\n   * Alt text for the image.\r\n   */\r\n  imageAltText?: string\r\n}\r\n\r\n/**\r\n * Zod schema for validating CardAction.\r\n */\r\nexport const cardActionZodSchema = z.object({\r\n  type: z.union([actionTypesZodSchema, z.string().min(1)]),\r\n  title: z.string().min(1),\r\n  image: z.string().min(1).optional(),\r\n  text: z.string().min(1).optional(),\r\n  displayText: z.string().min(1).optional(),\r\n  value: z.any().optional(),\r\n  channelData: z.unknown().optional(),\r\n  imageAltText: z.string().min(1).optional()\r\n})\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { CardAction, cardActionZodSchema } from './cardAction'\r\n\r\n/**\r\n * Represents suggested actions.\r\n */\r\nexport interface SuggestedActions {\r\n  /**\r\n   * Array of recipient IDs.\r\n   */\r\n  to: string[]\r\n  /**\r\n   * Array of card actions.\r\n   */\r\n  actions: CardAction[]\r\n}\r\n\r\n/**\r\n * Zod schema for validating SuggestedActions.\r\n */\r\nexport const suggestedActionsZodSchema = z.object({\r\n  to: z.array(z.string().min(1)),\r\n  actions: z.array(cardActionZodSchema)\r\n})\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing activity event names.\r\n */\r\nexport enum ActivityEventNames {\r\n  /**\r\n   * Event name for continuing a conversation.\r\n   */\r\n  ContinueConversation = 'ContinueConversation',\r\n\r\n  /**\r\n   * Event name for creating a new conversation.\r\n   */\r\n  CreateConversation = 'CreateConversation',\r\n}\r\n\r\n/**\r\n * Zod schema for validating an ActivityEventNames enum.\r\n */\r\nexport const activityEventNamesZodSchema = z.enum(['ContinueConversation', 'CreateConversation'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing activity importance levels.\r\n */\r\nexport enum ActivityImportance {\r\n  /**\r\n   * Indicates low importance.\r\n   */\r\n  Low = 'low',\r\n\r\n  /**\r\n   * Indicates normal importance.\r\n   */\r\n  Normal = 'normal',\r\n\r\n  /**\r\n   * Indicates high importance.\r\n   */\r\n  High = 'high',\r\n}\r\n\r\n/**\r\n * Zod schema for validating an ActivityImportance enum.\r\n */\r\nexport const activityImportanceZodSchema = z.enum(['low', 'normal', 'high'])\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing activity types.\r\n */\r\nexport enum ActivityTypes {\r\n  /**\r\n   * A message activity.\r\n   */\r\n  Message = 'message',\r\n\r\n  /**\r\n   * An update to a contact relationship.\r\n   */\r\n  ContactRelationUpdate = 'contactRelationUpdate',\r\n\r\n  /**\r\n   * An update to a conversation.\r\n   */\r\n  ConversationUpdate = 'conversationUpdate',\r\n\r\n  /**\r\n   * A typing indicator activity.\r\n   */\r\n  Typing = 'typing',\r\n\r\n  /**\r\n   * Indicates the end of a conversation.\r\n   */\r\n  EndOfConversation = 'endOfConversation',\r\n\r\n  /**\r\n   * An event activity.\r\n   */\r\n  Event = 'event',\r\n\r\n  /**\r\n   * An invoke activity.\r\n   */\r\n  Invoke = 'invoke',\r\n\r\n  /**\r\n   * A response to an invoke activity.\r\n   */\r\n  InvokeResponse = 'invokeResponse',\r\n\r\n  /**\r\n   * An activity to delete user data.\r\n   */\r\n  DeleteUserData = 'deleteUserData',\r\n\r\n  /**\r\n   * An update to a message.\r\n   */\r\n  MessageUpdate = 'messageUpdate',\r\n\r\n  /**\r\n   * A deletion of a message.\r\n   */\r\n  MessageDelete = 'messageDelete',\r\n\r\n  /**\r\n   * An update to an installation.\r\n   */\r\n  InstallationUpdate = 'installationUpdate',\r\n\r\n  /**\r\n   * A reaction to a message.\r\n   */\r\n  MessageReaction = 'messageReaction',\r\n\r\n  /**\r\n   * A suggestion activity.\r\n   */\r\n  Suggestion = 'suggestion',\r\n\r\n  /**\r\n   * A trace activity for debugging.\r\n   */\r\n  Trace = 'trace',\r\n\r\n  /**\r\n   * A handoff activity to another bot or human.\r\n   */\r\n  Handoff = 'handoff',\r\n\r\n  /**\r\n   * A command activity.\r\n   */\r\n  Command = 'command',\r\n\r\n  /**\r\n   * A result of a command activity.\r\n   */\r\n  CommandResult = 'commandResult',\r\n\r\n  /**\r\n   * A delay activity.\r\n   */\r\n  Delay = 'delay'\r\n}\r\n\r\n/**\r\n * Zod schema for validating an ActivityTypes enum.\r\n */\r\nexport const activityTypesZodSchema = z.enum([\r\n  'message',\r\n  'contactRelationUpdate',\r\n  'conversationUpdate',\r\n  'typing',\r\n  'endOfConversation',\r\n  'event',\r\n  'invoke',\r\n  'invokeResponse',\r\n  'deleteUserData',\r\n  'messageUpdate',\r\n  'messageDelete',\r\n  'installationUpdate',\r\n  'messageReaction',\r\n  'suggestion',\r\n  'trace',\r\n  'handoff',\r\n  'command',\r\n  'commandResult',\r\n  'delay'\r\n])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Represents an attachment.\r\n */\r\nexport interface Attachment {\r\n  /**\r\n   * The MIME type of the attachment content.\r\n   */\r\n  contentType: string\r\n\r\n  /**\r\n   * The URL of the attachment content.\r\n   */\r\n  contentUrl?: string\r\n\r\n  /**\r\n   * The content of the attachment.\r\n   */\r\n  content?: unknown\r\n\r\n  /**\r\n   * The name of the attachment.\r\n   */\r\n  name?: string\r\n\r\n  /**\r\n   * The URL of the thumbnail for the attachment.\r\n   */\r\n  thumbnailUrl?: string\r\n}\r\n\r\n/**\r\n * Zod schema for validating attachments.\r\n */\r\nexport const attachmentZodSchema = z.object({\r\n  contentType: z.string().min(1),\r\n  contentUrl: z.string().min(1).optional(),\r\n  content: z.unknown().optional(),\r\n  name: z.string().min(1).optional(),\r\n  thumbnailUrl: z.string().min(1).optional()\r\n})\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { roleTypeZodSchema, RoleTypes } from './roleTypes'\r\nimport { MembershipSource } from './membershipSource'\r\n\r\n/**\r\n * Represents a channel account.\r\n */\r\nexport interface ChannelAccount {\r\n  /**\r\n   * The unique identifier of the channel account.\r\n   */\r\n  id?: string\r\n\r\n  /**\r\n   * The name of the channel account.\r\n   */\r\n  name?: string\r\n\r\n  /**\r\n   * The Azure Active Directory object ID of the channel account.\r\n   */\r\n  aadObjectId?: string\r\n\r\n  /**\r\n   * The role of the channel account.\r\n   */\r\n  role?: RoleTypes | string\r\n\r\n  /**\r\n   * Additional properties of the channel account.\r\n   */\r\n  properties?: unknown\r\n\r\n  /**\r\n   * List of membership sources associated with the channel account.\r\n   */\r\n  membershipSources?: MembershipSource[]\r\n}\r\n\r\n/**\r\n * Zod schema for validating a channel account.\r\n */\r\nexport const channelAccountZodSchema = z.object({\r\n  id: z.string().min(1).optional(),\r\n  name: z.string().optional(),\r\n  aadObjectId: z.string().min(1).optional(),\r\n  role: z.union([roleTypeZodSchema, z.string().min(1)]).optional(),\r\n  properties: z.unknown().optional()\r\n})\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { roleTypeZodSchema, RoleTypes } from './roleTypes'\r\n\r\n/**\r\n * Represents a conversation account.\r\n */\r\nexport interface ConversationAccount {\r\n  /**\r\n   * The unique identifier of the conversation account.\r\n   */\r\n  id: string\r\n\r\n  /**\r\n   * The type of the conversation (e.g., personal, group, etc.).\r\n   */\r\n  conversationType?: string\r\n\r\n  /**\r\n   * The tenant ID associated with the conversation account.\r\n   */\r\n  tenantId?: string\r\n\r\n  /**\r\n   * Indicates whether the conversation is a group.\r\n   */\r\n  isGroup?: boolean\r\n\r\n  /**\r\n   * The name of the conversation account.\r\n   */\r\n  name?: string\r\n\r\n  /**\r\n   * The Azure Active Directory object ID of the conversation account.\r\n   */\r\n  aadObjectId?: string\r\n\r\n  /**\r\n   * The role of the conversation account.\r\n   */\r\n  role?: RoleTypes | string\r\n\r\n  /**\r\n   * Additional properties of the conversation account.\r\n   */\r\n  properties?: unknown\r\n}\r\n\r\n/**\r\n * Zod schema for validating a conversation account.\r\n */\r\nexport const conversationAccountZodSchema = z.object({\r\n  isGroup: z.boolean().optional(),\r\n  conversationType: z.string().min(1).optional(),\r\n  tenantId: z.string().min(1).optional(),\r\n  id: z.string().min(1),\r\n  name: z.string().min(1).optional(),\r\n  aadObjectId: z.string().min(1).optional(),\r\n  role: z.union([roleTypeZodSchema, z.string().min(1)]).optional(),\r\n  properties: z.unknown().optional()\r\n})\r\n", "/**\r\n * Copyright(c) Microsoft Corporation.All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { ChannelAccount, channelAccountZodSchema } from './channelAccount'\r\nimport { ConversationAccount, conversationAccountZodSchema } from './conversationAccount'\r\n\r\n/**\r\n * Represents a reference to a conversation.\r\n */\r\nexport interface ConversationReference {\r\n  /**\r\n   * The ID of the activity. Optional.\r\n   */\r\n  activityId?: string\r\n\r\n  /**\r\n   * The user involved in the conversation. Optional.\r\n   */\r\n  user?: ChannelAccount\r\n\r\n  /**\r\n   * The locale of the conversation. Optional.\r\n   */\r\n  locale?: string\r\n\r\n  /**\r\n   * The agent involved in the conversation. Can be undefined or null. Optional.\r\n   */\r\n  agent?: ChannelAccount | undefined | null\r\n\r\n  /**\r\n   * The conversation account details.\r\n   */\r\n  conversation: ConversationAccount\r\n\r\n  /**\r\n   * The ID of the channel where the conversation is taking place.\r\n   */\r\n  channelId: string\r\n\r\n  /**\r\n   * The service URL for the conversation. Optional.\r\n   */\r\n  serviceUrl?: string | undefined\r\n}\r\n\r\n/**\r\n * Zod schema for validating a conversation reference.\r\n */\r\nexport const conversationReferenceZodSchema = z.object({\r\n  activityId: z.string().min(1).optional(),\r\n  user: channelAccountZodSchema.optional(),\r\n  locale: z.string().min(1).optional(),\r\n  agent: channelAccountZodSchema.optional().nullable(),\r\n  conversation: conversationAccountZodSchema,\r\n  channelId: z.string().min(1),\r\n  serviceUrl: z.string().min(1).optional()\r\n})\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing delivery modes.\r\n */\r\nexport enum DeliveryModes {\r\n  /**\r\n   * Represents the normal delivery mode.\r\n   */\r\n  Normal = 'normal',\r\n\r\n  /**\r\n   * Represents a notification delivery mode.\r\n   */\r\n  Notification = 'notification',\r\n\r\n  /**\r\n   * Represents a delivery mode where replies are expected.\r\n   */\r\n  ExpectReplies = 'expectReplies',\r\n\r\n  /**\r\n   * Represents an ephemeral delivery mode.\r\n   */\r\n  Ephemeral = 'ephemeral',\r\n}\r\n\r\n/**\r\n * Zod schema for validating a DeliveryModes enum.\r\n */\r\nexport const deliveryModesZodSchema = z.enum(['normal', 'notification', 'expectReplies', 'ephemeral'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing input hints.\r\n */\r\nexport enum InputHints {\r\n  /**\r\n   * Indicates that the bot is ready to accept input from the user.\r\n   */\r\n  AcceptingInput = 'acceptingInput',\r\n\r\n  /**\r\n   * Indicates that the bot is ignoring input from the user.\r\n   */\r\n  IgnoringInput = 'ignoringInput',\r\n\r\n  /**\r\n   * Indicates that the bot is expecting input from the user.\r\n   */\r\n  ExpectingInput = 'expectingInput',\r\n}\r\n\r\n/**\r\n * Zod schema for validating an InputHints enum.\r\n */\r\nexport const inputHintsZodSchema = z.enum(['acceptingInput', 'ignoringInput', 'expectingInput'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing message reaction types.\r\n */\r\nexport enum MessageReactionTypes {\r\n  /**\r\n   * Represents a 'like' reaction to a message.\r\n   */\r\n  Like = 'like',\r\n\r\n  /**\r\n   * Represents a '+1' reaction to a message.\r\n   */\r\n  PlusOne = 'plusOne',\r\n}\r\n\r\n/**\r\n * Zod schema for validating MessageReactionTypes enum values.\r\n */\r\nexport const messageReactionTypesZodSchema = z.enum(['like', 'plusOne'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\nimport { MessageReactionTypes, messageReactionTypesZodSchema } from './messageReactionTypes'\r\n\r\n/**\r\n * Represents a message reaction.\r\n */\r\nexport interface MessageReaction {\r\n  /**\r\n   * The type of the reaction.\r\n   */\r\n  type: MessageReactionTypes | string\r\n}\r\n\r\n/**\r\n * Zod schema for validating a MessageReaction object.\r\n */\r\nexport const messageReactionZodSchema = z.object({\r\n  type: z.union([messageReactionTypesZodSchema, z.string().min(1)])\r\n})\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing text format types.\r\n */\r\nexport enum TextFormatTypes {\r\n  /**\r\n   * Represents text formatted using Markdown.\r\n   */\r\n  Markdown = 'markdown',\r\n\r\n  /**\r\n   * Represents plain text without any formatting.\r\n   */\r\n  Plain = 'plain',\r\n\r\n  /**\r\n   * Represents text formatted using XML.\r\n   */\r\n  Xml = 'xml',\r\n}\r\n\r\n/**\r\n * Zod schema for validating TextFormatTypes enum values.\r\n */\r\nexport const textFormatTypesZodSchema = z.enum(['markdown', 'plain', 'xml'])\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Represents a text highlight.\r\n */\r\nexport interface TextHighlight {\r\n  /**\r\n   * The highlighted text.\r\n   */\r\n  text: string\r\n  /**\r\n   * The occurrence count of the highlighted text.\r\n   */\r\n  occurrence: number\r\n}\r\n\r\n/**\r\n * Zod schema for validating TextHighlight objects.\r\n */\r\nexport const textHighlightZodSchema = z.object({\r\n  text: z.string().min(1),\r\n  occurrence: z.number()\r\n})\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { v4 as uuid } from 'uuid'\r\nimport { z } from 'zod'\r\nimport { SemanticAction, semanticActionZodSchema } from './action/semanticAction'\r\nimport { SuggestedActions, suggestedActionsZodSchema } from './action/suggestedActions'\r\nimport { ActivityEventNames, activityEventNamesZodSchema } from './activityEventNames'\r\nimport { ActivityImportance, activityImportanceZodSchema } from './activityImportance'\r\nimport { ActivityTypes, activityTypesZodSchema } from './activityTypes'\r\nimport { Attachment, attachmentZodSchema } from './attachment/attachment'\r\nimport { AttachmentLayoutTypes, attachmentLayoutTypesZodSchema } from './attachment/attachmentLayoutTypes'\r\nimport { ChannelAccount, channelAccountZodSchema } from './conversation/channelAccount'\r\nimport { Channels } from './conversation/channels'\r\nimport { ConversationAccount, conversationAccountZodSchema } from './conversation/conversationAccount'\r\nimport { ConversationReference, conversationReferenceZodSchema } from './conversation/conversationReference'\r\nimport { EndOfConversationCodes, endOfConversationCodesZodSchema } from './conversation/endOfConversationCodes'\r\nimport { DeliveryModes, deliveryModesZodSchema } from './deliveryModes'\r\nimport { Entity, entityZodSchema } from './entity/entity'\r\nimport { Mention } from './entity/mention'\r\nimport { InputHints, inputHintsZodSchema } from './inputHints'\r\nimport { MessageReaction, messageReactionZodSchema } from './messageReaction'\r\nimport { TextFormatTypes, textFormatTypesZodSchema } from './textFormatTypes'\r\nimport { TextHighlight, textHighlightZodSchema } from './textHighlight'\r\n\r\n/**\r\n * Zod schema for validating an Activity object.\r\n */\r\nexport const activityZodSchema = z.object({\r\n  type: z.union([activityTypesZodSchema, z.string().min(1)]),\r\n  text: z.string().optional(),\r\n  id: z.string().min(1).optional(),\r\n  channelId: z.string().min(1).optional(),\r\n  from: channelAccountZodSchema.optional(),\r\n  timestamp: z.union([z.date(), z.string().min(1).datetime().optional(), z.string().min(1).transform(s => new Date(s)).optional()]),\r\n  localTimestamp: z.string().min(1).transform(s => new Date(s)).optional().or(z.date()).optional(), // z.string().min(1).transform(s => new Date(s)).optional(),\r\n  localTimezone: z.string().min(1).optional(),\r\n  callerId: z.string().min(1).optional(),\r\n  serviceUrl: z.string().min(1).optional(),\r\n  conversation: conversationAccountZodSchema.optional(),\r\n  recipient: channelAccountZodSchema.optional(),\r\n  textFormat: z.union([textFormatTypesZodSchema, z.string().min(1)]).optional(),\r\n  attachmentLayout: z.union([attachmentLayoutTypesZodSchema, z.string().min(1)]).optional(),\r\n  membersAdded: z.array(channelAccountZodSchema).optional(),\r\n  membersRemoved: z.array(channelAccountZodSchema).optional(),\r\n  reactionsAdded: z.array(messageReactionZodSchema).optional(),\r\n  reactionsRemoved: z.array(messageReactionZodSchema).optional(),\r\n  topicName: z.string().min(1).optional(),\r\n  historyDisclosed: z.boolean().optional(),\r\n  locale: z.string().min(1).optional(),\r\n  speak: z.string().min(1).optional(),\r\n  inputHint: z.union([inputHintsZodSchema, z.string().min(1)]).optional(),\r\n  summary: z.string().min(1).optional(),\r\n  suggestedActions: suggestedActionsZodSchema.optional(),\r\n  attachments: z.array(attachmentZodSchema).optional(),\r\n  entities: z.array(entityZodSchema.passthrough()).optional(),\r\n  channelData: z.any().optional(),\r\n  action: z.string().min(1).optional(),\r\n  replyToId: z.string().min(1).optional(),\r\n  label: z.string().min(1).optional(),\r\n  valueType: z.string().min(1).optional(),\r\n  value: z.unknown().optional(),\r\n  name: z.union([activityEventNamesZodSchema, z.string().min(1)]).optional(),\r\n  relatesTo: conversationReferenceZodSchema.optional(),\r\n  code: z.union([endOfConversationCodesZodSchema, z.string().min(1)]).optional(),\r\n  expiration: z.string().min(1).datetime().optional(),\r\n  importance: z.union([activityImportanceZodSchema, z.string().min(1)]).optional(),\r\n  deliveryMode: z.union([deliveryModesZodSchema, z.string().min(1)]).optional(),\r\n  listenFor: z.array(z.string().min(1)).optional(),\r\n  textHighlights: z.array(textHighlightZodSchema).optional(),\r\n  semanticAction: semanticActionZodSchema.optional(),\r\n})\r\n\r\n/**\r\n * Represents an activity in a conversation.\r\n */\r\nexport class Activity {\r\n  /**\r\n   * The type of the activity.\r\n   */\r\n  type: ActivityTypes | string\r\n\r\n  /**\r\n   * The text content of the activity.\r\n   */\r\n  text?: string\r\n\r\n  /**\r\n   * The unique identifier of the activity.\r\n   */\r\n  id?: string\r\n\r\n  /**\r\n   * The channel ID where the activity originated.\r\n   */\r\n  channelId?: string\r\n\r\n  /**\r\n   * The account of the sender of the activity.\r\n   */\r\n  from?: ChannelAccount\r\n\r\n  /**\r\n   * The timestamp of the activity.\r\n   */\r\n  timestamp?: Date | string\r\n\r\n  /**\r\n   * The local timestamp of the activity.\r\n   */\r\n  localTimestamp?: Date | string\r\n\r\n  /**\r\n   * The local timezone of the activity.\r\n   */\r\n  localTimezone?: string\r\n\r\n  /**\r\n   * The caller ID of the activity.\r\n   */\r\n  callerId?: string\r\n\r\n  /**\r\n   * The service URL of the activity.\r\n   */\r\n  serviceUrl?: string\r\n\r\n  /**\r\n   * The conversation account associated with the activity.\r\n   */\r\n  conversation?: ConversationAccount\r\n\r\n  /**\r\n   * The recipient of the activity.\r\n   */\r\n  recipient?: ChannelAccount\r\n\r\n  /**\r\n   * The text format of the activity.\r\n   */\r\n  textFormat?: TextFormatTypes | string\r\n\r\n  /**\r\n   * The attachment layout of the activity.\r\n   */\r\n  attachmentLayout?: AttachmentLayoutTypes | string\r\n\r\n  /**\r\n   * The members added to the conversation.\r\n   */\r\n  membersAdded?: ChannelAccount[]\r\n\r\n  /**\r\n   * The members removed from the conversation.\r\n   */\r\n  membersRemoved?: ChannelAccount[]\r\n\r\n  /**\r\n   * The reactions added to the activity.\r\n   */\r\n  reactionsAdded?: MessageReaction[]\r\n\r\n  /**\r\n   * The reactions removed from the activity.\r\n   */\r\n  reactionsRemoved?: MessageReaction[]\r\n\r\n  /**\r\n   * The topic name of the activity.\r\n   */\r\n  topicName?: string\r\n\r\n  /**\r\n   * Indicates whether the history is disclosed.\r\n   */\r\n  historyDisclosed?: boolean\r\n\r\n  /**\r\n   * The locale of the activity.\r\n   */\r\n  locale?: string\r\n\r\n  /**\r\n   * The speech text of the activity.\r\n   */\r\n  speak?: string\r\n\r\n  /**\r\n   * The input hint for the activity.\r\n   */\r\n  inputHint?: InputHints | string\r\n\r\n  /**\r\n   * The summary of the activity.\r\n   */\r\n  summary?: string\r\n\r\n  /**\r\n   * The suggested actions for the activity.\r\n   */\r\n  suggestedActions?: SuggestedActions\r\n\r\n  /**\r\n   * The attachments of the activity.\r\n   */\r\n  attachments?: Attachment[]\r\n\r\n  /**\r\n   * The entities associated with the activity.\r\n   */\r\n  entities?: Entity[]\r\n\r\n  /**\r\n   * The channel-specific data for the activity.\r\n   */\r\n  channelData?: any\r\n\r\n  /**\r\n   * The action associated with the activity.\r\n   */\r\n  action?: string\r\n\r\n  /**\r\n   * The ID of the activity being replied to.\r\n   */\r\n  replyToId?: string\r\n\r\n  /**\r\n   * The label for the activity.\r\n   */\r\n  label?: string\r\n\r\n  /**\r\n   * The value type of the activity.\r\n   */\r\n  valueType?: string\r\n\r\n  /**\r\n   * The value associated with the activity.\r\n   */\r\n  value?: unknown\r\n\r\n  /**\r\n   * The name of the activity event.\r\n   */\r\n  name?: ActivityEventNames | string\r\n\r\n  /**\r\n   * The conversation reference for the activity.\r\n   */\r\n  relatesTo?: ConversationReference\r\n\r\n  /**\r\n   * The end-of-conversation code for the activity.\r\n   */\r\n  code?: EndOfConversationCodes | string\r\n\r\n  /**\r\n   * The expiration time of the activity.\r\n   */\r\n  expiration?: string | Date\r\n\r\n  /**\r\n   * The importance of the activity.\r\n   */\r\n  importance?: ActivityImportance | string\r\n\r\n  /**\r\n   * The delivery mode of the activity.\r\n   */\r\n  deliveryMode?: DeliveryModes | string\r\n\r\n  /**\r\n   * The list of keywords to listen for in the activity.\r\n   */\r\n  listenFor?: string[]\r\n\r\n  /**\r\n   * The text highlights in the activity.\r\n   */\r\n  textHighlights?: TextHighlight[]\r\n\r\n  /**\r\n   * The semantic action associated with the activity.\r\n   */\r\n  semanticAction?: SemanticAction\r\n\r\n  /**\r\n   * The raw timestamp of the activity.\r\n   */\r\n  rawTimestamp?: string\r\n\r\n  /**\r\n   * The raw expiration time of the activity.\r\n   */\r\n  rawExpiration?: string\r\n\r\n  /**\r\n   * The raw local timestamp of the activity.\r\n   */\r\n  rawLocalTimestamp?: string\r\n\r\n  /**\r\n   * Additional properties of the activity.\r\n   */\r\n  [x: string]: unknown\r\n\r\n  /**\r\n   * Creates a new Activity instance.\r\n   * @param t The type of the activity.\r\n   * @throws Will throw an error if the activity type is invalid.\r\n   */\r\n  constructor (t: ActivityTypes | string) {\r\n    if (t === undefined) {\r\n      throw new Error('Invalid ActivityType: undefined')\r\n    }\r\n    if (t === null) {\r\n      throw new Error('Invalid ActivityType: null')\r\n    }\r\n    if ((typeof t === 'string') && (t.length === 0)) {\r\n      throw new Error('Invalid ActivityType: empty string')\r\n    }\r\n\r\n    this.type = t\r\n  }\r\n\r\n  /**\r\n   * Creates an Activity instance from a JSON string.\r\n   * @param json The JSON string representing the activity.\r\n   * @returns The created Activity instance.\r\n   */\r\n  static fromJson (json: string): Activity {\r\n    return this.fromObject(JSON.parse(json))\r\n  }\r\n\r\n  /**\r\n   * Creates an Activity instance from an object.\r\n   * @param o The object representing the activity.\r\n   * @returns The created Activity instance.\r\n   */\r\n  static fromObject (o: object): Activity {\r\n    const parsedActivity = activityZodSchema.passthrough().parse(o)\r\n    const activity = new Activity(parsedActivity.type)\r\n    Object.assign(activity, parsedActivity)\r\n    return activity\r\n  }\r\n\r\n  /**\r\n   * Creates a continuation activity from a conversation reference.\r\n   * @param reference The conversation reference.\r\n   * @returns The created continuation activity.\r\n   */\r\n  static getContinuationActivity (reference: ConversationReference): Activity {\r\n    const continuationActivityObj = {\r\n      type: ActivityTypes.Event,\r\n      name: ActivityEventNames.ContinueConversation,\r\n      id: uuid(),\r\n      channelId: reference.channelId,\r\n      locale: reference.locale,\r\n      serviceUrl: reference.serviceUrl,\r\n      conversation: reference.conversation,\r\n      recipient: reference.agent,\r\n      from: reference.user,\r\n      relatesTo: reference\r\n    }\r\n    const continuationActivity: Activity = Activity.fromObject(continuationActivityObj)\r\n    return continuationActivity\r\n  }\r\n\r\n  /**\r\n   * Gets the appropriate reply-to ID for the activity.\r\n   * @returns The reply-to ID, or undefined if not applicable.\r\n   */\r\n  private getAppropriateReplyToId (): string | undefined {\r\n    if (\r\n      this.type !== ActivityTypes.ConversationUpdate ||\r\n        (this.channelId !== Channels.Directline && this.channelId !== Channels.Webchat)\r\n    ) {\r\n      return this.id\r\n    }\r\n\r\n    return undefined\r\n  }\r\n\r\n  /**\r\n   * Gets the conversation reference for the activity.\r\n   * @returns The conversation reference.\r\n   * @throws Will throw an error if required properties are undefined.\r\n   */\r\n  public getConversationReference (): ConversationReference {\r\n    if (this.recipient === null || this.recipient === undefined) {\r\n      throw new Error('Activity Recipient undefined')\r\n    }\r\n    if (this.conversation === null || this.conversation === undefined) {\r\n      throw new Error('Activity Conversation undefined')\r\n    }\r\n    if (this.channelId === null || this.channelId === undefined) {\r\n      throw new Error('Activity ChannelId undefined')\r\n    }\r\n\r\n    return {\r\n      activityId: this.getAppropriateReplyToId(),\r\n      user: this.from,\r\n      agent: this.recipient,\r\n      conversation: this.conversation,\r\n      channelId: this.channelId,\r\n      locale: this.locale,\r\n      serviceUrl: this.serviceUrl\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Applies a conversation reference to the activity.\r\n   * @param reference The conversation reference.\r\n   * @param isIncoming Whether the activity is incoming.\r\n   * @returns The updated activity.\r\n   */\r\n  public applyConversationReference (\r\n    reference: ConversationReference,\r\n    isIncoming = false\r\n  ): Activity {\r\n    this.channelId = reference.channelId\r\n    this.locale ??= reference.locale\r\n    this.serviceUrl = reference.serviceUrl\r\n    this.conversation = reference.conversation\r\n    if (isIncoming) {\r\n      this.from = reference.user\r\n      this.recipient = reference.agent ?? undefined\r\n      if (reference.activityId) {\r\n        this.id = reference.activityId\r\n      }\r\n    } else {\r\n      this.from = reference.agent ?? undefined\r\n      this.recipient = reference.user\r\n      if (reference.activityId) {\r\n        this.replyToId = reference.activityId\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  public clone (): Activity {\r\n    const activityCopy = JSON.parse(JSON.stringify(this))\r\n\r\n    for (const key in activityCopy) {\r\n      if (typeof activityCopy[key] === 'string' && !isNaN(Date.parse(activityCopy[key]))) {\r\n        activityCopy[key] = new Date(activityCopy[key] as string)\r\n      }\r\n    }\r\n\r\n    Object.setPrototypeOf(activityCopy, Activity.prototype)\r\n    return activityCopy\r\n  }\r\n\r\n  /**\r\n   * Gets the mentions in the activity.\r\n   * @param activity The activity.\r\n   * @returns The list of mentions.\r\n   */\r\n  public getMentions (activity: Activity): Mention[] {\r\n    const result: Mention[] = []\r\n    if (activity.entities !== undefined) {\r\n      for (let i = 0; i < activity.entities.length; i++) {\r\n        if (activity.entities[i].type.toLowerCase() === 'mention') {\r\n          result.push(activity.entities[i] as unknown as Mention)\r\n        }\r\n      }\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * Normalizes mentions in the activity by removing mention tags and optionally removing recipient mention.\r\n   * @param removeMention Whether to remove the recipient mention from the activity.\r\n   */\r\n  public normalizeMentions (removeMention: boolean = false): void {\r\n    if (this.type === ActivityTypes.Message) {\r\n      if (removeMention) {\r\n        // Strip recipient mention tags and text\r\n        this.removeRecipientMention()\r\n\r\n        // Strip entity.mention records for recipient id\r\n        if (this.entities !== undefined && this.recipient?.id) {\r\n          this.entities = this.entities.filter((entity) => {\r\n            if (entity.type.toLowerCase() === 'mention') {\r\n              const mention = entity as unknown as Mention\r\n              return mention.mentioned.id !== this.recipient?.id\r\n            }\r\n            return true\r\n          })\r\n        }\r\n      }\r\n\r\n      // Remove <at> </at> tags keeping the inner text\r\n      if (this.text) {\r\n        this.text = Activity.removeAt(this.text)\r\n      }\r\n\r\n      // Remove <at> </at> tags from mention records keeping the inner text\r\n      if (this.entities !== undefined) {\r\n        const mentions = this.getMentions(this)\r\n        for (const mention of mentions) {\r\n          if (mention.text) {\r\n            mention.text = Activity.removeAt(mention.text)?.trim()\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes <at> </at> tags from the specified text.\r\n   * @param text The text to process.\r\n   * @returns The text with <at> </at> tags removed.\r\n   */\r\n  private static removeAt (text: string): string {\r\n    if (!text) {\r\n      return text\r\n    }\r\n\r\n    let foundTag: boolean\r\n    do {\r\n      foundTag = false\r\n      const iAtStart = text.toLowerCase().indexOf('<at')\r\n      if (iAtStart >= 0) {\r\n        const iAtEnd = text.indexOf('>', iAtStart)\r\n        if (iAtEnd > 0) {\r\n          const iAtClose = text.toLowerCase().indexOf('</at>', iAtEnd)\r\n          if (iAtClose > 0) {\r\n            // Replace </at>\r\n            let followingText = text.substring(iAtClose + 5)\r\n\r\n            // If first char of followingText is not whitespace, insert space\r\n            if (followingText.length > 0 && !(/\\s/.test(followingText[0]))) {\r\n              followingText = ` ${followingText}`\r\n            }\r\n\r\n            text = text.substring(0, iAtClose) + followingText\r\n\r\n            // Get tag content (text between <at...> and </at>)\r\n            const tagContent = text.substring(iAtEnd + 1, iAtClose)\r\n\r\n            // Replace <at ...> with just the tag content\r\n            let prefixText = text.substring(0, iAtStart)\r\n\r\n            // If prefixText is not empty and doesn't end with whitespace, add a space\r\n            if (prefixText.length > 0 && !(/\\s$/.test(prefixText))) {\r\n              prefixText += ' '\r\n            }\r\n\r\n            text = prefixText + tagContent + followingText\r\n\r\n            // We found one, try again, there may be more\r\n            foundTag = true\r\n          }\r\n        }\r\n      }\r\n    } while (foundTag)\r\n\r\n    return text\r\n  }\r\n\r\n  /**\r\n   * Removes the mention text for a given ID.\r\n   * @param id The ID of the mention to remove.\r\n   * @returns The updated text.\r\n   */\r\n  public removeMentionText (id: string): string {\r\n    const mentions = this.getMentions(this)\r\n    const mentionsFiltered = mentions.filter((mention): boolean => mention.mentioned.id === id)\r\n    if ((mentionsFiltered.length > 0) && this.text) {\r\n      this.text = this.text.replace(mentionsFiltered[0].text, '').trim()\r\n    }\r\n    return this.text || ''\r\n  }\r\n\r\n  /**\r\n   * Removes the recipient mention from the activity text.\r\n   * @returns The updated text.\r\n   */\r\n  public removeRecipientMention (): string {\r\n    if ((this.recipient != null) && this.recipient.id) {\r\n      return this.removeMentionText(this.recipient.id)\r\n    }\r\n    return ''\r\n  }\r\n\r\n  /**\r\n   * Gets the conversation reference for a reply.\r\n   * @param replyId The ID of the reply.\r\n   * @returns The conversation reference.\r\n   */\r\n  public getReplyConversationReference (\r\n    replyId: string\r\n  ): ConversationReference {\r\n    const reference: ConversationReference = this.getConversationReference()\r\n\r\n    reference.activityId = replyId\r\n\r\n    return reference\r\n  }\r\n\r\n  public toJsonString (): string {\r\n    return JSON.stringify(this)\r\n  }\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Constants representing caller IDs.\r\n */\r\nexport const CallerIdConstants = {\r\n  /**\r\n   * Public Azure channel caller ID.\r\n   */\r\n  PublicAzureChannel: 'urn:botframework:azure',\r\n  /**\r\n   * US Government channel caller ID.\r\n   */\r\n  USGovChannel: 'urn:botframework:azureusgov',\r\n  /**\r\n   * Agent prefix for caller ID.\r\n   */\r\n  AgentPrefix: 'urn:botframework:aadappid:'\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { z } from 'zod'\r\n\r\n/**\r\n * Enum representing treatment types for the activity.\r\n */\r\nexport enum ActivityTreatments {\r\n  /**\r\n   * Indicates that only the recipient should be able to see the message even if the activity\r\n   * is being sent to a group of people.\r\n   */\r\n  Targeted = 'targeted',\r\n}\r\n\r\n/**\r\n * Zod schema for validating an ActivityTreatments enum.\r\n */\r\nexport const activityTreatments = z.nativeEnum(ActivityTreatments)\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Export statements for various modules.\r\n */\r\nexport { ActionTypes } from './action/actionTypes'\r\nexport { CardAction } from './action/cardAction'\r\nexport { SemanticAction } from './action/semanticAction'\r\nexport { SemanticActionStateTypes } from './action/semanticActionStateTypes'\r\nexport { SuggestedActions } from './action/suggestedActions'\r\n\r\nexport { Attachment } from './attachment/attachment'\r\nexport { AttachmentLayoutTypes } from './attachment/attachmentLayoutTypes'\r\n\r\nexport { ChannelAccount } from './conversation/channelAccount'\r\nexport { Channels } from './conversation/channels'\r\nexport { ConversationAccount } from './conversation/conversationAccount'\r\nexport { ConversationReference } from './conversation/conversationReference'\r\nexport { EndOfConversationCodes } from './conversation/endOfConversationCodes'\r\nexport { ConversationParameters } from './conversation/conversationParameters'\r\nexport { MembershipSource } from './conversation/membershipSource'\r\nexport { MembershipSourceTypes } from './conversation/membershipSourceTypes'\r\nexport { MembershipTypes } from './conversation/membershipTypes'\r\nexport { RoleTypes } from './conversation/roleTypes'\r\n\r\nexport { Entity } from './entity/entity'\r\nexport { Mention } from './entity/mention'\r\nexport { GeoCoordinates } from './entity/geoCoordinates'\r\nexport { Place } from './entity/place'\r\nexport { Thing } from './entity/thing'\r\nexport * from './entity/AIEntity'\r\n\r\nexport * from './invoke/adaptiveCardInvokeAction'\r\n\r\nexport { Activity, activityZodSchema } from './activity'\r\nexport { ActivityEventNames } from './activityEventNames'\r\nexport { ActivityImportance } from './activityImportance'\r\nexport { ActivityTypes } from './activityTypes'\r\nexport { CallerIdConstants } from './callerIdConstants'\r\nexport { DeliveryModes } from './deliveryModes'\r\nexport { ExpectedReplies } from './expectedReplies'\r\nexport { InputHints } from './inputHints'\r\nexport { MessageReaction } from './messageReaction'\r\nexport { MessageReactionTypes } from './messageReactionTypes'\r\nexport { TextFormatTypes } from './textFormatTypes'\r\nexport { TextHighlight } from './textHighlight'\r\nexport { ActivityTreatments } from './activityTreatments'\r\nexport { debug, Logger } from './logger'\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Activity } from '@microsoft/agents-activity'\r\n\r\n/**\r\n * Represents a request to execute a turn in a conversation.\r\n * This class encapsulates the activity to be executed during the turn.\r\n */\r\nexport class ExecuteTurnRequest {\r\n  /** The activity to be executed. */\r\n  activity?: Activity\r\n\r\n  /**\r\n   * Creates an instance of ExecuteTurnRequest.\r\n   * @param activity The activity to be executed.\r\n   */\r\n  constructor (activity?: Activity) {\r\n    this.activity = activity\r\n  }\r\n}\r\n", "{\r\n  \"name\": \"@microsoft/agents-copilotstudio-client\",\r\n  \"version\": \"0.1.0\",\r\n  \"homepage\": \"https://github.com/microsoft/Agents-for-js\",\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"git+https://github.com/microsoft/Agents-for-js.git\"\r\n  },\r\n  \"author\": {\r\n    \"name\": \"Microsoft\",\r\n    \"email\": \"agentssdk@microsoft.com\",\r\n    \"url\": \"https://aka.ms/Agents\"\r\n  },\r\n  \"description\": \"Microsoft Copilot Studio Client for JavaScript. Copilot Studio Client.\",\r\n  \"keywords\": [\r\n    \"Agents\",\r\n    \"copilotstudio\",\r\n    \"powerplatform\"\r\n  ],\r\n  \"main\": \"dist/src/index.js\",\r\n  \"types\": \"dist/src/index.d.ts\",\r\n  \"browser\": {\r\n    \"os\": \"./src/browser/os.ts\",\r\n    \"crypto\": \"./src/browser/crypto.ts\"\r\n  },\r\n  \"scripts\": {\r\n    \"build:browser\": \"esbuild --platform=browser --target=es2019 --format=esm --bundle --sourcemap --minify --outfile=dist/src/browser.mjs src/index.ts\"\r\n  },\r\n  \"dependencies\": {\r\n    \"@microsoft/agents-activity\": \"file:../agents-activity\",\r\n    \"eventsource-client\": \"^1.2.0\",\r\n    \"rxjs\": \"7.8.2\",\r\n    \"uuid\": \"^11.1.0\"\r\n  },\r\n  \"license\": \"MIT\",\r\n  \"files\": [\r\n    \"README.md\",\r\n    \"dist/src\",\r\n    \"src\",\r\n    \"package.json\"\r\n  ],\r\n  \"exports\": {\r\n    \".\": {\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n      \"import\": {\r\n        \"browser\": \"./dist/src/browser.mjs\",\r\n        \"default\": \"./dist/src/index.js\"\r\n      },\r\n      \"require\": {\r\n        \"default\": \"./dist/src/index.js\"\r\n      }\r\n    },\r\n    \"./package.json\": \"./package.json\"\r\n  },\r\n  \"engines\": {\r\n    \"node\": \">=20.0.0\"\r\n  }\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport type * as osTypes from 'os'\r\n\r\nexport default {} as typeof osTypes\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { createEventSource, EventSourceClient } from 'eventsource-client'\r\nimport { ConnectionSettings } from './connectionSettings'\r\nimport { getCopilotStudioConnectionUrl, getTokenAudience } from './powerPlatformEnvironment'\r\nimport { Activity, ActivityTypes, ConversationAccount } from '@microsoft/agents-activity'\r\nimport { ExecuteTurnRequest } from './executeTurnRequest'\r\nimport { debug } from '@microsoft/agents-activity/logger'\r\nimport { version } from '../package.json'\r\nimport os from 'os'\r\n\r\nconst logger = debug('copilot-studio:client')\r\n\r\n/**\r\n * Client for interacting with Microsoft Copilot Studio services.\r\n * Provides functionality to start conversations and send messages to Copilot Studio bots.\r\n */\r\nexport class CopilotStudioClient {\r\n  /** Header key for conversation ID. */\r\n  private static readonly conversationIdHeaderKey: string = 'x-ms-conversationid'\r\n  /** Island Header key */\r\n  private static readonly islandExperimentalUrlHeaderKey: string = 'x-ms-d2e-experimental'\r\n\r\n  /** The ID of the current conversation. */\r\n  private conversationId: string = ''\r\n  /** The connection settings for the client. */\r\n  private readonly settings: ConnectionSettings\r\n  /** The authenticaton token. */\r\n  private readonly token: string\r\n\r\n  /**\r\n   * Returns the scope URL needed to connect to Copilot Studio from the connection settings.\r\n   * This is used for authentication token audience configuration.\r\n   * @param settings Copilot Studio connection settings.\r\n   * @returns The scope URL for token audience.\r\n   */\r\n  static scopeFromSettings: (settings: ConnectionSettings) => string = getTokenAudience\r\n\r\n  /**\r\n   * Creates an instance of CopilotStudioClient.\r\n   * @param settings The connection settings.\r\n   * @param token The authentication token.\r\n   */\r\n  constructor (settings: ConnectionSettings, token: string) {\r\n    this.settings = settings\r\n    this.token = token\r\n  }\r\n\r\n  /**\r\n   * Streams activities from the Copilot Studio service using eventsource-client.\r\n   * @param url The connection URL for Copilot Studio.\r\n   * @param body Optional. The request body (for POST).\r\n   * @param method Optional. The HTTP method (default: POST).\r\n   * @returns An async generator yielding the Agent's Activities.\r\n   */\r\n  private async * postRequestAsync (url: string, body?: any, method: string = 'POST'): AsyncGenerator<Activity> {\r\n    logger.debug(`>>> SEND TO ${url}`)\r\n\r\n    const eventSource: EventSourceClient = createEventSource({\r\n      url,\r\n      headers: {\r\n        Authorization: `Bearer ${this.token}`,\r\n        'User-Agent': CopilotStudioClient.getProductInfo(),\r\n        'Content-Type': 'application/json',\r\n        Accept: 'text/event-stream'\r\n      },\r\n      body: body ? JSON.stringify(body) : undefined,\r\n      method,\r\n      fetch: async (url, init) => {\r\n        const response = await fetch(url, init)\r\n        this.processResponseHeaders(response.headers)\r\n        return response\r\n      }\r\n    })\r\n\r\n    try {\r\n      for await (const { data, event } of eventSource) {\r\n        if (data && event === 'activity') {\r\n          try {\r\n            const activity = Activity.fromJson(data)\r\n            switch (activity.type) {\r\n              case ActivityTypes.Message:\r\n                if (!this.conversationId.trim()) { // Did not get it from the header.\r\n                  this.conversationId = activity.conversation?.id ?? ''\r\n                  logger.debug(`Conversation ID: ${this.conversationId}`)\r\n                }\r\n                yield activity\r\n                break\r\n              default:\r\n                logger.debug(`Activity type: ${activity.type}`)\r\n                yield activity\r\n                break\r\n            }\r\n          } catch (error) {\r\n            logger.error('Failed to parse activity:', error)\r\n          }\r\n        } else if (event === 'end') {\r\n          logger.debug('Stream complete')\r\n          break\r\n        }\r\n\r\n        if (eventSource.readyState === 'closed') {\r\n          logger.debug('Connection closed')\r\n          break\r\n        }\r\n      }\r\n    } finally {\r\n      eventSource.close()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Appends this package.json version to the User-Agent header.\r\n   * - For browser environments, it includes the user agent of the browser.\r\n   * - For Node.js environments, it includes the Node.js version, platform, architecture, and release.\r\n   * @returns A string containing the product information, including version and user agent.\r\n   */\r\n  private static getProductInfo (): string {\r\n    const versionString = `CopilotStudioClient.agents-sdk-js/${version}`\r\n    let userAgent: string\r\n\r\n    if (typeof window !== 'undefined' && window.navigator) {\r\n      userAgent = `${versionString} ${navigator.userAgent}`\r\n    } else {\r\n      userAgent = `${versionString} nodejs/${process.version} ${os.platform()}-${os.arch()}/${os.release()}`\r\n    }\r\n\r\n    logger.debug(`User-Agent: ${userAgent}`)\r\n    return userAgent\r\n  }\r\n\r\n  private processResponseHeaders (responseHeaders: Headers): void {\r\n    if (this.settings.useExperimentalEndpoint && !this.settings.directConnectUrl?.trim()) {\r\n      const islandExperimentalUrl = responseHeaders?.get(CopilotStudioClient.islandExperimentalUrlHeaderKey)\r\n      if (islandExperimentalUrl) {\r\n        this.settings.directConnectUrl = islandExperimentalUrl\r\n        logger.debug(`Island Experimental URL: ${islandExperimentalUrl}`)\r\n      }\r\n    }\r\n\r\n    this.conversationId = responseHeaders?.get(CopilotStudioClient.conversationIdHeaderKey) ?? ''\r\n    if (this.conversationId) {\r\n      logger.debug(`Conversation ID: ${this.conversationId}`)\r\n    }\r\n\r\n    const sanitizedHeaders = new Headers()\r\n    responseHeaders.forEach((value, key) => {\r\n      if (key.toLowerCase() !== 'authorization' && key.toLowerCase() !== CopilotStudioClient.conversationIdHeaderKey.toLowerCase()) {\r\n        sanitizedHeaders.set(key, value)\r\n      }\r\n    })\r\n    logger.debug('Headers received:', sanitizedHeaders)\r\n  }\r\n\r\n  /**\r\n   * Starts a new conversation with the Copilot Studio service.\r\n   * @param emitStartConversationEvent Whether to emit a start conversation event. Defaults to true.\r\n   * @returns An async generator yielding the Agent's Activities.\r\n   */\r\n  public async * startConversationAsync (emitStartConversationEvent: boolean = true): AsyncGenerator<Activity> {\r\n    const uriStart: string = getCopilotStudioConnectionUrl(this.settings)\r\n    const body = { emitStartConversationEvent }\r\n\r\n    logger.info('Starting conversation ...')\r\n\r\n    yield * this.postRequestAsync(uriStart, body, 'POST')\r\n  }\r\n\r\n  /**\r\n   * Sends a question to the Copilot Studio service and retrieves the response activities.\r\n   * @param question The question to ask.\r\n   * @param conversationId The ID of the conversation. Defaults to the current conversation ID.\r\n   * @returns An async generator yielding the Agent's Activities.\r\n   */\r\n  public async * askQuestionAsync (question: string, conversationId: string = this.conversationId) : AsyncGenerator<Activity> {\r\n    const conversationAccount: ConversationAccount = {\r\n      id: conversationId\r\n    }\r\n    const activityObj = {\r\n      type: 'message',\r\n      text: question,\r\n      conversation: conversationAccount\r\n    }\r\n    const activity = Activity.fromObject(activityObj)\r\n\r\n    yield * this.sendActivity(activity)\r\n  }\r\n\r\n  /**\r\n   * Sends an activity to the Copilot Studio service and retrieves the response activities.\r\n   * @param activity The activity to send.\r\n   * @param conversationId The ID of the conversation. Defaults to the current conversation ID.\r\n   * @returns An async generator yielding the Agent's Activities.\r\n   */\r\n  public async * sendActivity (activity: Activity, conversationId: string = this.conversationId) : AsyncGenerator<Activity> {\r\n    const localConversationId = activity.conversation?.id ?? conversationId\r\n    const uriExecute = getCopilotStudioConnectionUrl(this.settings, localConversationId)\r\n    const qbody: ExecuteTurnRequest = new ExecuteTurnRequest(activity)\r\n\r\n    logger.info('Sending activity...', activity)\r\n    yield * this.postRequestAsync(uriExecute, qbody, 'POST')\r\n  }\r\n}\r\n", "/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n */\nexport class Subscription implements SubscriptionLike {\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param value The `next` value.\n   */\n  next(value: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param err The `error` exception.\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as ((value: T) => void) | undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent.\n * @param subscriber The stopped subscriber.\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n", "import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @param subscribe The function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @param subscribe the subscriber function to be passed to the Observable constructor\n   * @return A new observable.\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @param operator the operator defining the operation to take on the observable\n   * @return A new observable with the Operator applied.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @param error A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param complete A handler for a terminal event resulting from successful completion.\n   * @return A subscription reference to the registered handlers.\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next A handler for each value emitted by the observable.\n   * @return A promise that either resolves on observable completion or\n   * rejects with the handled error.\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @return This instance of the observable.\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @return The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n", "import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n", "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param _bufferSize The size of the buffer to replay on subscription\n   * @param _windowTime The amount of time the buffered items will stay buffered\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param state Some contextual data that the `work` function uses when called by the\n   * Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is implicit\n   * and defined by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param work A function representing a task, or some unit of work to be\n   * executed by the Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is\n   * implicit and defined by the Scheduler itself.\n   * @param state Some contextual data that the `work` function uses when called\n   * by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    let flushId;\n    if (action) {\n      flushId = action.id;\n    } else {\n      flushId = this._scheduled;\n      this._scheduled = undefined;\n    }\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param input A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return An Observable converted from {@link ObservableInput}.\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n", "import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param args A comma separated list of arguments you want to be emitted.\n * @return An Observable that synchronously emits the arguments described\n * above and then immediately completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param value The `next` value.\n   * @return The \"next\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param err The `error` error.\n   * @return The \"error\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return The valueless \"complete\" Notification.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n", "/** prettier */\nimport { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\n\n/**\n * Tests to see if the object is an RxJS {@link Observable}\n * @param obj the object to test\n */\nexport function isObservable(obj: any): obj is Observable<unknown> {\n  // The !! is to ensure that this publicly exposed function returns\n  // `false` if something like `null` or `0` is passed.\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\n  (_super) =>\n    function EmptyErrorImpl(this: any) {\n      _super(this);\n      this.name = 'EmptyError';\n      this.message = 'no elements in sequence';\n    }\n);\n", "import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n", "import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n", "/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param project The function to apply to each `value` emitted by the source\n * Observable. The `index` parameter is the number `i` for the i-th emission\n * that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n", "import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}", "import { SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { Observable } from '../Observable';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { observeOn } from '../operators/observeOn';\nimport { AsyncSubject } from '../AsyncSubject';\n\nexport function bindCallbackInternals(\n  isNodeStyle: boolean,\n  callbackFunc: any,\n  resultSelector?: any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  if (resultSelector) {\n    if (isScheduler(resultSelector)) {\n      scheduler = resultSelector;\n    } else {\n      // The user provided a result selector.\n      return function (this: any, ...args: any[]) {\n        return (bindCallbackInternals(isNodeStyle, callbackFunc, scheduler) as any)\n          .apply(this, args)\n          .pipe(mapOneOrManyArgs(resultSelector as any));\n      };\n    }\n  }\n\n  // If a scheduler was passed, use our `subscribeOn` and `observeOn` operators\n  // to compose that behavior for the user.\n  if (scheduler) {\n    return function (this: any, ...args: any[]) {\n      return (bindCallbackInternals(isNodeStyle, callbackFunc) as any)\n        .apply(this, args)\n        .pipe(subscribeOn(scheduler!), observeOn(scheduler!));\n    };\n  }\n\n  return function (this: any, ...args: any[]): Observable<any> {\n    // We're using AsyncSubject, because it emits when it completes,\n    // and it will play the value to all late-arriving subscribers.\n    const subject = new AsyncSubject<any>();\n\n    // If this is true, then we haven't called our function yet.\n    let uninitialized = true;\n    return new Observable((subscriber) => {\n      // Add our subscriber to the subject.\n      const subs = subject.subscribe(subscriber);\n\n      if (uninitialized) {\n        uninitialized = false;\n        // We're going to execute the bound function\n        // This bit is to signal that we are hitting the callback asynchronously.\n        // Because we don't have any anti-\"Zalgo\" guarantees with whatever\n        // function we are handed, we use this bit to figure out whether or not\n        // we are getting hit in a callback synchronously during our call.\n        let isAsync = false;\n\n        // This is used to signal that the callback completed synchronously.\n        let isComplete = false;\n\n        // Call our function that has a callback. If at any time during this\n        // call, an error is thrown, it will be caught by the Observable\n        // subscription process and sent to the consumer.\n        callbackFunc.apply(\n          // Pass the appropriate `this` context.\n          this,\n          [\n            // Pass the arguments.\n            ...args,\n            // And our callback handler.\n            (...results: any[]) => {\n              if (isNodeStyle) {\n                // If this is a node callback, shift the first value off of the\n                // results and check it, as it is the error argument. By shifting,\n                // we leave only the argument(s) we want to pass to the consumer.\n                const err = results.shift();\n                if (err != null) {\n                  subject.error(err);\n                  // If we've errored, we can stop processing this function\n                  // as there's nothing else to do. Just return to escape.\n                  return;\n                }\n              }\n              // If we have one argument, notify the consumer\n              // of it as a single value, otherwise, if there's more than one, pass\n              // them as an array. Note that if there are no arguments, `undefined`\n              // will be emitted.\n              subject.next(1 < results.length ? results : results[0]);\n              // Flip this flag, so we know we can complete it in the synchronous\n              // case below.\n              isComplete = true;\n              // If we're not asynchronous, we need to defer the `complete` call\n              // until after the call to the function is over. This is because an\n              // error could be thrown in the function after it calls our callback,\n              // and if that is the case, if we complete here, we are unable to notify\n              // the consumer than an error occurred.\n              if (isAsync) {\n                subject.complete();\n              }\n            },\n          ]\n        );\n        // If we flipped `isComplete` during the call, we resolved synchronously,\n        // notify complete, because we skipped it in the callback to wait\n        // to make sure there were no errors during the call.\n        if (isComplete) {\n          subject.complete();\n        }\n\n        // We're no longer synchronous. If the callback is called at this point\n        // we can notify complete on the spot.\n        isAsync = true;\n      }\n\n      // Return the subscription from adding our subscriber to the subject.\n      return subs;\n    });\n  };\n}\n", "/* @prettier */\nimport { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a callback API to a function that returns an Observable.\n *\n * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n * it will return a function `g` that when called as `g(x)` will output an\n * Observable.</span>\n *\n * `bindCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters. The\n * last parameter must be a callback function that `func` calls when it is\n * done.\n *\n * The output of `bindCallback` is a function that takes the same parameters\n * as `func`, except the last one (the callback). When the output function\n * is called with arguments it will return an Observable. If function `func`\n * calls its callback with one argument, the Observable will emit that value.\n * If on the other hand the callback is called with multiple values the resulting\n * Observable will emit an array with said values as arguments.\n *\n * It is **very important** to remember that input function `func` is not called\n * when the output function is, but rather when the Observable returned by the output\n * function is subscribed. This means if `func` makes an AJAX request, that request\n * will be made every time someone subscribes to the resulting Observable, but not before.\n *\n * The last optional parameter - `scheduler` - can be used to control when the call\n * to `func` happens after someone subscribes to Observable, as well as when results\n * passed to callback will be emitted. By default, the subscription to an Observable calls `func`\n * synchronously, but using {@link asyncScheduler} as the last parameter will defer the call to `func`,\n * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you were to use the async Scheduler\n * and call `subscribe` on the output Observable, all function calls that are currently executing\n * will end before `func` is invoked.\n *\n * By default, results passed to the callback are emitted immediately after `func` invokes the callback.\n * In particular, if the callback is called synchronously, then the subscription of the resulting Observable\n * will call the `next` function synchronously as well.  If you want to defer that call,\n * you may use {@link asyncScheduler} just as before.  This means that by using `Scheduler.async` you can\n * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n *\n * Note that the Observable created by the output function will always emit a single value\n * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n * calls will not appear in the stream. If you need to listen for multiple calls,\n *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n *\n * If `func` depends on some context (`this` property) and is not already bound, the context of `func`\n * will be the context that the output function has at call time. In particular, if `func`\n * is called as a method of some object and if `func` is not already bound, in order to preserve the context\n * it is recommended that the context of the output function is set to that object as well.\n *\n * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n * provides convenient error handling and probably is a better choice.\n * `bindCallback` will treat such functions the same as any other and error parameters\n * (whether passed or not) will always be interpreted as regular callback argument.\n *\n * ## Examples\n *\n * Convert jQuery's getJSON to an Observable API\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n * import * as jQuery from 'jquery';\n *\n * // Suppose we have jQuery.getJSON('/my/url', callback)\n * const getJSONAsObservable = bindCallback(jQuery.getJSON);\n * const result = getJSONAsObservable('/my/url');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * Receive an array of arguments passed to a callback\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const someFunction = (n, s, cb) => {\n *   cb(n, s, { someProperty: 'someValue' });\n * };\n *\n * const boundSomeFunction = bindCallback(someFunction);\n * boundSomeFunction(5, 'some string').subscribe((values) => {\n *   console.log(values); // [5, 'some string', {someProperty: 'someValue'}]\n * });\n * ```\n *\n * Compare behaviour with and without `asyncScheduler`\n *\n * ```ts\n * import { bindCallback, asyncScheduler } from 'rxjs';\n *\n * function iCallMyCallbackSynchronously(cb) {\n *   cb();\n * }\n *\n * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);\n * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);\n *\n * boundSyncFn().subscribe(() => console.log('I was sync!'));\n * boundAsyncFn().subscribe(() => console.log('I was async!'));\n * console.log('This happened...');\n *\n * // Logs:\n * // I was sync!\n * // This happened...\n * // I was async!\n * ```\n *\n * Use `bindCallback` on an object method\n *\n * ```ts\n * import { bindCallback } from 'rxjs';\n *\n * const boundMethod = bindCallback(someObject.methodWithCallback);\n * boundMethod\n *   .call(someObject) // make sure methodWithCallback has access to someObject\n *   .subscribe(subscriber);\n * ```\n *\n * @see {@link bindNodeCallback}\n * @see {@link from}\n *\n * @param callbackFunc A function with a callback as the last parameter.\n * @param resultSelector A mapping function used to transform callback events.\n * @param scheduler The scheduler on which to schedule the callbacks.\n * @return A function which returns the Observable that delivers the same\n * values the callback would deliver.\n */\nexport function bindCallback(\n  callbackFunc: (...args: [...any[], (...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<unknown> {\n  return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\n", "/* @prettier */\nimport { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { bindCallbackInternals } from './bindCallbackInternals';\n\nexport function bindNodeCallback(\n  callbackFunc: (...args: any[]) => void,\n  resultSelector: (...args: any[]) => any,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any>;\n\n// args is the arguments array and we push the callback on the rest tuple since the rest parameter must be last (only item) in a parameter list\nexport function bindNodeCallback<A extends readonly unknown[], R extends readonly unknown[]>(\n  callbackFunc: (...args: [...A, (err: any, ...res: R) => void]) => void,\n  schedulerLike?: SchedulerLike\n): (...arg: A) => Observable<R extends [] ? void : R extends [any] ? R[0] : R>;\n\n/**\n * Converts a Node.js-style callback API to a function that returns an\n * Observable.\n *\n * <span class=\"informal\">It's just like {@link bindCallback}, but the\n * callback is expected to be of type `callback(error, result)`.</span>\n *\n * `bindNodeCallback` is not an operator because its input and output are not\n * Observables. The input is a function `func` with some parameters, but the\n * last parameter must be a callback function that `func` calls when it is\n * done. The callback function is expected to follow Node.js conventions,\n * where the first argument to the callback is an error object, signaling\n * whether call was successful. If that object is passed to callback, it means\n * something went wrong.\n *\n * The output of `bindNodeCallback` is a function that takes the same\n * parameters as `func`, except the last one (the callback). When the output\n * function is called with arguments, it will return an Observable.\n * If `func` calls its callback with error parameter present, Observable will\n * error with that value as well. If error parameter is not passed, Observable will emit\n * second parameter. If there are more parameters (third and so on),\n * Observable will emit an array with all arguments, except first error argument.\n *\n * Note that `func` will not be called at the same time output function is,\n * but rather whenever resulting Observable is subscribed. By default call to\n * `func` will happen synchronously after subscription, but that can be changed\n * with proper `scheduler` provided as optional third parameter. {@link SchedulerLike}\n * can also control when values from callback will be emitted by Observable.\n * To find out more, check out documentation for {@link bindCallback}, where\n * {@link SchedulerLike} works exactly the same.\n *\n * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n * of returned function, when it is called.\n *\n * After Observable emits value, it will complete immediately. This means\n * even if `func` calls callback again, values from second and consecutive\n * calls will never appear on the stream. If you need to handle functions\n * that call callbacks multiple times, check out {@link fromEvent} or\n * {@link fromEventPattern} instead.\n *\n * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n * \"Node.js-style\" callbacks are just a convention, so if you write for\n * browsers or any other environment and API you use implements that callback style,\n * `bindNodeCallback` can be safely used on that API functions as well.\n *\n * Remember that Error object passed to callback does not have to be an instance\n * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n * Error parameter of callback function is interpreted as \"present\", when value\n * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n * string or boolean `true`. In all of these cases resulting Observable would error\n * with that value. This means usually regular style callbacks will fail very often when\n * `bindNodeCallback` is used. If your Observable errors much more often then you\n * would expect, check if callback really is called in Node.js-style and, if not,\n * switch to {@link bindCallback} instead.\n *\n * Note that even if error parameter is technically present in callback, but its value\n * is falsy, it still won't appear in array emitted by Observable.\n *\n * ## Examples\n *\n *  Read a file from the filesystem and get the data as an Observable\n *\n * ```ts\n * import * as fs from 'fs';\n * const readFileAsObservable = bindNodeCallback(fs.readFile);\n * const result = readFileAsObservable('./roadNames.txt', 'utf8');\n * result.subscribe(x => console.log(x), e => console.error(e));\n * ```\n *\n * Use on function calling callback with multiple arguments\n *\n * ```ts\n * someFunction((err, a, b) => {\n *   console.log(err); // null\n *   console.log(a); // 5\n *   console.log(b); // \"some string\"\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(value => {\n *   console.log(value); // [5, \"some string\"]\n * });\n * ```\n *\n * Use on function calling callback in regular style\n *\n * ```ts\n * someFunction(a => {\n *   console.log(a); // 5\n * });\n * const boundSomeFunction = bindNodeCallback(someFunction);\n * boundSomeFunction()\n * .subscribe(\n *   value => {}             // never gets called\n *   err => console.log(err) // 5\n * );\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link from}\n *\n * @param callbackFunc Function with a Node.js-style callback as the last parameter.\n * @param resultSelector A mapping function used to transform callback events.\n * @param scheduler The scheduler on which to schedule the callbacks.\n * @return A function which returns the Observable that delivers the same values the\n * Node.js callback would deliver.\n */\nexport function bindNodeCallback(\n  callbackFunc: (...args: [...any[], (err: any, ...res: any) => void]) => void,\n  resultSelector?: ((...args: any[]) => any) | SchedulerLike,\n  scheduler?: SchedulerLike\n): (...args: any[]) => Observable<any> {\n  return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\n", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "export function createObject(keys: string[], values: any[]) {\n  return keys.reduce((result, key, i) => ((result[key] = values[i]), result), {} as any);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf, ObservableInputTuple } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { Subscriber } from '../Subscriber';\nimport { from } from './from';\nimport { identity } from '../util/identity';\nimport { Subscription } from '../Subscription';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { popResultSelector, popScheduler } from '../util/args';\nimport { createObject } from '../util/createObject';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { AnyCatcher } from '../AnyCatcher';\nimport { executeSchedule } from '../util/executeSchedule';\n\n// combineLatest(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function combineLatest<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// combineLatest([a, b, c])\nexport function combineLatest(sources: []): Observable<never>;\nexport function combineLatest<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R,\n  scheduler: SchedulerLike\n): Observable<R>;\nexport function combineLatest<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  sources: readonly [...ObservableInputTuple<A>],\n  scheduler: SchedulerLike\n): Observable<A>;\n\n// combineLatest(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelectorAndScheduler: [...ObservableInputTuple<A>, (...values: A) => R, SchedulerLike]\n): Observable<R>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function combineLatest<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `combineLatestAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function combineLatest<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): Observable<A>;\n\n// combineLatest({a, b, c})\nexport function combineLatest(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function combineLatest<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * ![](combineLatest.png)\n *\n * `combineLatest` combines the values from all the Observables passed in the\n * observables array. This is done by subscribing to each Observable in order and,\n * whenever any Observable emits, collecting an array of the most recent\n * values from each Observable. So if you pass `n` Observables to this operator,\n * the returned Observable will always emit an array of `n` values, in an order\n * corresponding to the order of the passed Observables (the value from the first Observable\n * will be at index 0 of the array and so on).\n *\n * Static version of `combineLatest` accepts an array of Observables. Note that an array of\n * Observables is a good choice, if you don't know beforehand how many Observables\n * you will combine. Passing an empty array will result in an Observable that\n * completes immediately.\n *\n * To ensure the output array always has the same length, `combineLatest` will\n * actually wait for all input Observables to emit at least once,\n * before it starts emitting results. This means if some Observable emits\n * values before other Observables started emitting, all these values but the last\n * will be lost. On the other hand, if some Observable does not emit a value but\n * completes, resulting Observable will complete at the same moment without\n * emitting anything, since it will now be impossible to include a value from the\n * completed Observable in the resulting array. Also, if some input Observable does\n * not emit any value and never completes, `combineLatest` will also never emit\n * and never complete, since, again, it will wait for all streams to emit some\n * value.\n *\n * If at least one Observable was passed to `combineLatest` and all passed Observables\n * emitted something, the resulting Observable will complete when all combined\n * streams complete. So even if some Observable completes, the result of\n * `combineLatest` will still emit values when other Observables do. In case\n * of a completed Observable, its value from now on will always be the last\n * emitted value. On the other hand, if any Observable errors, `combineLatest`\n * will error immediately as well, and all other Observables will be unsubscribed.\n *\n * ## Examples\n *\n * Combine two timer Observables\n *\n * ```ts\n * import { timer, combineLatest } from 'rxjs';\n *\n * const firstTimer = timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n * const secondTimer = timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n * const combinedTimers = combineLatest([firstTimer, secondTimer]);\n * combinedTimers.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0] after 0.5s\n * // [1, 0] after 1s\n * // [1, 1] after 1.5s\n * // [2, 1] after 2s\n * ```\n *\n * Combine a dictionary of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = {\n *   a: of(1).pipe(delay(1000), startWith(0)),\n *   b: of(5).pipe(delay(5000), startWith(0)),\n *   c: of(10).pipe(delay(10000), startWith(0))\n * };\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // { a: 0, b: 0, c: 0 } immediately\n * // { a: 1, b: 0, c: 0 } after 1s\n * // { a: 1, b: 5, c: 0 } after 5s\n * // { a: 1, b: 5, c: 10 } after 10s\n * ```\n *\n * Combine an array of Observables\n *\n * ```ts\n * import { of, delay, startWith, combineLatest } from 'rxjs';\n *\n * const observables = [1, 5, 10].map(\n *   n => of(n).pipe(\n *     delay(n * 1000), // emit 0 and then emit n after n seconds\n *     startWith(0)\n *   )\n * );\n * const combined = combineLatest(observables);\n * combined.subscribe(value => console.log(value));\n * // Logs\n * // [0, 0, 0] immediately\n * // [1, 0, 0] after 1s\n * // [1, 5, 0] after 5s\n * // [1, 5, 10] after 10s\n * ```\n *\n * Use map operator to dynamically calculate the Body-Mass Index\n *\n * ```ts\n * import { of, combineLatest, map } from 'rxjs';\n *\n * const weight = of(70, 72, 76, 79, 75);\n * const height = of(1.76, 1.77, 1.78);\n * const bmi = combineLatest([weight, height]).pipe(\n *   map(([w, h]) => w / (h * h)),\n * );\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\n * to combine with each other. If the last parameter is the function, it will be used to project the\n * values from the combined latest values into a new value on the output Observable.\n * @return An Observable of projected values from the most recent values from each `ObservableInput`,\n * or an array of the most recent values from each `ObservableInput`.\n */\nexport function combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]> {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n\n  const { args: observables, keys } = argsArgArrayOrObject(args);\n\n  if (observables.length === 0) {\n    // If no observables are passed, or someone has passed an empty array\n    // of observables, or even an empty object POJO, we need to just\n    // complete (EMPTY), but we have to honor the scheduler provided if any.\n    return from([], scheduler as any);\n  }\n\n  const result = new Observable<ObservedValueOf<O>[]>(\n    combineLatestInit(\n      observables as ObservableInput<ObservedValueOf<O>>[],\n      scheduler,\n      keys\n        ? // A handler for scrubbing the array of args into a dictionary.\n          (values) => createObject(keys, values)\n        : // A passthrough to just return the array\n          identity\n    )\n  );\n\n  return resultSelector ? (result.pipe(mapOneOrManyArgs(resultSelector)) as Observable<R>) : result;\n}\n\nexport function combineLatestInit(\n  observables: ObservableInput<any>[],\n  scheduler?: SchedulerLike,\n  valueTransform: (values: any[]) => any = identity\n) {\n  return (subscriber: Subscriber<any>) => {\n    // The outer subscription. We're capturing this in a function\n    // because we may have to schedule it.\n    maybeSchedule(\n      scheduler,\n      () => {\n        const { length } = observables;\n        // A store for the values each observable has emitted so far. We match observable to value on index.\n        const values = new Array(length);\n        // The number of currently active subscriptions, as they complete, we decrement this number to see if\n        // we are all done combining values, so we can complete the result.\n        let active = length;\n        // The number of inner sources that still haven't emitted the first value\n        // We need to track this because all sources need to emit one value in order\n        // to start emitting values.\n        let remainingFirstValues = length;\n        // The loop to kick off subscription. We're keying everything on index `i` to relate the observables passed\n        // in to the slot in the output array or the key in the array of keys in the output dictionary.\n        for (let i = 0; i < length; i++) {\n          maybeSchedule(\n            scheduler,\n            () => {\n              const source = from(observables[i], scheduler as any);\n              let hasFirstValue = false;\n              source.subscribe(\n                createOperatorSubscriber(\n                  subscriber,\n                  (value) => {\n                    // When we get a value, record it in our set of values.\n                    values[i] = value;\n                    if (!hasFirstValue) {\n                      // If this is our first value, record that.\n                      hasFirstValue = true;\n                      remainingFirstValues--;\n                    }\n                    if (!remainingFirstValues) {\n                      // We're not waiting for any more\n                      // first values, so we can emit!\n                      subscriber.next(valueTransform(values.slice()));\n                    }\n                  },\n                  () => {\n                    if (!--active) {\n                      // We only complete the result if we have no more active\n                      // inner observables.\n                      subscriber.complete();\n                    }\n                  }\n                )\n              );\n            },\n            subscriber\n          );\n        }\n      },\n      subscriber\n    );\n  };\n}\n\n/**\n * A small utility to handle the couple of locations where we want to schedule if a scheduler was provided,\n * but we don't if there was no scheduler.\n */\nfunction maybeSchedule(scheduler: SchedulerLike | undefined, execute: () => void, subscription: Subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n", "import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param concurrent Maximum number of inner Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n", "import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args `ObservableInput`s to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n", "import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param observableFactory The Observable factory function to invoke for each\n * Observer that subscribes to the output Observable. May also return any\n * `ObservableInput`, which will be converted on the fly to an Observable.\n * @return An Observable whose Observers' subscriptions trigger an invocation of the\n * given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n", "import { Connectable, ObservableInput, SubjectLike } from '../types';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\n\nexport interface ConnectableConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n  /**\n   * If true, the resulting observable will reset internal state upon disconnection\n   * and return to a \"cold\" state. This allows the resulting observable to be\n   * reconnected.\n   * If false, upon disconnection, the connecting subject will remain the\n   * connecting subject, meaning the resulting observable will not go \"cold\" again,\n   * and subsequent repeats or resubscriptions will resubscribe to that same subject.\n   */\n  resetOnDisconnect?: boolean;\n}\n\n/**\n * The default configuration for `connectable`.\n */\nconst DEFAULT_CONFIG: ConnectableConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n  resetOnDisconnect: true,\n};\n\n/**\n * Creates an observable that multicasts once `connect()` is called on it.\n *\n * @param source The observable source to make connectable.\n * @param config The configuration object for `connectable`.\n * @returns A \"connectable\" observable, that has a `connect()` method, that you must call to\n * connect the source to all consumers through the subject provided as the connector.\n */\nexport function connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): Connectable<T> {\n  // The subscription representing the connection.\n  let connection: Subscription | null = null;\n  const { connector, resetOnDisconnect = true } = config;\n  let subject = connector();\n\n  const result: any = new Observable<T>((subscriber) => {\n    return subject.subscribe(subscriber);\n  });\n\n  // Define the `connect` function. This is what users must call\n  // in order to \"connect\" the source to the subject that is\n  // multicasting it.\n  result.connect = () => {\n    if (!connection || connection.closed) {\n      connection = defer(() => source).subscribe(subject);\n      if (resetOnDisconnect) {\n        connection.add(() => (subject = connector()));\n      }\n    }\n    return connection;\n  };\n\n  return result;\n}\n", "import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInputTuple, ObservableInput } from '../types';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nimport { AnyCatcher } from '../AnyCatcher';\n\n// forkJoin(any)\n// We put this first because we need to catch cases where the user has supplied\n// _exactly `any`_ as the argument. Since `any` literally matches _anything_,\n// we don't want it to randomly hit one of the other type signatures below,\n// as we have no idea at build-time what type we should be returning when given an any.\n\n/**\n * You have passed `any` here, we can't figure out if it is\n * an array or an object, so you're getting `unknown`. Use better types.\n * @param arg Something typed as `any`\n */\nexport function forkJoin<T extends AnyCatcher>(arg: T): Observable<unknown>;\n\n// forkJoin(null | undefined)\nexport function forkJoin(scheduler: null | undefined): Observable<never>;\n\n// forkJoin([a, b, c])\nexport function forkJoin(sources: readonly []): Observable<never>;\nexport function forkJoin<A extends readonly unknown[]>(sources: readonly [...ObservableInputTuple<A>]): Observable<A>;\nexport function forkJoin<A extends readonly unknown[], R>(\n  sources: readonly [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\n\n// forkJoin(a, b, c)\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\n/** @deprecated Pass an array of sources instead. The rest-parameters signature will be removed in v8. Details: https://rxjs.dev/deprecations/array-argument */\nexport function forkJoin<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n// forkJoin({a, b, c})\nexport function forkJoin(sourcesObject: { [K in any]: never }): Observable<never>;\nexport function forkJoin<T extends Record<string, ObservableInput<any>>>(\n  sourcesObject: T\n): Observable<{ [K in keyof T]: ObservedValueOf<T[K]> }>;\n\n/**\n * Accepts an `Array` of {@link ObservableInput} or a dictionary `Object` of {@link ObservableInput} and returns\n * an {@link Observable} that emits either an array of values in the exact same order as the passed array,\n * or a dictionary of values in the same shape as the passed dictionary.\n *\n * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted;\n * complete immediately if an empty array is passed.</span>\n *\n * ![](forkJoin.png)\n *\n * `forkJoin` is an operator that takes any number of input observables which can be passed either as an array\n * or a dictionary of input observables. If no input observables are provided (e.g. an empty array is passed),\n * then the resulting stream will complete immediately.\n *\n * `forkJoin` will wait for all passed observables to emit and complete and then it will emit an array or an object with last\n * values from corresponding observables.\n *\n * If you pass an array of `n` observables to the operator, then the resulting\n * array will have `n` values, where the first value is the last one emitted by the first observable,\n * second value is the last one emitted by the second observable and so on.\n *\n * If you pass a dictionary of observables to the operator, then the resulting\n * objects will have the same keys as the dictionary passed, with their last values they have emitted\n * located at the corresponding key.\n *\n * That means `forkJoin` will not emit more than once and it will complete after that. If you need to emit combined\n * values not only at the end of the lifecycle of passed observables, but also throughout it, try out {@link combineLatest}\n * or {@link zip} instead.\n *\n * In order for the resulting array to have the same length as the number of input observables, whenever any of\n * the given observables completes without emitting any value, `forkJoin` will complete at that moment as well\n * and it will not emit anything either, even if it already has some last values from other observables.\n * Conversely, if there is an observable that never completes, `forkJoin` will never complete either,\n * unless at any point some other observable completes without emitting a value, which brings us back to\n * the previous case. Overall, in order for `forkJoin` to emit a value, all given observables\n * have to emit something at least once and complete.\n *\n * If any given observable errors at some point, `forkJoin` will error as well and immediately unsubscribe\n * from the other observables.\n *\n * Optionally `forkJoin` accepts a `resultSelector` function, that will be called with values which normally\n * would land in the emitted array. Whatever is returned by the `resultSelector`, will appear in the output\n * observable instead. This means that the default `resultSelector` can be thought of as a function that takes\n * all its arguments and puts them into an array. Note that the `resultSelector` will be called only\n * when `forkJoin` is supposed to emit a result.\n *\n * ## Examples\n *\n * Use `forkJoin` with a dictionary of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin({\n *   foo: of(1, 2, 3, 4),\n *   bar: Promise.resolve(8),\n *   baz: timer(4000)\n * });\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // { foo: 4, bar: 8, baz: 0 } after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * Use `forkJoin` with an array of observable inputs\n *\n * ```ts\n * import { forkJoin, of, timer } from 'rxjs';\n *\n * const observable = forkJoin([\n *   of(1, 2, 3, 4),\n *   Promise.resolve(8),\n *   timer(4000)\n * ]);\n * observable.subscribe({\n *  next: value => console.log(value),\n *  complete: () => console.log('This is how it ends!'),\n * });\n *\n * // Logs:\n * // [4, 8, 0] after 4 seconds\n * // 'This is how it ends!' immediately after\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n *\n * @param args Any number of `ObservableInput`s provided either as an array, as an object\n * or as arguments passed directly to the operator.\n * @return Observable emitting either an array of last values emitted by passed Observables\n * or value from project function.\n */\nexport function forkJoin(...args: any[]): Observable<any> {\n  const resultSelector = popResultSelector(args);\n  const { args: sources, keys } = argsArgArrayOrObject(args);\n  const result = new Observable((subscriber) => {\n    const { length } = sources;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(length);\n    let remainingCompletions = length;\n    let remainingEmissions = length;\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      let hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            if (!hasValue) {\n              hasValue = true;\n              remainingEmissions--;\n            }\n            values[sourceIndex] = value;\n          },\n          () => remainingCompletions--,\n          undefined,\n          () => {\n            if (!remainingCompletions || !hasValue) {\n              if (!remainingEmissions) {\n                subscriber.next(keys ? createObject(keys, values) : values);\n              }\n              subscriber.complete();\n            }\n          }\n        )\n      );\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\n * NodeList or HTMLCollection to attach the event handler to.\n * @param eventName The event name of interest, being emitted by the `target`.\n * @param options Options to pass through to the underlying `addListener`,\n * `addEventListener` or `on` functions.\n * @param resultSelector A mapping function used to transform events. It takes the\n * arguments from the event handler and should return a single value.\n * @return An Observable emitting events registered through `target`'s\n * listener handlers.\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n", "import { Observable } from '../Observable';\nimport { isFunction } from '../util/isFunction';\nimport { NodeEventHandler } from './fromEvent';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n/* tslint:disable:max-line-length */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void\n): Observable<T>;\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Creates an Observable from an arbitrary API for registering event handlers.\n *\n * <span class=\"informal\">When that method for adding event handler was something {@link fromEvent}\n * was not prepared for.</span>\n *\n * ![](fromEventPattern.png)\n *\n * `fromEventPattern` allows you to convert into an Observable any API that supports registering handler functions\n * for events. It is similar to {@link fromEvent}, but far\n * more flexible. In fact, all use cases of {@link fromEvent} could be easily handled by\n * `fromEventPattern` (although in slightly more verbose way).\n *\n * This operator accepts as a first argument an `addHandler` function, which will be injected with\n * handler parameter. That handler is actually an event handler function that you now can pass\n * to API expecting it. `addHandler` will be called whenever Observable\n * returned by the operator is subscribed, so registering handler in API will not\n * necessarily happen when `fromEventPattern` is called.\n *\n * After registration, every time an event that we listen to happens,\n * Observable returned by `fromEventPattern` will emit value that event handler\n * function was called with. Note that if event handler was called with more\n * than one argument, second and following arguments will not appear in the Observable.\n *\n * If API you are using allows to unregister event handlers as well, you can pass to `fromEventPattern`\n * another function - `removeHandler` - as a second parameter. It will be injected\n * with the same handler function as before, which now you can use to unregister\n * it from the API. `removeHandler` will be called when consumer of resulting Observable\n * unsubscribes from it.\n *\n * In some APIs unregistering is actually handled differently. Method registering an event handler\n * returns some kind of token, which is later used to identify which function should\n * be unregistered or it itself has method that unregisters event handler.\n * If that is the case with your API, make sure token returned\n * by registering method is returned by `addHandler`. Then it will be passed\n * as a second argument to `removeHandler`, where you will be able to use it.\n *\n * If you need access to all event handler parameters (not only the first one),\n * or you need to transform them in any way, you can call `fromEventPattern` with optional\n * third parameter - project function which will accept all arguments passed to\n * event handler when it is called. Whatever is returned from project function will appear on\n * resulting stream instead of usual event handlers first argument. This means\n * that default project can be thought of as function that takes its first parameter\n * and ignores the rest.\n *\n * ## Examples\n *\n * Emits clicks happening on the DOM document\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * function addClickHandler(handler) {\n *   document.addEventListener('click', handler);\n * }\n *\n * function removeClickHandler(handler) {\n *   document.removeEventListener('click', handler);\n * }\n *\n * const clicks = fromEventPattern(\n *   addClickHandler,\n *   removeClickHandler\n * );\n * clicks.subscribe(x => console.log(x));\n *\n * // Whenever you click anywhere in the browser, DOM MouseEvent\n * // object will be logged.\n * ```\n *\n * Use with API that returns cancellation token\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * const token = someAPI.registerEventHandler(function() {});\n * someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n *                                        // not handler itself, but special token.\n *\n * const someAPIObservable = fromEventPattern(\n *   function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n *   function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n * );\n * ```\n *\n * Use with project function\n *\n * ```ts\n * import { fromEventPattern } from 'rxjs';\n *\n * someAPI.registerEventHandler((eventType, eventMessage) => {\n *   console.log(eventType, eventMessage); // Logs 'EVENT_TYPE' 'EVENT_MESSAGE' to console.\n * });\n *\n * const someAPIObservable = fromEventPattern(\n *   handler => someAPI.registerEventHandler(handler),\n *   handler => someAPI.unregisterEventHandler(handler)\n *   (eventType, eventMessage) => eventType + ' --- ' + eventMessage // without that function only 'EVENT_TYPE'\n * );                                                                // would be emitted by the Observable\n *\n * someAPIObservable.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'EVENT_TYPE --- EVENT_MESSAGE'\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n *\n * @param addHandler A function that takes a `handler` function as argument and attaches it\n * somehow to the actual source of events.\n * @param removeHandler A function that takes a `handler` function as an argument and removes\n * it from the event source. If `addHandler` returns some kind of token, `removeHandler` function\n * will have it as a second parameter.\n * @param resultSelector A function to transform results. It takes the arguments from the event\n * handler and should return a single value.\n * @return Observable which, when an event happens, emits first parameter passed to registered\n * event handler. Alternatively it emits whatever project function returns at that moment.\n */\nexport function fromEventPattern<T>(\n  addHandler: (handler: NodeEventHandler) => any,\n  removeHandler?: (handler: NodeEventHandler, signal?: any) => void,\n  resultSelector?: (...args: any[]) => T\n): Observable<T | T[]> {\n  if (resultSelector) {\n    return fromEventPattern<T>(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  return new Observable<T | T[]>((subscriber) => {\n    const handler = (...e: T[]) => subscriber.next(e.length === 1 ? e[0] : e);\n    const retValue = addHandler(handler);\n    return isFunction(removeHandler) ? () => removeHandler(handler, retValue) : undefined;\n  });\n}\n", "import { Observable } from '../Observable';\nimport { identity } from '../util/identity';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\n\ntype ConditionFunc<S> = (state: S) => boolean;\ntype IterateFunc<S> = (state: S) => S;\ntype ResultFunc<S, T> = (state: S) => T;\n\nexport interface GenerateBaseOptions<S> {\n  /**\n   * Initial state.\n   */\n  initialState: S;\n  /**\n   * Condition function that accepts state and returns boolean.\n   * When it returns false, the generator stops.\n   * If not specified, a generator never stops.\n   */\n  condition?: ConditionFunc<S>;\n  /**\n   * Iterate function that accepts state and returns new state.\n   */\n  iterate: IterateFunc<S>;\n  /**\n   * SchedulerLike to use for generation process.\n   * By default, a generator starts immediately.\n   */\n  scheduler?: SchedulerLike;\n}\n\nexport interface GenerateOptions<T, S> extends GenerateBaseOptions<S> {\n  /**\n   * Result selection function that accepts state and returns a value to emit.\n   */\n  resultSelector: ResultFunc<S, T>;\n}\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Produces sequence of numbers\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Use `asapScheduler`\n *\n * ```ts\n * import { generate, asapScheduler } from 'rxjs';\n *\n * const result = generate(1, x => x < 5, x => x * 2, x => x + 1, asapScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 2\n * // 3\n * // 5\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param initialState Initial state.\n * @param condition Condition to terminate generation (upon returning false).\n * @param iterate Iteration step function.\n * @param resultSelector Selector function for results produced in the sequence.\n * @param scheduler A {@link SchedulerLike} on which to run the generator loop.\n * If not provided, defaults to emit immediately.\n * @returns The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument.\n * Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<T, S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  resultSelector: ResultFunc<S, T>,\n  scheduler?: SchedulerLike\n): Observable<T>;\n\n/**\n * Generates an Observable by running a state-driven loop\n * that emits an element on each iteration.\n *\n * <span class=\"informal\">Use it instead of nexting values in a for loop.</span>\n *\n * ![](generate.png)\n *\n * `generate` allows you to create a stream of values generated with a loop very similar to\n * a traditional for loop. The first argument of `generate` is a beginning value. The second argument\n * is a function that accepts this value and tests if some condition still holds. If it does,\n * then the loop continues, if not, it stops. The third value is a function which takes the\n * previously defined value and modifies it in some way on each iteration. Note how these three parameters\n * are direct equivalents of three expressions in a traditional for loop: the first expression\n * initializes some state (for example, a numeric index), the second tests if the loop can perform the next\n * iteration (for example, if the index is lower than 10) and the third states how the defined value\n * will be modified on every step (for example, the index will be incremented by one).\n *\n * Return value of a `generate` operator is an Observable that on each loop iteration\n * emits a value. First of all, the condition function is ran. If it returns true, then the Observable\n * emits the currently stored value (initial value at the first iteration) and finally updates\n * that value with iterate function. If at some point the condition returns false, then the Observable\n * completes at that moment.\n *\n * Optionally you can pass a fourth parameter to `generate` - a result selector function which allows you\n * to immediately map the value that would normally be emitted by an Observable.\n *\n * If you find three anonymous functions in `generate` call hard to read, you can provide\n * a single object to the operator instead where the object has the properties: `initialState`,\n * `condition`, `iterate` and `resultSelector`, which should have respective values that you\n * would normally pass to `generate`. `resultSelector` is still optional, but that form\n * of calling `generate` allows you to omit `condition` as well. If you omit it, that means\n * condition always holds, or in other words the resulting Observable will never complete.\n *\n * Both forms of `generate` can optionally accept a scheduler. In case of a multi-parameter call,\n * scheduler simply comes as a last argument (no matter if there is a `resultSelector`\n * function or not). In case of a single-parameter call, you can provide it as a\n * `scheduler` property on the object passed to the operator. In both cases, a scheduler decides when\n * the next iteration of the loop will happen and therefore when the next value will be emitted\n * by the Observable. For example, to ensure that each value is pushed to the Observer\n * on a separate task in the event loop, you could use the `async` scheduler. Note that\n * by default (when no scheduler is passed) values are simply emitted synchronously.\n *\n *\n * ## Examples\n *\n * Use with condition and iterate functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * Use with condition, iterate and resultSelector functions\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate(0, x => x < 3, x => x + 1, x => x * 1000);\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use with options object\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition(value) { return value < 3; },\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 'Complete!'\n * ```\n *\n * Use options object without condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   iterate(value) { return value + 1; },\n *   resultSelector(value) { return value * 1000; }\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!') // This will never run\n * });\n *\n * // Logs:\n * // 0\n * // 1000\n * // 2000\n * // 3000\n * // ...and never stops.\n * ```\n *\n * @see {@link from}\n *\n * @param initialState Initial state.\n * @param condition Condition to terminate generation (upon returning false).\n * @param iterate Iteration step function.\n * @param scheduler A {@link Scheduler} on which to run the generator loop. If not\n * provided, defaults to emitting immediately.\n * @return The generated sequence.\n * @deprecated Instead of passing separate arguments, use the options argument.\n * Signatures taking separate arguments will be removed in v8.\n */\nexport function generate<S>(\n  initialState: S,\n  condition: ConditionFunc<S>,\n  iterate: IterateFunc<S>,\n  scheduler?: SchedulerLike\n): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param options Object that must contain initialState, iterate and might contain condition and scheduler.\n * @returns The generated sequence.\n */\nexport function generate<S>(options: GenerateBaseOptions<S>): Observable<S>;\n\n/**\n * Generates an observable sequence by running a state-driven loop\n * producing the sequence's elements, using the specified scheduler\n * to send out observer messages.\n * The overload accepts options object that might contain initial state, iterate,\n * condition, result selector and scheduler.\n *\n * ![](generate.png)\n *\n * ## Examples\n *\n * Use options object with condition and iterate function\n *\n * ```ts\n * import { generate } from 'rxjs';\n *\n * const result = generate({\n *   initialState: 0,\n *   condition: x => x < 3,\n *   iterate: x => x + 1,\n *   resultSelector: x => x\n * });\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 'Complete!'\n * ```\n *\n * @see {@link from}\n * @see {@link Observable}\n *\n * @param options Object that must contain initialState, iterate, resultSelector and might contain condition and scheduler.\n * @returns The generated sequence.\n */\nexport function generate<T, S>(options: GenerateOptions<T, S>): Observable<T>;\n\nexport function generate<T, S>(\n  initialStateOrOptions: S | GenerateOptions<T, S>,\n  condition?: ConditionFunc<S>,\n  iterate?: IterateFunc<S>,\n  resultSelectorOrScheduler?: ResultFunc<S, T> | SchedulerLike,\n  scheduler?: SchedulerLike\n): Observable<T> {\n  let resultSelector: ResultFunc<S, T>;\n  let initialState: S;\n\n  // TODO: Remove this as we move away from deprecated signatures\n  // and move towards a configuration object argument.\n  if (arguments.length === 1) {\n    // If we only have one argument, we can assume it is a configuration object.\n    // Note that folks not using TypeScript may trip over this.\n    ({\n      initialState,\n      condition,\n      iterate,\n      resultSelector = identity as ResultFunc<S, T>,\n      scheduler,\n    } = initialStateOrOptions as GenerateOptions<T, S>);\n  } else {\n    // Deprecated arguments path. Figure out what the user\n    // passed and set it here.\n    initialState = initialStateOrOptions as S;\n    if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n      resultSelector = identity as ResultFunc<S, T>;\n      scheduler = resultSelectorOrScheduler as SchedulerLike;\n    } else {\n      resultSelector = resultSelectorOrScheduler as ResultFunc<S, T>;\n    }\n  }\n\n  // The actual generator used to \"generate\" values.\n  function* gen() {\n    for (let state = initialState; !condition || condition(state); state = iterate!(state)) {\n      yield resultSelector(state);\n    }\n  }\n\n  // We use `defer` because we want to defer the creation of the iterator from the iterable.\n  return defer(\n    (scheduler\n      ? // If a scheduler was provided, use `scheduleIterable` to ensure that iteration/generation\n        // happens on the scheduler.\n        () => scheduleIterable(gen(), scheduler!)\n      : // Otherwise, if there's no scheduler, we can just use the generator function directly in\n        // `defer` and executing it will return the generator (which is iterable).\n        gen) as () => ObservableInput<T>\n  );\n}\n", "import { Observable } from '../Observable';\nimport { defer } from './defer';\nimport { ObservableInput } from '../types';\n\n/**\n * Checks a boolean at subscription time, and chooses between one of two observable sources\n *\n * `iif` expects a function that returns a boolean (the `condition` function), and two sources,\n * the `trueResult` and the `falseResult`, and returns an Observable.\n *\n * At the moment of subscription, the `condition` function is called. If the result is `true`, the\n * subscription will be to the source passed as the `trueResult`, otherwise, the subscription will be\n * to the source passed as the `falseResult`.\n *\n * If you need to check more than two options to choose between more than one observable, have a look at the {@link defer} creation method.\n *\n * ## Examples\n *\n * Change at runtime which Observable will be subscribed\n *\n * ```ts\n * import { iif, of } from 'rxjs';\n *\n * let subscribeToFirst;\n * const firstOrSecond = iif(\n *   () => subscribeToFirst,\n *   of('first'),\n *   of('second')\n * );\n *\n * subscribeToFirst = true;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'first'\n *\n * subscribeToFirst = false;\n * firstOrSecond.subscribe(value => console.log(value));\n *\n * // Logs:\n * // 'second'\n * ```\n *\n * Control access to an Observable\n *\n * ```ts\n * import { iif, of, EMPTY } from 'rxjs';\n *\n * let accessGranted;\n * const observableIfYouHaveAccess = iif(\n *   () => accessGranted,\n *   of('It seems you have an access...'),\n *   EMPTY\n * );\n *\n * accessGranted = true;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'It seems you have an access...'\n * // 'The end'\n *\n * accessGranted = false;\n * observableIfYouHaveAccess.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('The end')\n * });\n *\n * // Logs:\n * // 'The end'\n * ```\n *\n * @see {@link defer}\n *\n * @param condition Condition which Observable should be chosen.\n * @param trueResult An Observable that will be subscribed if condition is true.\n * @param falseResult An Observable that will be subscribed if condition is false.\n * @return An observable that proxies to `trueResult` or `falseResult`, depending on the result of the `condition` function.\n */\nexport function iif<T, F>(condition: () => boolean, trueResult: ObservableInput<T>, falseResult: ObservableInput<F>): Observable<T | F> {\n  return defer(() => (condition() ? trueResult : falseResult));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike } from '../types';\nimport { timer } from './timer';\n\n/**\n * Creates an Observable that emits sequential numbers every specified\n * interval of time, on a specified {@link SchedulerLike}.\n *\n * <span class=\"informal\">Emits incremental numbers periodically in time.</span>\n *\n * ![](interval.png)\n *\n * `interval` returns an Observable that emits an infinite sequence of\n * ascending integers, with a constant interval of time of your choosing\n * between those emissions. The first emission is not sent immediately, but\n * only after the first period has passed. By default, this operator uses the\n * `async` {@link SchedulerLike} to provide a notion of time, but you may pass any\n * {@link SchedulerLike} to it.\n *\n * ## Example\n *\n * Emits ascending numbers, one every second (1000ms) up to the number 3\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const numbers = interval(1000);\n *\n * const takeFourNumbers = numbers.pipe(take(4));\n *\n * takeFourNumbers.subscribe(x => console.log('Next: ', x));\n *\n * // Logs:\n * // Next: 0\n * // Next: 1\n * // Next: 2\n * // Next: 3\n * ```\n *\n * @see {@link timer}\n * @see {@link delay}\n *\n * @param period The interval size in milliseconds (by default) or the time unit determined\n * by the scheduler's clock.\n * @param scheduler The {@link SchedulerLike} to use for scheduling the emission of values,\n * and providing a notion of \"time\".\n * @return An Observable that emits a sequential number each time interval.\n */\nexport function interval(period = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number> {\n  if (period < 0) {\n    // We cannot schedule an interval in the past.\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param args `ObservableInput`s to merge together. If the last parameter\n * is of type number, `merge` will use it to limit number of concurrently\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\n * it will be used for scheduling the emission of values.\n * @return An Observable that emits items that are the result of every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { OperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from './innerFrom';\n\nexport function onErrorResumeNext<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function onErrorResumeNext<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\n\n/**\n * When any of the provided Observable emits a complete or an error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` will subscribe to each observable source it is provided, in order.\n * If the source it's subscribed to emits an error or completes, it will move to the next source\n * without error.\n *\n * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.\n *\n * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its\n * sources emits an error.\n *\n * Note that there is no way to handle any errors thrown by sources via the result of\n * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can\n * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { onErrorResumeNext, of, map } from 'rxjs';\n *\n * onErrorResumeNext(\n *   of(1, 2, 3, 0).pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *       return 10 / x;\n *     })\n *   ),\n *   of(1, 2, 3)\n * )\n * .subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(err),     // Will never be called.\n *   complete: () => console.log('done')\n * });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'done'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param sources `ObservableInput`s passed either directly or as an array.\n * @return An Observable that concatenates all sources, one after the other,\n * ignoring all errors, such that any error causes it to move on to the next source.\n */\nexport function onErrorResumeNext<A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): Observable<A[number]> {\n  const nextSources: ObservableInputTuple<A> = argsOrArgArray(sources) as any;\n\n  return new Observable((subscriber) => {\n    let sourceIndex = 0;\n    const subscribeNext = () => {\n      if (sourceIndex < nextSources.length) {\n        let nextSource: Observable<A[number]>;\n        try {\n          nextSource = innerFrom(nextSources[sourceIndex++]);\n        } catch (err) {\n          subscribeNext();\n          return;\n        }\n        const innerSubscriber = new OperatorSubscriber(subscriber, undefined, noop, noop);\n        nextSource.subscribe(innerSubscriber);\n        innerSubscriber.add(subscribeNext);\n      } else {\n        subscriber.complete();\n      }\n    };\n    subscribeNext();\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { from } from './from';\n\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(arr: readonly T[], scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<O extends Record<string, unknown>>(obj: O, scheduler?: SchedulerLike): Observable<[keyof O, O[keyof O]]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs<T>(iterable: Iterable<T>, scheduler?: SchedulerLike): Observable<[string, T]>;\n/**\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(\n  n: number | bigint | boolean | ((...args: any[]) => any) | symbol,\n  scheduler?: SchedulerLike\n): Observable<[never, never]>;\n\n/**\n * Convert an object into an Observable of `[key, value]` pairs.\n *\n * <span class=\"informal\">Turn entries of an object into a stream.</span>\n *\n * ![](pairs.png)\n *\n * `pairs` takes an arbitrary object and returns an Observable that emits arrays. Each\n * emitted array has exactly two elements - the first is a key from the object\n * and the second is a value corresponding to that key. Keys are extracted from\n * an object via `Object.keys` function, which means that they will be only\n * enumerable keys that are present on an object directly - not ones inherited\n * via prototype chain.\n *\n * By default, these arrays are emitted synchronously. To change that you can\n * pass a {@link SchedulerLike} as a second argument to `pairs`.\n *\n * ## Example\n *\n * Converts an object to an Observable\n *\n * ```ts\n * import { pairs } from 'rxjs';\n *\n * const obj = {\n *   foo: 42,\n *   bar: 56,\n *   baz: 78\n * };\n *\n * pairs(obj).subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // ['foo', 42]\n * // ['bar', 56]\n * // ['baz', 78]\n * // 'Complete!'\n * ```\n *\n * ### Object.entries required\n *\n * In IE, you will need to polyfill `Object.entries` in order to use this.\n * [MDN has a polyfill here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)\n *\n * @param obj The object to inspect and turn into an Observable sequence.\n * @param scheduler An optional IScheduler to schedule when resulting\n * Observable will emit values.\n * @returns An observable sequence of [key, value] pairs from the object.\n * @deprecated Use `from(Object.entries(obj))` instead. Will be removed in v8.\n */\nexport function pairs(obj: any, scheduler?: SchedulerLike) {\n  return from(Object.entries(obj), scheduler as any);\n}\n", "export function not<T>(pred: (value: T, index: number) => boolean, thisArg: any): (value: T, index: number) => boolean {\n  return (value: T, index: number) => !pred.call(thisArg, value, index); \n}", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n", "import { not } from '../util/not';\nimport { filter } from '../operators/filter';\nimport { ObservableInput } from '../types';\nimport { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, U extends T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => value is U,\n  thisArg: A\n): [Observable<U>, Observable<Exclude<T, U>>];\nexport function partition<T, U extends T>(\n  source: ObservableInput<T>,\n  predicate: (value: T, index: number) => value is U\n): [Observable<U>, Observable<Exclude<T, U>>];\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function partition<T, A>(\n  source: ObservableInput<T>,\n  predicate: (this: A, value: T, index: number) => boolean,\n  thisArg: A\n): [Observable<T>, Observable<T>];\nexport function partition<T>(source: ObservableInput<T>, predicate: (value: T, index: number) => boolean): [Observable<T>, Observable<T>];\n\n/**\n * Splits the source Observable into two, one with values that satisfy a\n * predicate, and another with values that don't satisfy the predicate.\n *\n * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n * one like the output of {@link filter}, and the other with values that did not\n * pass the condition.</span>\n *\n * ![](partition.png)\n *\n * `partition` outputs an array with two Observables that partition the values\n * from the source Observable through the given `predicate` function. The first\n * Observable in that array emits source values for which the predicate argument\n * returns true. The second Observable emits source values for which the\n * predicate returns false. The first behaves like {@link filter} and the second\n * behaves like {@link filter} with the predicate negated.\n *\n * ## Example\n *\n * Partition a set of numbers into odds and evens observables\n *\n * ```ts\n * import { of, partition } from 'rxjs';\n *\n * const observableValues = of(1, 2, 3, 4, 5, 6);\n * const [evens$, odds$] = partition(observableValues, value => value % 2 === 0);\n *\n * odds$.subscribe(x => console.log('odds', x));\n * evens$.subscribe(x => console.log('evens', x));\n *\n * // Logs:\n * // odds 1\n * // odds 3\n * // odds 5\n * // evens 2\n * // evens 4\n * // evens 6\n * ```\n *\n * @see {@link filter}\n *\n * @param source The source `ObservableInput` that will be split into a tuple of\n * two Observable elements.\n * @param predicate A function that evaluates each value emitted by the source\n * Observable. If it returns `true`, the value is emitted on the first Observable\n * in the returned array, if `false` the value is emitted on the second Observable\n * in the array. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return An array with two Observables: one with values that passed the\n * predicate, and another with values that did not pass the predicate.\n */\nexport function partition<T>(\n  source: ObservableInput<T>,\n  predicate: (this: any, value: T, index: number) => boolean,\n  thisArg?: any\n): [Observable<T>, Observable<T>] {\n  return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))] as [\n    Observable<T>,\n    Observable<T>\n  ];\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param sources Used to race for which `ObservableInput` emits first.\n * @return An Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { EMPTY } from './empty';\n\nexport function range(start: number, count?: number): Observable<number>;\n\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. Use `range(start, count).pipe(observeOn(scheduler))` instead. Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function range(start: number, count: number | undefined, scheduler: SchedulerLike): Observable<number>;\n\n/**\n * Creates an Observable that emits a sequence of numbers within a specified\n * range.\n *\n * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n *\n * ![](range.png)\n *\n * `range` operator emits a range of sequential integers, in order, where you\n * select the `start` of the range and its `length`. By default, uses no\n * {@link SchedulerLike} and just delivers the notifications synchronously, but may use\n * an optional {@link SchedulerLike} to regulate those deliveries.\n *\n * ## Example\n *\n * Produce a range of numbers\n *\n * ```ts\n * import { range } from 'rxjs';\n *\n * const numbers = range(1, 3);\n *\n * numbers.subscribe({\n *   next: value => console.log(value),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Logs:\n * // 1\n * // 2\n * // 3\n * // 'Complete!'\n * ```\n *\n * @see {@link timer}\n * @see {@link interval}\n *\n * @param start The value of the first integer in the sequence.\n * @param count The number of sequential integers to generate.\n * @param scheduler A {@link SchedulerLike} to use for scheduling the emissions\n * of the notifications.\n * @return An Observable of numbers that emits a finite range of sequential integers.\n */\nexport function range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number> {\n  if (count == null) {\n    // If one argument was passed, it's the count, not the start.\n    count = start;\n    start = 0;\n  }\n\n  if (count <= 0) {\n    // No count? We're going nowhere. Return EMPTY.\n    return EMPTY;\n  }\n\n  // Where the range should stop.\n  const end = count + start;\n\n  return new Observable(\n    scheduler\n      ? // The deprecated scheduled path.\n        (subscriber) => {\n          let n = start;\n          return scheduler.schedule(function () {\n            if (n < end) {\n              subscriber.next(n++);\n              this.schedule();\n            } else {\n              subscriber.complete();\n            }\n          });\n        }\n      : // Standard synchronous range.\n        (subscriber) => {\n          let n = start;\n          while (n < end && !subscriber.closed) {\n            subscriber.next(n++);\n          }\n          subscriber.complete();\n        }\n  );\n}\n", "import { Observable } from '../Observable';\nimport { Unsubscribable, ObservableInput, ObservedValueOf } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\n\n/**\n * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.\n *\n * <span class=\"informal\">Use it when you catch yourself cleaning up after an Observable.</span>\n *\n * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.\n * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with\n * that object and should return an Observable. That Observable can use resource object during its execution.\n * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor\n * resource object will be shared in any way between subscriptions.\n *\n * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed\n * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output\n * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,\n * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which\n * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone\n * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make\n * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.\n *\n * @see {@link defer}\n *\n * @param resourceFactory A function which creates any resource object that implements `unsubscribe` method.\n * @param observableFactory A function which creates an Observable, that can use injected resource object.\n * @return An Observable that behaves the same as Observable returned by `observableFactory`, but\n * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.\n */\nexport function using<T extends ObservableInput<any>>(\n  resourceFactory: () => Unsubscribable | void,\n  observableFactory: (resource: Unsubscribable | void) => T | void\n): Observable<ObservedValueOf<T>> {\n  return new Observable<ObservedValueOf<T>>((subscriber) => {\n    const resource = resourceFactory();\n    const result = observableFactory(resource);\n    const source = result ? innerFrom(result) : EMPTY;\n    source.subscribe(subscriber);\n    return () => {\n      // NOTE: Optional chaining did not work here.\n      // Related TS Issue: https://github.com/microsoft/TypeScript/issues/40818\n      if (resource) {\n        resource.unsubscribe();\n      }\n    };\n  });\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInputTuple } from '../types';\nimport { innerFrom } from './innerFrom';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { EMPTY } from './empty';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { popResultSelector } from '../util/args';\n\nexport function zip<A extends readonly unknown[]>(sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  resultSelector: (...values: A) => R\n): Observable<R>;\nexport function zip<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A>;\nexport function zip<A extends readonly unknown[], R>(\n  ...sourcesAndResultSelector: [...ObservableInputTuple<A>, (...values: A) => R]\n): Observable<R>;\n\n/**\n * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n * of its input Observables.\n *\n * If the last parameter is a function, this function is used to compute the created value from the input values.\n * Otherwise, an array of the input values is returned.\n *\n * ## Example\n *\n * Combine age and name from different sources\n *\n * ```ts\n * import { of, zip, map } from 'rxjs';\n *\n * const age$ = of(27, 25, 29);\n * const name$ = of('Foo', 'Bar', 'Beer');\n * const isDev$ = of(true, true, false);\n *\n * zip(age$, name$, isDev$).pipe(\n *   map(([age, name, isDev]) => ({ age, name, isDev }))\n * )\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 27, name: 'Foo', isDev: true }\n * // { age: 25, name: 'Bar', isDev: true }\n * // { age: 29, name: 'Beer', isDev: false }\n * ```\n *\n * @param args Any number of `ObservableInput`s provided either as an array or as an object\n * to combine with each other.\n * @return An Observable of array values of the values emitted at the same index from each\n * individual `ObservableInput`.\n */\nexport function zip(...args: unknown[]): Observable<unknown> {\n  const resultSelector = popResultSelector(args);\n\n  const sources = argsOrArgArray(args) as Observable<unknown>[];\n\n  return sources.length\n    ? new Observable<unknown[]>((subscriber) => {\n        // A collection of buffers of values from each source.\n        // Keyed by the same index with which the sources were passed in.\n        let buffers: unknown[][] = sources.map(() => []);\n\n        // An array of flags of whether or not the sources have completed.\n        // This is used to check to see if we should complete the result.\n        // Keyed by the same index with which the sources were passed in.\n        let completed = sources.map(() => false);\n\n        // When everything is done, release the arrays above.\n        subscriber.add(() => {\n          buffers = completed = null!;\n        });\n\n        // Loop over our sources and subscribe to each one. The index `i` is\n        // especially important here, because we use it in closures below to\n        // access the related buffers and completion properties\n        for (let sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {\n          innerFrom(sources[sourceIndex]).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                buffers[sourceIndex].push(value);\n                // if every buffer has at least one value in it, then we\n                // can shift out the oldest value from each buffer and emit\n                // them as an array.\n                if (buffers.every((buffer) => buffer.length)) {\n                  const result: any = buffers.map((buffer) => buffer.shift()!);\n                  // Emit the array. If theres' a result selector, use that.\n                  subscriber.next(resultSelector ? resultSelector(...result) : result);\n                  // If any one of the sources is both complete and has an empty buffer\n                  // then we complete the result. This is because we cannot possibly have\n                  // any more values to zip together.\n                  if (buffers.some((buffer, i) => !buffer.length && completed[i])) {\n                    subscriber.complete();\n                  }\n                }\n              },\n              () => {\n                // This source completed. Mark it as complete so we can check it later\n                // if we have to.\n                completed[sourceIndex] = true;\n                // But, if this complete source has nothing in its buffer, then we\n                // can complete the result, because we can't possibly have any more\n                // values from this to zip together with the other values.\n                !buffers[sourceIndex].length && subscriber.complete();\n              }\n            )\n          );\n        }\n\n        // When everything is done, release the arrays above.\n        return () => {\n          buffers = completed = null!;\n        };\n      })\n    : EMPTY;\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map", "import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\n\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Ignores source values for a duration determined by another Observable, then\n * emits the most recent value from the source Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](audit.svg)\n *\n * `audit` is similar to `throttle`, but emits the last value from the silenced\n * time window, instead of the first value. `audit` emits the most recent value\n * from the source Observable on the output Observable as soon as its internal\n * timer becomes disabled, and ignores source values while the timer is enabled.\n * Initially, the timer is disabled. As soon as the first source value arrives,\n * the timer is enabled by calling the `durationSelector` function with the\n * source value, which returns the \"duration\" Observable. When the duration\n * Observable emits a value, the timer is disabled, then the most\n * recent source value is emitted on the output Observable, and this process\n * repeats for the next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, audit, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(audit(ev => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttle}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the silencing\n * duration, returned as an Observable or a Promise.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    let durationSubscriber: Subscriber<any> | null = null;\n    let isComplete = false;\n\n    const endDuration = () => {\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n      isComplete && subscriber.complete();\n    };\n\n    const cleanupDuration = () => {\n      durationSubscriber = null;\n      isComplete && subscriber.complete();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          lastValue = value;\n          if (!durationSubscriber) {\n            innerFrom(durationSelector(value)).subscribe(\n              (durationSubscriber = createOperatorSubscriber(subscriber, endDuration, cleanupDuration))\n            );\n          }\n        },\n        () => {\n          isComplete = true;\n          (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { audit } from './audit';\nimport { timer } from '../observable/timer';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\n\n/**\n * Ignores source values for `duration` milliseconds, then emits the most recent\n * value from the source Observable, then repeats this process.\n *\n * <span class=\"informal\">When it sees a source value, it ignores that plus\n * the next ones for `duration` milliseconds, and then it emits the most recent\n * value from the source.</span>\n *\n * ![](auditTime.png)\n *\n * `auditTime` is similar to `throttleTime`, but emits the last value from the\n * silenced time window, instead of the first value. `auditTime` emits the most\n * recent value from the source Observable on the output Observable as soon as\n * its internal timer becomes disabled, and ignores source values while the\n * timer is enabled. Initially, the timer is disabled. As soon as the first\n * source value arrives, the timer is enabled. After `duration` milliseconds (or\n * the time unit determined internally by the optional `scheduler`) has passed,\n * the timer is disabled, then the most recent source value is emitted on the\n * output Observable, and this process repeats for the next source value.\n * Optionally takes a {@link SchedulerLike} for managing timers.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, auditTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(auditTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param duration Time to wait before emitting the most recent source value,\n * measured in milliseconds or the time unit determined internally by the\n * optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the rate-limiting behavior.\n * @return A function that returns an Observable that performs rate-limiting of\n * emissions from the source Observable.\n */\nexport function auditTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return audit(() => timer(duration, scheduler));\n}\n", "import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values until `closingNotifier` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when another Observable emits.</span>\n *\n * ![](buffer.png)\n *\n * Buffers the incoming Observable values until the given `closingNotifier`\n * `ObservableInput` (that internally gets converted to an Observable)\n * emits a value, at which point it emits the buffer on the output\n * Observable and starts a new buffer internally, awaiting the next time\n * `closingNotifier` emits.\n *\n * ## Example\n *\n * On every click, emit array of most recent interval events\n *\n * ```ts\n * import { fromEvent, interval, buffer } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const intervalEvents = interval(1000);\n * const buffered = intervalEvents.pipe(buffer(clicks));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link window}\n *\n * @param closingNotifier An `ObservableInput` that signals the\n * buffer to be emitted on the output Observable.\n * @return A function that returns an Observable of buffers, which are arrays\n * of values.\n */\nexport function buffer<T>(closingNotifier: ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The current buffered values.\n    let currentBuffer: T[] = [];\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => currentBuffer.push(value),\n        () => {\n          subscriber.next(currentBuffer);\n          subscriber.complete();\n        }\n      )\n    );\n\n    // Subscribe to the closing notifier.\n    innerFrom(closingNotifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          // Start a new buffer and emit the previous one.\n          const b = currentBuffer;\n          currentBuffer = [];\n          subscriber.next(b);\n        },\n        noop\n      )\n    );\n\n    return () => {\n      // Ensure buffered values are released on finalization.\n      currentBuffer = null!;\n    };\n  });\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values until the size hits the maximum\n * `bufferSize` given.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * that array only when its size reaches `bufferSize`.</span>\n *\n * ![](bufferCount.png)\n *\n * Buffers a number of values from the source Observable by `bufferSize` then\n * emits the buffer and clears it, and starts a new buffer each\n * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n * `null`, then new buffers are started immediately at the start of the source\n * and when each buffer closes and is emitted.\n *\n * ## Examples\n *\n * Emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * On every click, emit the last two click events as an array\n *\n * ```ts\n * import { fromEvent, bufferCount } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferCount(2, 1));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link pairwise}\n * @see {@link windowCount}\n *\n * @param bufferSize The maximum size of the buffer emitted.\n * @param startBufferEvery Interval at which to start a new buffer.\n * For example if `startBufferEvery` is `2`, then a new buffer will be started\n * on every other value from the source. A new buffer is started at the\n * beginning of the source by default.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferCount<T>(bufferSize: number, startBufferEvery: number | null = null): OperatorFunction<T, T[]> {\n  // If no `startBufferEvery` value was supplied, then we're\n  // opening and closing on the bufferSize itself.\n  startBufferEvery = startBufferEvery ?? bufferSize;\n\n  return operate((source, subscriber) => {\n    let buffers: T[][] = [];\n    let count = 0;\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          let toEmit: T[][] | null = null;\n\n          // Check to see if we need to start a buffer.\n          // This will start one at the first value, and then\n          // a new one every N after that.\n          if (count++ % startBufferEvery! === 0) {\n            buffers.push([]);\n          }\n\n          // Push our value into our active buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n            // Check to see if we're over the bufferSize\n            // if we are, record it so we can emit it later.\n            // If we emitted it now and removed it, it would\n            // mutate the `buffers` array while we're looping\n            // over it.\n            if (bufferSize <= buffer.length) {\n              toEmit = toEmit ?? [];\n              toEmit.push(buffer);\n            }\n          }\n\n          if (toEmit) {\n            // We have found some buffers that are over the\n            // `bufferSize`. Emit them, and remove them from our\n            // buffers list.\n            for (const buffer of toEmit) {\n              arrRemove(buffers, buffer);\n              subscriber.next(buffer);\n            }\n          }\n        },\n        () => {\n          // When the source completes, emit all of our\n          // active buffers.\n          for (const buffer of buffers) {\n            subscriber.next(buffer);\n          }\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Clean up our memory when we finalize\n          buffers = null!;\n        }\n      )\n    );\n  });\n}\n", "import { Subscription } from '../Subscription';\nimport { OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { asyncScheduler } from '../scheduler/async';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function bufferTime<T>(bufferTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\nexport function bufferTime<T>(\n  bufferTimeSpan: number,\n  bufferCreationInterval: number | null | undefined,\n  maxBufferSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T[]>;\n\n/**\n * Buffers the source Observable values for a specific time period.\n *\n * <span class=\"informal\">Collects values from the past as an array, and emits\n * those arrays periodically in time.</span>\n *\n * ![](bufferTime.png)\n *\n * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n * Unless the optional argument `bufferCreationInterval` is given, it emits and\n * resets the buffer every `bufferTimeSpan` milliseconds. If\n * `bufferCreationInterval` is given, this operator opens the buffer every\n * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n * `maxBufferSize` is specified, the buffer will be closed either after\n * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n *\n * ## Examples\n *\n * Every second, emit an array of the recent click events\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(1000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds, emit the click events from the next 2 seconds\n *\n * ```ts\n * import { fromEvent, bufferTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(bufferTime(2000, 5000));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferToggle}\n * @see {@link bufferWhen}\n * @see {@link windowTime}\n *\n * @param bufferTimeSpan The amount of time to fill each buffer array.\n * @param otherArgs Other configuration arguments such as:\n * - `bufferCreationInterval` - the interval at which to start new buffers;\n * - `maxBufferSize` - the maximum buffer size;\n * - `scheduler` - the scheduler on which to schedule the intervals that determine buffer boundaries.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const bufferCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxBufferSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active buffers, their related subscriptions, and removal functions.\n    let bufferRecords: { buffer: T[]; subs: Subscription }[] | null = [];\n    // If true, it means that every time we emit a buffer, we want to start a new buffer\n    // this is only really used for when *just* the buffer time span is passed.\n    let restartOnEmit = false;\n\n    /**\n     * Does the work of emitting the buffer from the record, ensuring that the\n     * record is removed before the emission so reentrant code (from some custom scheduling, perhaps)\n     * does not alter the buffer. Also checks to see if a new buffer needs to be started\n     * after the emit.\n     */\n    const emit = (record: { buffer: T[]; subs: Subscription }) => {\n      const { buffer, subs } = record;\n      subs.unsubscribe();\n      arrRemove(bufferRecords, record);\n      subscriber.next(buffer);\n      restartOnEmit && startBuffer();\n    };\n\n    /**\n     * Called every time we start a new buffer. This does\n     * the work of scheduling a job at the requested bufferTimeSpan\n     * that will emit the buffer (if it's not unsubscribed before then).\n     */\n    const startBuffer = () => {\n      if (bufferRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const buffer: T[] = [];\n        const record = {\n          buffer,\n          subs,\n        };\n        bufferRecords.push(record);\n        executeSchedule(subs, scheduler, () => emit(record), bufferTimeSpan);\n      }\n    };\n\n    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {\n      // The user passed both a bufferTimeSpan (required), and a creation interval\n      // That means we need to start new buffers on the interval, and those buffers need\n      // to wait the required time span before emitting.\n      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);\n    } else {\n      restartOnEmit = true;\n    }\n\n    startBuffer();\n\n    const bufferTimeSubscriber = createOperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Copy the records, so if we need to remove one we\n        // don't mutate the array. It's hard, but not impossible to\n        // set up a buffer time that could mutate the array and\n        // cause issues here.\n        const recordsCopy = bufferRecords!.slice();\n        for (const record of recordsCopy) {\n          // Loop over all buffers and\n          const { buffer } = record;\n          buffer.push(value);\n          // If the buffer is over the max size, we need to emit it.\n          maxBufferSize <= buffer.length && emit(record);\n        }\n      },\n      () => {\n        // The source completed, emit all of the active\n        // buffers we have before we complete.\n        while (bufferRecords?.length) {\n          subscriber.next(bufferRecords.shift()!.buffer);\n        }\n        bufferTimeSubscriber?.unsubscribe();\n        subscriber.complete();\n        subscriber.unsubscribe();\n      },\n      // Pass all errors through to consumer.\n      undefined,\n      // Clean up\n      () => (bufferRecords = null)\n    );\n\n    source.subscribe(bufferTimeSubscriber);\n  });\n}\n", "import { Subscription } from '../Subscription';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * ![](bufferToggle.png)\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, bufferToggle, EMPTY } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const buffered = clicks.pipe(bufferToggle(openings, i =>\n *   i % 2 ? interval(500) : EMPTY\n * ));\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (value: O) => ObservableInput<any>\n): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    const buffers: T[][] = [];\n\n    // Subscribe to the openings notifier first\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const buffer: T[] = [];\n          buffers.push(buffer);\n          // We use this composite subscription, so that\n          // when the closing notifier emits, we can tear it down.\n          const closingSubscription = new Subscription();\n\n          const emitBuffer = () => {\n            arrRemove(buffers, buffer);\n            subscriber.next(buffer);\n            closingSubscription.unsubscribe();\n          };\n\n          // The line below will add the subscription to the parent subscriber *and* the closing subscription.\n          closingSubscription.add(innerFrom(closingSelector(openValue)).subscribe(createOperatorSubscriber(subscriber, emitBuffer, noop)));\n        },\n        noop\n      )\n    );\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Value from our source. Add it to all pending buffers.\n          for (const buffer of buffers) {\n            buffer.push(value);\n          }\n        },\n        () => {\n          // Source complete. Emit all pending buffers.\n          while (buffers.length > 0) {\n            subscriber.next(buffers.shift()!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Buffers the source Observable values, using a factory function of closing\n * Observables to determine when to close, emit, and reset the buffer.\n *\n * <span class=\"informal\">Collects values from the past as an array. When it\n * starts collecting values, it calls a function that returns an Observable that\n * tells when to close the buffer and restart collecting.</span>\n *\n * ![](bufferWhen.svg)\n *\n * Opens a buffer immediately, then closes the buffer when the observable\n * returned by calling `closingSelector` function emits a value. When it closes\n * the buffer, it immediately opens a new buffer and repeats the process.\n *\n * ## Example\n *\n * Emit an array of the last clicks every [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, bufferWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const buffered = clicks.pipe(\n *   bufferWhen(() => interval(1000 + Math.random() * 4000))\n * );\n * buffered.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferToggle}\n * @see {@link windowWhen}\n *\n * @param closingSelector A function that takes no arguments and returns an\n * Observable that signals buffer closure.\n * @return A function that returns an Observable of arrays of buffered values.\n */\nexport function bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]> {\n  return operate((source, subscriber) => {\n    // The buffer we keep and emit.\n    let buffer: T[] | null = null;\n    // A reference to the subscriber used to subscribe to\n    // the closing notifier. We need to hold this so we can\n    // end the subscription after the first notification.\n    let closingSubscriber: Subscriber<T> | null = null;\n\n    // Ends the previous closing notifier subscription, so it\n    // terminates after the first emission, then emits\n    // the current buffer  if there is one, starts a new buffer, and starts a\n    // new closing notifier.\n    const openBuffer = () => {\n      // Make sure to finalize the closing subscription, we only cared\n      // about one notification.\n      closingSubscriber?.unsubscribe();\n      // emit the buffer if we have one, and start a new buffer.\n      const b = buffer;\n      buffer = [];\n      b && subscriber.next(b);\n\n      // Get a new closing notifier and subscribe to it.\n      innerFrom(closingSelector()).subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openBuffer, noop)));\n    };\n\n    // Start the first buffer.\n    openBuffer();\n\n    // Subscribe to our source.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Add every new value to the current buffer.\n        (value) => buffer?.push(value),\n        // When we complete, emit the buffer if we have one,\n        // then complete the result.\n        () => {\n          buffer && subscriber.next(buffer);\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        // Release memory on finalization\n        () => (buffer = closingSubscriber = null!)\n      )\n    );\n  });\n}\n", "import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param selector A function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again.\n * Whatever observable is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A basic scan operation. This is used for `scan` and `reduce`.\n * @param accumulator The accumulator to use\n * @param seed The seed value for the state to accumulate\n * @param hasSeed Whether or not a seed was provided\n * @param emitOnNext Whether or not to emit the state on next\n * @param emitBeforeComplete Whether or not to emit the before completion\n */\n\nexport function scanInternals<V, A, S>(\n  accumulator: (acc: V | A | S, value: V, index: number) => A,\n  seed: S,\n  hasSeed: boolean,\n  emitOnNext: boolean,\n  emitBeforeComplete?: undefined | true\n) {\n  return (source: Observable<V>, subscriber: Subscriber<any>) => {\n    // Whether or not we have state yet. This will only be\n    // false before the first value arrives if we didn't get\n    // a seed value.\n    let hasState = hasSeed;\n    // The state that we're tracking, starting with the seed,\n    // if there is one, and then updated by the return value\n    // from the accumulator on each emission.\n    let state: any = seed;\n    // An index to pass to the accumulator function.\n    let index = 0;\n\n    // Subscribe to our source. All errors and completions are passed through.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Always increment the index.\n          const i = index++;\n          // Set the state\n          state = hasState\n            ? // We already have state, so we can get the new state from the accumulator\n              accumulator(state, value, i)\n            : // We didn't have state yet, a seed value was not provided, so\n\n              // we set the state to the first value, and mark that we have state now\n              ((hasState = true), value);\n\n          // Maybe send it to the consumer.\n          emitOnNext && subscriber.next(state);\n        },\n        // If an onComplete was given, call it, otherwise\n        // just pass through the complete notification to the consumer.\n        emitBeforeComplete &&\n          (() => {\n            hasState && subscriber.next(state);\n            subscriber.complete();\n          })\n      )\n    );\n  };\n}\n", "import { scanInternals } from './scanInternals';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nexport function reduce<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function reduce<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function reduce<V, A, S = A>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n/**\n * Applies an accumulator function over the source Observable, and returns the\n * accumulated result when the source completes, given an optional seed value.\n *\n * <span class=\"informal\">Combines together all values emitted on the source,\n * using an accumulator function that knows how to join a new source value into\n * the accumulation from the past.</span>\n *\n * ![](reduce.png)\n *\n * Like\n * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n * `reduce` applies an `accumulator` function against an accumulation and each\n * value of the source Observable (from the past) to reduce it to a single\n * value, emitted on the output Observable. Note that `reduce` will only emit\n * one value, only when the source Observable completes. It is equivalent to\n * applying operator {@link scan} followed by operator {@link last}.\n *\n * Returns an Observable that applies a specified `accumulator` function to each\n * item emitted by the source Observable. If a `seed` value is specified, then\n * that value will be used as the initial value for the accumulator. If no seed\n * value is specified, the first item of the source is used as the seed.\n *\n * ## Example\n *\n * Count the number of click events that happened in 5 seconds\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, map, reduce } from 'rxjs';\n *\n * const clicksInFiveSeconds = fromEvent(document, 'click')\n *   .pipe(takeUntil(interval(5000)));\n *\n * const ones = clicksInFiveSeconds.pipe(map(() => 1));\n * const seed = 0;\n * const count = ones.pipe(reduce((acc, one) => acc + one, seed));\n *\n * count.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link count}\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link scan}\n *\n * @param accumulator The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an Observable that emits a single value that\n * is the result of accumulating the values emitted by the source Observable.\n */\nexport function reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A> {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));\n}\n", "import { reduce } from './reduce';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\nconst arrReducer = (arr: any[], value: any) => (arr.push(value), arr);\n\n/**\n * Collects all source emissions and emits them as an array when the source completes.\n *\n * <span class=\"informal\">Get all values inside an array when the source completes</span>\n *\n * ![](toArray.png)\n *\n * `toArray` will wait until the source Observable completes before emitting\n * the array containing all emissions. When the source Observable errors no\n * array will be emitted.\n *\n * ## Example\n *\n * ```ts\n * import { interval, take, toArray } from 'rxjs';\n *\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(10),\n *   toArray()\n * );\n *\n * example.subscribe(value => console.log(value));\n *\n * // output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n * ```\n *\n * @return A function that returns an Observable that emits an array of items\n * emitted by the source Observable when source completes.\n */\nexport function toArray<T>(): OperatorFunction<T, T[]> {\n  // Because arrays are mutable, and we're mutating the array in this\n  // reducer process, we have to encapsulate the creation of the initial\n  // array within this `operate` function.\n  return operate((source, subscriber) => {\n    reduce(arrReducer, [] as T[])(source).subscribe(subscriber);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { mergeMap } from './mergeMap';\nimport { toArray } from './toArray';\n\n/**\n * Collects all of the inner sources from source observable. Then, once the\n * source completes, joins the values using the given static.\n *\n * This is used for {@link combineLatestAll} and {@link zipAll} which both have the\n * same behavior of collecting all inner observables, then operating on them.\n *\n * @param joinFn The type of static join to apply to the sources collected\n * @param project The projection function to apply to the values, if any\n */\nexport function joinAllInternals<T, R>(joinFn: (sources: ObservableInput<T>[]) => Observable<T>, project?: (...args: any[]) => R) {\n  return pipe(\n    // Collect all inner sources into an array, and emit them when the\n    // source completes.\n    toArray() as OperatorFunction<ObservableInput<T>, ObservableInput<T>[]>,\n    // Run the join function on the collected array of inner sources.\n    mergeMap((sources) => joinFn(sources)),\n    // If a projection function was supplied, apply it to each result.\n    project ? mapOneOrManyArgs(project) : (identity as any)\n  );\n}\n", "import { combineLatest } from '../observable/combineLatest';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { joinAllInternals } from './joinAllInternals';\n\nexport function combineLatestAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function combineLatestAll<T>(): OperatorFunction<any, T[]>;\nexport function combineLatestAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function combineLatestAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\n/**\n * Flattens an Observable-of-Observables by applying {@link combineLatest} when the Observable-of-Observables completes.\n *\n * `combineLatestAll` takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes,\n * it subscribes to all collected Observables and combines their values using the {@link combineLatest} strategy, such that:\n *\n * * Every time an inner Observable emits, the output Observable emits\n * * When the returned observable emits, it emits all of the latest values by:\n *    * If a `project` function is provided, it is called with each recent value from each inner Observable in whatever order they\n *      arrived, and the result of the `project` function is what is emitted by the output Observable.\n *    * If there is no `project` function, an array of all the most recent values is emitted by the output Observable.\n *\n * ## Example\n *\n * Map two click events to a finite interval Observable, then apply `combineLatestAll`\n *\n * ```ts\n * import { fromEvent, map, interval, take, combineLatestAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(Math.random() * 2000).pipe(take(3))),\n *   take(2)\n * );\n * const result = higherOrder.pipe(combineLatestAll());\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link combineLatestWith}\n * @see {@link mergeAll}\n *\n * @param project optional function to map the most recent values from each inner Observable into a new result.\n * Takes each of the most recent values from each collected inner Observable as arguments, in order.\n * @return A function that returns an Observable that flattens Observables\n * emitted by the source Observable.\n */\nexport function combineLatestAll<R>(project?: (...values: Array<any>) => R) {\n  return joinAllInternals(combineLatest, project);\n}\n", "import { combineLatestAll } from './combineLatestAll';\n\n/**\n * @deprecated Renamed to {@link combineLatestAll}. Will be removed in v8.\n */\nexport const combineAll = combineLatestAll;\n", "import { combineLatestInit } from '../observable/combineLatest';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { pipe } from '../util/pipe';\nimport { popResultSelector } from '../util/args';\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  sources: [...ObservableInputTuple<A>],\n  project: (...values: [T, ...A]) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(\n  ...sourcesAndProject: [...ObservableInputTuple<A>, (...values: [T, ...A]) => R]\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8. */\nexport function combineLatest<T, A extends readonly unknown[], R>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, [T, ...A]>;\n\n/**\n * @deprecated Replaced with {@link combineLatestWith}. Will be removed in v8.\n */\nexport function combineLatest<T, R>(...args: (ObservableInput<any> | ((...values: any[]) => R))[]): OperatorFunction<T, unknown> {\n  const resultSelector = popResultSelector(args);\n  return resultSelector\n    ? pipe(combineLatest(...(args as Array<ObservableInput<any>>)), mapOneOrManyArgs(resultSelector))\n    : operate((source, subscriber) => {\n        combineLatestInit([source, ...argsOrArgArray(args)])(subscriber);\n      });\n}\n", "import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { combineLatest } from './combineLatest';\n\n/**\n * Create an observable that combines the latest values from all passed observables and the source\n * into arrays and emits them.\n *\n * Returns an observable, that when subscribed to, will subscribe to the source observable and all\n * sources provided as arguments. Once all sources emit at least one value, all of the latest values\n * will be emitted as an array. After that, every time any source emits a value, all of the latest values\n * will be emitted as an array.\n *\n * This is a useful operator for eagerly calculating values based off of changed inputs.\n *\n * ## Example\n *\n * Simple concatenation of values from two inputs\n *\n * ```ts\n * import { fromEvent, combineLatestWith, map } from 'rxjs';\n *\n * // Setup: Add two inputs to the page\n * const input1 = document.createElement('input');\n * document.body.appendChild(input1);\n * const input2 = document.createElement('input');\n * document.body.appendChild(input2);\n *\n * // Get streams of changes\n * const input1Changes$ = fromEvent(input1, 'change');\n * const input2Changes$ = fromEvent(input2, 'change');\n *\n * // Combine the changes by adding them together\n * input1Changes$.pipe(\n *   combineLatestWith(input2Changes$),\n *   map(([e1, e2]) => (<HTMLInputElement>e1.target).value + ' - ' + (<HTMLInputElement>e2.target).value)\n * )\n * .subscribe(x => console.log(x));\n * ```\n *\n * @param otherSources the other sources to subscribe to.\n * @return A function that returns an Observable that emits the latest\n * emissions from both source and provided Observables.\n */\nexport function combineLatestWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, Cons<T, A>> {\n  return combineLatest(...otherSources);\n}\n", "import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n", "import { concatMap } from './concatMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)` */\nexport function concatMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in a serialized fashion on the output Observable.\n *\n * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](concatMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. Each new `innerObservable`\n * instance emitted on the output Observable is concatenated with the previous\n * `innerObservable` instance.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n * set to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMapTo, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMapTo(interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link mergeMapTo}\n * @see {@link switchMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @return A function that returns an Observable of values merged together by\n * joining the passed Observable with itself, one after the other, for each\n * value emitted from the source.\n * @deprecated Will be removed in v9. Use {@link concatMap} instead: `concatMap(() => result)`\n */\nexport function concatMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? concatMap(() => innerObservable, resultSelector) : concatMap(() => innerObservable);\n}\n", "import { ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { concatAll } from './concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link concatWith}. Will be removed in v8. */\nexport function concat<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * @deprecated Replaced with {@link concatWith}. Will be removed in v8.\n */\nexport function concat<T, R>(...args: any[]): OperatorFunction<T, R> {\n  const scheduler = popScheduler(args);\n  return operate((source, subscriber) => {\n    concatAll()(from([source, ...args], scheduler)).subscribe(subscriber);\n  });\n}\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { concat } from './concat';\n\n/**\n * Emits all of the values from the source observable, then, once it completes, subscribes\n * to each observable source provided, one at a time, emitting all of their values, and not subscribing\n * to the next one until it completes.\n *\n * `concat(a$, b$, c$)` is the same as `a$.pipe(concatWith(b$, c$))`.\n *\n * ## Example\n *\n * Listen for one mouse click, then listen for all mouse moves.\n *\n * ```ts\n * import { fromEvent, map, take, concatWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click');\n * const moves$ = fromEvent(document, 'mousemove');\n *\n * clicks$.pipe(\n *   map(() => 'click'),\n *   take(1),\n *   concatWith(\n *     moves$.pipe(\n *       map(() => 'move')\n *     )\n *   )\n * )\n * .subscribe(x => console.log(x));\n *\n * // 'click'\n * // 'move'\n * // 'move'\n * // 'move'\n * // ...\n * ```\n *\n * @param otherSources Other observable sources to subscribe to, in sequence, after the original source is complete.\n * @return A function that returns an Observable that concatenates\n * subscriptions to the source and provided Observables subscribing to the next\n * only once the current subscription completes.\n */\nexport function concatWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return concat(...otherSources);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscribable } from '../types';\n\n/**\n * Used to convert a subscribable to an observable.\n *\n * Currently, this is only used within internals.\n *\n * TODO: Discuss ObservableInput supporting \"Subscribable\".\n * https://github.com/ReactiveX/rxjs/issues/5909\n *\n * @param subscribable A subscribable\n */\nexport function fromSubscribable<T>(subscribable: Subscribable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => subscribable.subscribe(subscriber));\n}\n", "import { OperatorFunction, ObservableInput, ObservedValueOf, SubjectLike } from '../types';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { fromSubscribable } from '../observable/fromSubscribable';\n\n/**\n * An object used to configure {@link connect} operator.\n */\nexport interface ConnectConfig<T> {\n  /**\n   * A factory function used to create the Subject through which the source\n   * is multicast. By default, this creates a {@link Subject}.\n   */\n  connector: () => SubjectLike<T>;\n}\n\n/**\n * The default configuration for `connect`.\n */\nconst DEFAULT_CONFIG: ConnectConfig<unknown> = {\n  connector: () => new Subject<unknown>(),\n};\n\n/**\n * Creates an observable by multicasting the source within a function that\n * allows the developer to define the usage of the multicast prior to connection.\n *\n * This is particularly useful if the observable source you wish to multicast could\n * be synchronous or asynchronous. This sets it apart from {@link share}, which, in the\n * case of totally synchronous sources will fail to share a single subscription with\n * multiple consumers, as by the time the subscription to the result of {@link share}\n * has returned, if the source is synchronous its internal reference count will jump from\n * 0 to 1 back to 0 and reset.\n *\n * To use `connect`, you provide a `selector` function that will give you\n * a multicast observable that is not yet connected. You then use that multicast observable\n * to create a resulting observable that, when subscribed, will set up your multicast. This is\n * generally, but not always, accomplished with {@link merge}.\n *\n * Note that using a {@link takeUntil} inside of `connect`'s `selector` _might_ mean you were looking\n * to use the {@link takeWhile} operator instead.\n *\n * When you subscribe to the result of `connect`, the `selector` function will be called. After\n * the `selector` function returns, the observable it returns will be subscribed to, _then_ the\n * multicast will be connected to the source.\n *\n * ## Example\n *\n * Sharing a totally synchronous observable\n *\n * ```ts\n * import { of, tap, connect, merge, map, filter } from 'rxjs';\n *\n * const source$ = of(1, 2, 3, 4, 5).pipe(\n *   tap({\n *     subscribe: () => console.log('subscription started'),\n *     next: n => console.log(`source emitted ${ n }`)\n *   })\n * );\n *\n * source$.pipe(\n *   // Notice in here we're merging 3 subscriptions to `shared$`.\n *   connect(shared$ => merge(\n *     shared$.pipe(map(n => `all ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${ n }`)),\n *     shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${ n }`))\n *   ))\n * )\n * .subscribe(console.log);\n *\n * // Expected output: (notice only one subscription)\n * 'subscription started'\n * 'source emitted 1'\n * 'all 1'\n * 'odd 1'\n * 'source emitted 2'\n * 'all 2'\n * 'even 2'\n * 'source emitted 3'\n * 'all 3'\n * 'odd 3'\n * 'source emitted 4'\n * 'all 4'\n * 'even 4'\n * 'source emitted 5'\n * 'all 5'\n * 'odd 5'\n * ```\n *\n * @param selector A function used to set up the multicast. Gives you a multicast observable\n * that is not yet connected. With that, you're expected to create and return\n * and Observable, that when subscribed to, will utilize the multicast observable.\n * After this function is executed -- and its return value subscribed to -- the\n * operator will subscribe to the source, and the connection will be made.\n * @param config The configuration object for `connect`.\n */\nexport function connect<T, O extends ObservableInput<unknown>>(\n  selector: (shared: Observable<T>) => O,\n  config: ConnectConfig<T> = DEFAULT_CONFIG\n): OperatorFunction<T, ObservedValueOf<O>> {\n  const { connector } = config;\n  return operate((source, subscriber) => {\n    const subject = connector();\n    innerFrom(selector(fromSubscribable(subject))).subscribe(subscriber);\n    subscriber.add(source.subscribe(subject));\n  });\n}\n", "import { OperatorFunction } from '../types';\nimport { reduce } from './reduce';\n\n/**\n * Counts the number of emissions on the source and emits that number when the\n * source completes.\n *\n * <span class=\"informal\">Tells how many values were emitted, when the source\n * completes.</span>\n *\n * ![](count.png)\n *\n * `count` transforms an Observable that emits values into an Observable that\n * emits a single value that represents the number of values emitted by the\n * source Observable. If the source Observable terminates with an error, `count`\n * will pass this error notification along without emitting a value first. If\n * the source Observable does not terminate at all, `count` will neither emit\n * a value nor terminate. This operator takes an optional `predicate` function\n * as argument, in which case the output emission will represent the number of\n * source values that matched `true` with the `predicate`.\n *\n * ## Examples\n *\n * Counts how many seconds have passed before the first click happened\n *\n * ```ts\n * import { interval, fromEvent, takeUntil, count } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const secondsBeforeClick = seconds.pipe(takeUntil(clicks));\n * const result = secondsBeforeClick.pipe(count());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Counts how many odd numbers are there between 1 and 7\n *\n * ```ts\n * import { range, count } from 'rxjs';\n *\n * const numbers = range(1, 7);\n * const result = numbers.pipe(count(i => i % 2 === 1));\n * result.subscribe(x => console.log(x));\n * // Results in:\n * // 4\n * ```\n *\n * @see {@link max}\n * @see {@link min}\n * @see {@link reduce}\n *\n * @param predicate A function that is used to analyze the value and the index and\n * determine whether or not to increment the count. Return `true` to increment the count,\n * and return `false` to keep the count the same.\n * If the predicate is not provided, every value will be counted.\n * @return A function that returns an Observable that emits one number that\n * represents the count of emissions.\n */\nexport function count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number> {\n  return reduce((total, value, i) => (!predicate || predicate(value, i) ? total + 1 : total), 0);\n}\n", "import { Subscriber } from '../Subscriber';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * determined by another Observable has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n * emission silence is determined by a second Observable.</span>\n *\n * ![](debounce.svg)\n *\n * `debounce` delays notifications emitted by the source Observable, but drops previous\n * pending delayed emissions if a new notification arrives on the source Observable.\n * This operator keeps track of the most recent notification from the source\n * Observable, and spawns a duration Observable by calling the\n * `durationSelector` function. The notification is emitted only when the duration\n * Observable emits a next notification, and if no other notification was emitted on\n * the source Observable since the duration Observable was spawned. If a new\n * notification appears before the duration Observable emits, the previous notification will\n * not be emitted and a new duration is scheduled from `durationSelector` is scheduled.\n * If the completing event happens during the scheduled duration the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during the scheduled duration or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n * delay-like operator since output emissions do not necessarily occur at the\n * same time as they did on the source Observable.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, scan, debounce, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   scan(i => ++i, 1),\n *   debounce(i => interval(200 * i))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function\n * that receives a value from the source Observable, for computing the timeout\n * duration for each source value, returned as an Observable or a Promise.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified duration Observable returned by\n * `durationSelector`, and may drop some values if they occur too frequently.\n */\nexport function debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    // The subscriber/subscription for the current debounce, if there is one.\n    let durationSubscriber: Subscriber<any> | null = null;\n\n    const emit = () => {\n      // Unsubscribe any current debounce subscription we have,\n      // we only cared about the first notification from it, and we\n      // want to clean that subscription up as soon as possible.\n      durationSubscriber?.unsubscribe();\n      durationSubscriber = null;\n      if (hasValue) {\n        // We have a value! Free up memory first, then emit the value.\n        hasValue = false;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Cancel any pending debounce duration. We don't\n          // need to null it out here yet tho, because we're just going\n          // to create another one in a few lines.\n          durationSubscriber?.unsubscribe();\n          hasValue = true;\n          lastValue = value;\n          // Capture our duration subscriber, so we can unsubscribe it when we're notified\n          // and we're going to emit the value.\n          durationSubscriber = createOperatorSubscriber(subscriber, emit, noop);\n          // Subscribe to the duration.\n          innerFrom(durationSelector(value)).subscribe(durationSubscriber);\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = durationSubscriber = null;\n        }\n      )\n    );\n  });\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a notification from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent notification from each burst of emissions.</span>\n *\n * ![](debounceTime.png)\n *\n * `debounceTime` delays notifications emitted by the source Observable, but drops\n * previous pending delayed emissions if a new notification arrives on the source\n * Observable. This operator keeps track of the most recent notification from the\n * source Observable, and emits that only when `dueTime` has passed\n * without any other notification appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous notification will be dropped\n * and will not be emitted and a new `dueTime` is scheduled.\n * If the completing event happens during `dueTime` the last cached notification\n * is emitted before the completion event is forwarded to the output observable.\n * If the error event happens during `dueTime` or after it only the error event is\n * forwarded to the output observable. The cache notification is not emitted in this case.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * notification to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\n * managing timers.\n *\n * ## Example\n *\n * Emit the most recent click after a burst of clicks\n *\n * ```ts\n * import { fromEvent, debounceTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(debounceTime(1000));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link throttle}\n * @see {@link throttleTime}\n *\n * @param dueTime The timeout duration in milliseconds (or the time unit determined\n * internally by the optional `scheduler`) for the window of time required to wait\n * for emission silence before emitting the most recent source value.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers that\n * handle the timeout for each value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified `dueTime`, and may drop some values\n * if they occur too frequently.\n */\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let activeTask: Subscription | null = null;\n    let lastValue: T | null = null;\n    let lastTime: number | null = null;\n\n    const emit = () => {\n      if (activeTask) {\n        // We have a value! Free up memory first, then emit the value.\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue!;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\n      // This is called `dueTime` after the first value\n      // but we might have received new values during this window!\n\n      const targetTime = lastTime! + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        // On that case, re-schedule to the new target\n        activeTask = this.schedule(undefined, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n\n      emit();\n    }\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          lastValue = value;\n          lastTime = scheduler.now();\n\n          // Only set up a task if it's not already up\n          if (!activeTask) {\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n            subscriber.add(activeTask);\n          }\n        },\n        () => {\n          // Source completed.\n          // Emit any pending debounced values then complete\n          emit();\n          subscriber.complete();\n        },\n        // Pass all errors through to consumer.\n        undefined,\n        () => {\n          // Finalization.\n          lastValue = activeTask = null;\n        }\n      )\n    );\n  });\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\n *\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\n * to the Observable, which will ensure that it will never call its observers\u2019 `next` handlers.\n *\n * ## Example\n *\n * Ignore all `next` emissions from the source\n *\n * ```ts\n * import { of, ignoreElements } from 'rxjs';\n *\n * of('you', 'talking', 'to', 'me')\n *   .pipe(ignoreElements())\n *   .subscribe({\n *     next: word => console.log(word),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // result:\n * // 'the end'\n * ```\n *\n * @return A function that returns an empty Observable that only calls\n * `complete` or `error`, based on which one is called by the source\n * Observable.\n */\nexport function ignoreElements(): OperatorFunction<unknown, never> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\n  });\n}\n", "import { OperatorFunction } from '../types';\nimport { map } from './map';\n\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\n/**\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\n * use {@link map} instead: `map(() => value)`.\n * */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n *\n * Map every click to the string `'Hi'`\n *\n * ```ts\n * import { fromEvent, mapTo } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n *\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\n */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\n  return map(() => value);\n}\n", "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\n\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay: Observable<any>\n): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` operator shifts each emitted value from the source Observable by\n * a time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the value emitted from\n * the source Observable as the first argument to the `delayDurationSelector`.\n * The `delayDurationSelector` function should return an {@link ObservableInput},\n * that is internally converted to an Observable that is called the \"duration\"\n * Observable.\n *\n * The source value is emitted on the output Observable only when the \"duration\"\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\n * Upon that, the \"duration\" Observable gets unsubscribed.\n *\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\n * of the \"duration\" Observable would have been triggering the emission of the\n * source value to the output Observable, but with RxJS V7, this is not the case\n * anymore.\n *\n * Only next notifications (from the \"duration\" Observable) trigger values from\n * the source Observable to be passed to the output Observable. If the \"duration\"\n * Observable only emits the complete notification (without next), the value\n * emitted by the source Observable will never get to the output Observable - it\n * will be swallowed. If the \"duration\" Observable errors, the error will be\n * propagated to the output Observable.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n *\n * Delay each click by a random amount of time, between 0 and 5 seconds\n *\n * ```ts\n * import { fromEvent, delayWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(() => interval(Math.random() * 5000))\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param delayDurationSelector A function that returns an `ObservableInput` for\n * each `value` emitted by the source Observable, which is then used to delay the\n * emission of that `value` on the output Observable until the `ObservableInput`\n * returned from this function emits a next value. When called, beside `value`,\n * this function receives a zero-based `index` of the emission order.\n * @param subscriptionDelay An Observable that triggers the subscription to the\n * source Observable once it emits any value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by an amount of time specified by the Observable\n * returned by `delayDurationSelector`.\n */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay?: Observable<any>\n): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n  }\n\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.svg)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n *\n * Delay each click by one second\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delayWhen}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param due The delay duration in milliseconds (a `number`) or a `Date` until\n * which the emission of the source items is delayed.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the time-shift for each item.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified timeout or Date.\n */\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  const duration = timer(due, scheduler);\n  return delayWhen(() => duration);\n}\n", "import { observeNotification } from '../Notification';\nimport { OperatorFunction, ObservableNotification, ValueFromNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Converts an Observable of {@link ObservableNotification} objects into the emissions\n * that they represent.\n *\n * <span class=\"informal\">Unwraps {@link ObservableNotification} objects as actual `next`,\n * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n *\n * ![](dematerialize.png)\n *\n * `dematerialize` is assumed to operate an Observable that only emits\n * {@link ObservableNotification} objects as `next` emissions, and does not emit any\n * `error`. Such Observable is the output of a `materialize` operation. Those\n * notifications are then unwrapped using the metadata they contain, and emitted\n * as `next`, `error`, and `complete` on the output Observable.\n *\n * Use this operator in conjunction with {@link materialize}.\n *\n * ## Example\n *\n * Convert an Observable of Notifications to an actual Observable\n *\n * ```ts\n * import { NextNotification, ErrorNotification, of, dematerialize } from 'rxjs';\n *\n * const notifA: NextNotification<string> = { kind: 'N', value: 'A' };\n * const notifB: NextNotification<string> = { kind: 'N', value: 'B' };\n * const notifE: ErrorNotification = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') };\n *\n * const materialized = of(notifA, notifB, notifE);\n *\n * const upperCase = materialized.pipe(dematerialize());\n * upperCase.subscribe({\n *   next: x => console.log(x),\n *   error: e => console.error(e)\n * });\n *\n * // Results in:\n * // A\n * // B\n * // TypeError: x.toUpperCase is not a function\n * ```\n *\n * @see {@link materialize}\n *\n * @return A function that returns an Observable that emits items and\n * notifications embedded in Notification objects emitted by the source\n * Observable.\n */\nexport function dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, (notification) => observeNotification(notification, subscriber)));\n  });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n *\n * If a `keySelector` function is provided, then it will project each value from the source observable into a new value that it will\n * check for equality with previously projected values. If the `keySelector` function is not provided, it will use each value from the\n * source observable directly with an equality check against previous values.\n *\n * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n *\n * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n * that the internal `Set` can be \"flushed\", basically clearing it of values.\n *\n * ## Examples\n *\n * A simple example with numbers\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n *   .pipe(distinct())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * An example using the `keySelector` function\n *\n * ```ts\n * import { of, distinct } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo'},\n *   { age: 7, name: 'Bar'},\n *   { age: 5, name: 'Foo'}\n * )\n * .pipe(distinct(({ name }) => name))\n * .subscribe(x => console.log(x));\n *\n * // Outputs\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * ```\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param keySelector Optional `function` to select which value you want to check as distinct.\n * @param flushes Optional `ObservableInput` for flushing the internal HashSet of the operator.\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinct<T, K>(keySelector?: (value: T) => K, flushes?: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const distinctKeys = new Set();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const key = keySelector ? keySelector(value) : value;\n        if (!distinctKeys.has(key)) {\n          distinctKeys.add(key);\n          subscriber.next(value);\n        }\n      })\n    );\n\n    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, () => distinctKeys.clear(), noop));\n  });\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\nexport function distinctUntilChanged<T, K>(\n  comparator: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\n * are distinct in comparison to the last value the result observable emitted.\n *\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\n * it behaves like this:\n *\n * 1. It will always emit the first value from the source.\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\n *    using the provided `comparator` or an `===` equality check.\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\n *    becomes the new \"previously emitted value\" internally.\n *\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\n * changes:\n *\n * 1. It will always emit the first value from the source.\n * 2. The `keySelector` will be run against all values, including the first value.\n * 3. For all values after the first, the selected key will be compared against the key selected from\n *    the previously emitted value using the `comparator`.\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\n *    and the selected key from that value is saved for future comparisons against other keys.\n *\n * ## Examples\n *\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\n * because it's distinct in comparison to the _previously emitted_ value,\n * not in comparison to _all other emitted values_.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\n *   .pipe(distinctUntilChanged())\n *   .subscribe(console.log);\n * // Logs: 1, 2, 1, 3\n * ```\n *\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\n * you only want to emit a value when all of its components have\n * changed:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const totallyDifferentBuilds$ = of(\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ).pipe(\n *   distinctUntilChanged((prev, curr) => {\n *     return (\n *       prev.engineVersion === curr.engineVersion ||\n *       prev.transmissionVersion === curr.transmissionVersion\n *     );\n *   })\n * );\n *\n * totallyDifferentBuilds$.subscribe(console.log);\n *\n * // Logs:\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\n * ```\n *\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\n * changes are only in one direction. Let's say you only want to get\n * the next record temperature:\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\n *\n * const recordHighs$ = temps$.pipe(\n *   distinctUntilChanged((prevHigh, temp) => {\n *     // If the current temp is less than\n *     // or the same as the previous record,\n *     // the record hasn't changed.\n *     return temp <= prevHigh;\n *   })\n * );\n *\n * recordHighs$.subscribe(console.log);\n * // Logs: 30, 31, 34, 35\n * ```\n *\n * Selecting update events only when the `updatedBy` field shows\n * the account changed hands.\n *\n * ```ts\n * import { of, distinctUntilChanged } from 'rxjs';\n *\n * // A stream of updates to a given account\n * const accountUpdates$ = of(\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'blesh', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'ncjamieson', data: [] },\n *   { updatedBy: 'blesh', data: [] }\n * );\n *\n * // We only want the events where it changed hands\n * const changedHands$ = accountUpdates$.pipe(\n *   distinctUntilChanged(undefined, update => update.updatedBy)\n * );\n *\n * changedHands$.subscribe(console.log);\n * // Logs:\n * // { updatedBy: 'blesh', data: Array[0] }\n * // { updatedBy: 'ncjamieson', data: Array[0] }\n * // { updatedBy: 'blesh', data: Array[0] }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilKeyChanged}\n *\n * @param comparator A function used to compare the previous and current keys for\n * equality. Defaults to a `===` check.\n * @param keySelector Used to select a key value to be passed to the `comparator`.\n *\n * @return A function that returns an Observable that emits items from the\n * source Observable with distinct values.\n */\nexport function distinctUntilChanged<T, K>(\n  comparator?: (previous: K, current: K) => boolean,\n  keySelector: (value: T) => K = identity as (value: T) => K\n): MonoTypeOperatorFunction<T> {\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\n  // a default value for the parameter, because that will only work\n  // for `undefined`.\n  comparator = comparator ?? defaultCompare;\n\n  return operate((source, subscriber) => {\n    // The previous key, used to compare against keys selected\n    // from new arrivals to determine \"distinctiveness\".\n    let previousKey: K;\n    // Whether or not this is the first value we've gotten.\n    let first = true;\n\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        // We always call the key selector.\n        const currentKey = keySelector(value);\n\n        // If it's the first value, we always emit it.\n        // Otherwise, we compare this key to the previous key, and\n        // if the comparer returns false, we emit.\n        if (first || !comparator!(previousKey, currentKey)) {\n          // Update our state *before* we emit the value\n          // as emission can be the source of re-entrant code\n          // in functional libraries like this. We only really\n          // need to do this if it's the first value, or if the\n          // key we're tracking in previous needs to change.\n          first = false;\n          previousKey = currentKey;\n\n          // Emit the value!\n          subscriber.next(value);\n        }\n      })\n    );\n  });\n}\n\nfunction defaultCompare(a: any, b: any) {\n  return a === b;\n}\n", "import { distinctUntilChanged } from './distinctUntilChanged';\nimport { MonoTypeOperatorFunction } from '../types';\n\nexport function distinctUntilKeyChanged<T>(key: keyof T): MonoTypeOperatorFunction<T>;\nexport function distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that emits all items emitted by the source Observable that\n * are distinct by comparison from the previous item, using a property accessed by\n * using the key provided to check if the two items are distinct.\n *\n * If a comparator function is provided, then it will be called for each item to\n * test for whether that value should be emitted or not.\n *\n * If a comparator function is not provided, an equality check is used by default.\n *\n * ## Examples\n *\n * An example comparing the name of persons\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo' },\n *   { age: 6, name: 'Foo' }\n * ).pipe(\n *   distinctUntilKeyChanged('name')\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo' }\n * ```\n *\n * An example comparing the first letters of the name\n *\n * ```ts\n * import { of, distinctUntilKeyChanged } from 'rxjs';\n *\n * of(\n *   { age: 4, name: 'Foo1' },\n *   { age: 7, name: 'Bar' },\n *   { age: 5, name: 'Foo2' },\n *   { age: 6, name: 'Foo3' }\n * ).pipe(\n *   distinctUntilKeyChanged('name', (x, y) => x.substring(0, 3) === y.substring(0, 3))\n * )\n * .subscribe(x => console.log(x));\n *\n * // displays:\n * // { age: 4, name: 'Foo1' }\n * // { age: 7, name: 'Bar' }\n * // { age: 5, name: 'Foo2' }\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n *\n * @param key String key for object property lookup on each item.\n * @param compare Optional comparison function called to test if an item is distinct\n * from the previous item in the source.\n * @return A function that returns an Observable that emits items from the source\n * Observable with distinct values based on the key specified.\n */\nexport function distinctUntilKeyChanged<T, K extends keyof T>(\n  key: K,\n  compare?: (x: T[K], y: T[K]) => boolean\n): MonoTypeOperatorFunction<T> {\n  return distinctUntilChanged((x: T, y: T) => (compare ? compare(x[key], y[key]) : x[key] === y[key]));\n}\n", "import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n", "import { ArgumentOutOfRangeError } from '../util/ArgumentOutOfRangeError';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../types';\nimport { filter } from './filter';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { take } from './take';\n\n/**\n * Emits the single value at the specified `index` in a sequence of emissions\n * from the source Observable.\n *\n * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n *\n * ![](elementAt.png)\n *\n * `elementAt` returns an Observable that emits the item at the specified\n * `index` in the source Observable, or a default value if that `index` is out\n * of range and the `default` argument is provided. If the `default` argument is\n * not given and the `index` is out of range, the output Observable will emit an\n * `ArgumentOutOfRangeError` error.\n *\n * ## Example\n *\n * Emit only the third click event\n *\n * ```ts\n * import { fromEvent, elementAt } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(elementAt(2));\n * result.subscribe(x => console.log(x));\n *\n * // Results in:\n * // click 1 = nothing\n * // click 2 = nothing\n * // click 3 = MouseEvent object logged to console\n * ```\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link skip}\n * @see {@link single}\n * @see {@link take}\n *\n * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n * `ArgumentOutOfRangeError` to the Observer's `error` callback if `i < 0` or the\n * Observable has completed before emitting the i-th `next` notification.\n *\n * @param index Is the number `i` for the i-th source emission that has happened\n * since the subscription, starting from the number `0`.\n * @param defaultValue The default value returned for missing indices.\n * @return A function that returns an Observable that emits a single item, if\n * it is found. Otherwise, it will emit the default value if given. If not, it\n * emits an error.\n */\nexport function elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D> {\n  if (index < 0) {\n    throw new ArgumentOutOfRangeError();\n  }\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      filter((v, i) => i === index),\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new ArgumentOutOfRangeError())\n    );\n}\n", "/** prettier */\nimport { Observable } from '../Observable';\nimport { concat } from '../observable/concat';\nimport { of } from '../observable/of';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ValueFromArray } from '../types';\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T>(scheduler: SchedulerLike): MonoTypeOperatorFunction<T>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function endWith<T, A extends unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\n\nexport function endWith<T, A extends unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that will emit all values from the source, then synchronously emit\n * the provided value(s) immediately after the source completes.\n *\n * NOTE: Passing a last argument of a Scheduler is _deprecated_, and may result in incorrect\n * types in TypeScript.\n *\n * This is useful for knowing when an observable ends. Particularly when paired with an\n * operator like {@link takeUntil}\n *\n * ![](endWith.png)\n *\n * ## Example\n *\n * Emit values to know when an interval starts and stops. The interval will\n * stop when a user clicks anywhere on the document.\n *\n * ```ts\n * import { interval, map, fromEvent, startWith, takeUntil, endWith } from 'rxjs';\n *\n * const ticker$ = interval(5000).pipe(\n *   map(() => 'tick')\n * );\n *\n * const documentClicks$ = fromEvent(document, 'click');\n *\n * ticker$.pipe(\n *   startWith('interval started'),\n *   takeUntil(documentClicks$),\n *   endWith('interval ended by click')\n * )\n * .subscribe(x => console.log(x));\n *\n * // Result (assuming a user clicks after 15 seconds)\n * // 'interval started'\n * // 'tick'\n * // 'tick'\n * // 'tick'\n * // 'interval ended by click'\n * ```\n *\n * @see {@link startWith}\n * @see {@link concat}\n * @see {@link takeUntil}\n *\n * @param values Items you want the modified Observable to emit last.\n * @return A function that returns an Observable that emits all values from the\n * source, then synchronously emits the provided value(s) immediately after the\n * source completes.\n */\nexport function endWith<T>(...values: Array<T | SchedulerLike>): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => concat(source, of(...values)) as Observable<T>;\n}\n", "import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function every<T>(predicate: BooleanConstructor): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T>(\n  predicate: BooleanConstructor,\n  thisArg: any\n): OperatorFunction<T, Exclude<T, Falsy> extends never ? false : boolean>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function every<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, boolean>;\nexport function every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, boolean>;\n\n/**\n * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n *\n * <span class=\"informal\">If all values pass predicate before the source completes, emits true before completion,\n * otherwise emit false, then complete.</span>\n *\n * ![](every.png)\n *\n * ## Example\n *\n * A simple example emitting true if all elements are less than 5, false otherwise\n *\n * ```ts\n * import { of, every } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5, 6)\n *   .pipe(every(x => x < 5))\n *   .subscribe(x => console.log(x)); // -> false\n * ```\n *\n * @param predicate A function for determining if an item meets a specified condition.\n * @param thisArg Optional object to use for `this` in the callback.\n * @return A function that returns an Observable of booleans that determines if\n * all items of the source Observable meet the condition specified.\n */\nexport function every<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          if (!predicate.call(thisArg, value, index++, source)) {\n            subscriber.next(false);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function exhaustMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable only if the previous projected Observable has completed.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link exhaustAll}.</span>\n *\n * ![](exhaustMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. When it projects a source value to\n * an Observable, the output Observable begins emitting the items emitted by\n * that projected Observable. However, `exhaustMap` ignores every new projected\n * Observable if the previous projected Observable has not yet completed. Once\n * that one completes, it will accept and flatten the next projected Observable\n * and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, exhaustMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   exhaustMap(() => interval(1000).pipe(take(5)))\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaust}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable containing projected\n * Observables of each item of the source, ignoring projected Observables that\n * start before their preceding Observable has completed.\n */\nexport function exhaustMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (resultSelector) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      source.pipe(exhaustMap((a, i) => innerFrom(project(a, i)).pipe(map((b: any, ii: any) => resultSelector(a, b, i, ii)))));\n  }\n  return operate((source, subscriber) => {\n    let index = 0;\n    let innerSub: Subscriber<T> | null = null;\n    let isComplete = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (outerValue) => {\n          if (!innerSub) {\n            innerSub = createOperatorSubscriber(subscriber, undefined, () => {\n              innerSub = null;\n              isComplete && subscriber.complete();\n            });\n            innerFrom(project(outerValue, index++)).subscribe(innerSub);\n          }\n        },\n        () => {\n          isComplete = true;\n          !innerSub && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { exhaustMap } from './exhaustMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by dropping\n * inner Observables while the previous inner Observable has not yet completed.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n * next inner Observables while the current inner is still executing.</span>\n *\n * ![](exhaustAll.svg)\n *\n * `exhaustAll` subscribes to an Observable that emits Observables, also known as a\n * higher-order Observable. Each time it observes one of these emitted inner\n * Observables, the output Observable begins emitting the items emitted by that\n * inner Observable. So far, it behaves like {@link mergeAll}. However,\n * `exhaustAll` ignores every new inner Observable if the previous Observable has\n * not yet completed. Once that one completes, it will accept and flatten the\n * next inner Observable and repeat this process.\n *\n * ## Example\n *\n * Run a finite timer for each click, only if there is no currently active timer\n *\n * ```ts\n * import { fromEvent, map, interval, take, exhaustAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(5)))\n * );\n * const result = higherOrder.pipe(exhaustAll());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeAll}\n * @see {@link exhaustMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable that takes a source of\n * Observables and propagates the first Observable exclusively until it\n * completes before subscribing to the next.\n */\nexport function exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return exhaustMap(identity);\n}\n", "import { exhaustAll } from './exhaustAll';\n\n/**\n * @deprecated Renamed to {@link exhaustAll}. Will be removed in v8.\n */\nexport const exhaust = exhaustAll;\n", "import { OperatorFunction, ObservableInput, ObservedValueOf, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/* tslint:disable:max-line-length */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/**\n * @deprecated The `scheduler` parameter will be removed in v8. If you need to schedule the inner subscription,\n * use `subscribeOn` within the projection function: `expand((value) => fn(value).pipe(subscribeOn(scheduler)))`.\n * Details: Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent: number | undefined,\n  scheduler: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Recursively projects each source value to an Observable which is merged in\n * the output Observable.\n *\n * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n * projection function to every source value as well as every output value.\n * It's recursive.</span>\n *\n * ![](expand.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger. *Expand* will re-emit on the output\n * Observable every source value. Then, each output value is given to the\n * `project` function which returns an inner Observable to be merged on the\n * output Observable. Those output values resulting from the projection are also\n * given to the `project` function to produce new output values. This is how\n * *expand* behaves recursively.\n *\n * ## Example\n *\n * Start emitting the powers of two on every click, at most 10 of them\n *\n * ```ts\n * import { fromEvent, map, expand, of, delay, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const powersOfTwo = clicks.pipe(\n *   map(() => 1),\n *   expand(x => of(2 * x).pipe(delay(1000))),\n *   take(10)\n * );\n * powersOfTwo.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n *\n * @param project A function that, when applied to an item emitted by the source\n * or the output Observable, returns an Observable.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @param scheduler The {@link SchedulerLike} to use for subscribing to\n * each projected inner Observable.\n * @return A function that returns an Observable that emits the source values\n * and also result of applying the projection function to each value emitted on\n * the output Observable and merging the results of the Observables obtained\n * from this transformation.\n */\nexport function expand<T, O extends ObservableInput<unknown>>(\n  project: (value: T, index: number) => O,\n  concurrent = Infinity,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, ObservedValueOf<O>> {\n  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;\n  return operate((source, subscriber) =>\n    mergeInternals(\n      // General merge params\n      source,\n      subscriber,\n      project,\n      concurrent,\n\n      // onBeforeNext\n      undefined,\n\n      // Expand-specific\n      true, // Use expand path\n      scheduler // Inner subscription scheduler\n    )\n  );\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function find<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, S extends T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => value is S,\n  thisArg: A\n): OperatorFunction<T, S | undefined>;\nexport function find<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S\n): OperatorFunction<T, S | undefined>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function find<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, T | undefined>;\nexport function find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, T | undefined>;\n/**\n * Emits only the first value emitted by the source Observable that meets some\n * condition.\n *\n * <span class=\"informal\">Finds the first value that passes some test and emits\n * that.</span>\n *\n * ![](find.png)\n *\n * `find` searches for the first item in the source Observable that matches the\n * specified condition embodied by the `predicate`, and returns the first\n * occurrence in the source. Unlike {@link first}, the `predicate` is required\n * in `find`, and does not emit an error if a valid value is not found\n * (emits `undefined` instead).\n *\n * ## Example\n *\n * Find and emit the first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, find } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(find(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link first}\n * @see {@link findIndex}\n * @see {@link take}\n *\n * @param predicate A function called with each item to test for condition matching.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function find<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, T | undefined> {\n  return operate(createFind(predicate, thisArg, 'value'));\n}\n\nexport function createFind<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: any,\n  emit: 'value' | 'index'\n) {\n  const findIndex = emit === 'index';\n  return (source: Observable<T>, subscriber: Subscriber<any>) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          const i = index++;\n          if (predicate.call(thisArg, value, i, source)) {\n            subscriber.next(findIndex ? i : value);\n            subscriber.complete();\n          }\n        },\n        () => {\n          subscriber.next(findIndex ? -1 : undefined);\n          subscriber.complete();\n        }\n      )\n    );\n  };\n}\n", "import { Observable } from '../Observable';\nimport { Falsy, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createFind } from './find';\n\nexport function findIndex<T>(predicate: BooleanConstructor): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T>(predicate: BooleanConstructor, thisArg: any): OperatorFunction<T, T extends Falsy ? -1 : number>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function findIndex<T, A>(\n  predicate: (this: A, value: T, index: number, source: Observable<T>) => boolean,\n  thisArg: A\n): OperatorFunction<T, number>;\nexport function findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean): OperatorFunction<T, number>;\n\n/**\n * Emits only the index of the first value emitted by the source Observable that\n * meets some condition.\n *\n * <span class=\"informal\">It's like {@link find}, but emits the index of the\n * found value, not the value itself.</span>\n *\n * ![](findIndex.png)\n *\n * `findIndex` searches for the first item in the source Observable that matches\n * the specified condition embodied by the `predicate`, and returns the\n * (zero-based) index of the first occurrence in the source. Unlike\n * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n * an error if a valid value is not found.\n *\n * ## Example\n *\n * Emit the index of first click that happens on a DIV element\n *\n * ```ts\n * import { fromEvent, findIndex } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(findIndex(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link first}\n * @see {@link take}\n *\n * @param predicate A function called with each item to test for condition matching.\n * @param thisArg An optional argument to determine the value of `this` in the\n * `predicate` function.\n * @return A function that returns an Observable that emits the index of the\n * first item that matches the condition.\n */\nexport function findIndex<T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  thisArg?: any\n): OperatorFunction<T, number> {\n  return operate(createFind(predicate, thisArg, 'index'));\n}\n", "import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Emits an error\n * notification if `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n * @see {@link last}\n *\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from `take(1)` which completes instead.\n *\n * @param predicate An optional function called with each item to test for condition\n * matching.\n * @param defaultValue The default value emitted in case no valid value was found on\n * the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { ObservableInput, Observer, OperatorFunction, SubjectLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber, OperatorSubscriber } from './OperatorSubscriber';\n\nexport interface BasicGroupByOptions<K, T> {\n  element?: undefined;\n  duration?: (grouped: GroupedObservable<K, T>) => ObservableInput<any>;\n  connector?: () => SubjectLike<T>;\n}\n\nexport interface GroupByOptionsWithElement<K, E, T> {\n  element: (value: T) => E;\n  duration?: (grouped: GroupedObservable<K, E>) => ObservableInput<any>;\n  connector?: () => SubjectLike<E>;\n}\n\nexport function groupBy<T, K>(key: (value: T) => K, options: BasicGroupByOptions<K, T>): OperatorFunction<T, GroupedObservable<K, T>>;\n\nexport function groupBy<T, K, E>(\n  key: (value: T) => K,\n  options: GroupByOptionsWithElement<K, E, T>\n): OperatorFunction<T, GroupedObservable<K, E>>;\n\nexport function groupBy<T, K extends T>(\n  key: (value: T) => value is K\n): OperatorFunction<T, GroupedObservable<true, K> | GroupedObservable<false, Exclude<T, K>>>;\n\nexport function groupBy<T, K>(key: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K>(\n  key: (value: T) => K,\n  element: void,\n  duration: (grouped: GroupedObservable<K, T>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, T>>;\n\n/**\n * @deprecated use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n/**\n * Groups the items emitted by an Observable according to a specified criterion,\n * and emits these grouped items as `GroupedObservables`, one\n * {@link GroupedObservable} per group.\n *\n * ![](groupBy.png)\n *\n * When the Observable emits an item, a key is computed for this item with the key function.\n *\n * If a {@link GroupedObservable} for this key exists, this {@link GroupedObservable} emits. Otherwise, a new\n * {@link GroupedObservable} for this key is created and emits.\n *\n * A {@link GroupedObservable} represents values belonging to the same group represented by a common key. The common\n * key is available as the `key` field of a {@link GroupedObservable} instance.\n *\n * The elements emitted by {@link GroupedObservable}s are by default the items emitted by the Observable, or elements\n * returned by the element function.\n *\n * ## Examples\n *\n * Group objects by `id` and return as array\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [])))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // [{ id: 1, name: 'JavaScript' }, { id: 1, name: 'TypeScript'}]\n * // [{ id: 2, name: 'Parcel' }, { id: 2, name: 'webpack'}]\n * // [{ id: 3, name: 'TSLint' }]\n * ```\n *\n * Pivot data on the `id` field\n *\n * ```ts\n * import { of, groupBy, mergeMap, reduce, map } from 'rxjs';\n *\n * of(\n *   { id: 1, name: 'JavaScript' },\n *   { id: 2, name: 'Parcel' },\n *   { id: 2, name: 'webpack' },\n *   { id: 1, name: 'TypeScript' },\n *   { id: 3, name: 'TSLint' }\n * ).pipe(\n *   groupBy(p => p.id, { element: p => p.name }),\n *   mergeMap(group$ => group$.pipe(reduce((acc, cur) => [...acc, cur], [`${ group$.key }`]))),\n *   map(arr => ({ id: parseInt(arr[0], 10), values: arr.slice(1) }))\n * )\n * .subscribe(p => console.log(p));\n *\n * // displays:\n * // { id: 1, values: [ 'JavaScript', 'TypeScript' ] }\n * // { id: 2, values: [ 'Parcel', 'webpack' ] }\n * // { id: 3, values: [ 'TSLint' ] }\n * ```\n *\n * @param key A function that extracts the key\n * for each item.\n * @param element A function that extracts the\n * return element for each item.\n * @param duration\n * A function that returns an Observable to determine how long each group should\n * exist.\n * @param connector Factory function to create an\n * intermediate Subject through which grouped elements are emitted.\n * @return A function that returns an Observable that emits GroupedObservables,\n * each of which corresponds to a unique key value and each of which emits\n * those items from the source Observable that share that key value.\n *\n * @deprecated Use the options parameter instead.\n */\nexport function groupBy<T, K, R>(\n  key: (value: T) => K,\n  element?: (value: T) => R,\n  duration?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n  connector?: () => Subject<R>\n): OperatorFunction<T, GroupedObservable<K, R>>;\n\n// Impl\nexport function groupBy<T, K, R>(\n  keySelector: (value: T) => K,\n  elementOrOptions?: ((value: any) => any) | void | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>,\n  duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>,\n  connector?: () => SubjectLike<any>\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return operate((source, subscriber) => {\n    let element: ((value: any) => any) | void;\n    if (!elementOrOptions || typeof elementOrOptions === 'function') {\n      element = elementOrOptions as ((value: any) => any);\n    } else {\n      ({ duration, element, connector } = elementOrOptions);\n    }\n\n    // A lookup for the groups that we have so far.\n    const groups = new Map<K, SubjectLike<any>>();\n\n    // Used for notifying all groups and the subscriber in the same way.\n    const notify = (cb: (group: Observer<any>) => void) => {\n      groups.forEach(cb);\n      cb(subscriber);\n    };\n\n    // Used to handle errors from the source, AND errors that occur during the\n    // next call from the source.\n    const handleError = (err: any) => notify((consumer) => consumer.error(err));\n\n    // The number of actively subscribed groups\n    let activeGroups = 0;\n\n    // Whether or not teardown was attempted on this subscription.\n    let teardownAttempted = false;\n\n    // Capturing a reference to this, because we need a handle to it\n    // in `createGroupedObservable` below. This is what we use to\n    // subscribe to our source observable. This sometimes needs to be unsubscribed\n    // out-of-band with our `subscriber` which is the downstream subscriber, or destination,\n    // in cases where a user unsubscribes from the main resulting subscription, but\n    // still has groups from this subscription subscribed and would expect values from it\n    // Consider:  `source.pipe(groupBy(fn), take(2))`.\n    const groupBySourceSubscriber = new OperatorSubscriber(\n      subscriber,\n      (value: T) => {\n        // Because we have to notify all groups of any errors that occur in here,\n        // we have to add our own try/catch to ensure that those errors are propagated.\n        // OperatorSubscriber will only send the error to the main subscriber.\n        try {\n          const key = keySelector(value);\n\n          let group = groups.get(key);\n          if (!group) {\n            // Create our group subject\n            groups.set(key, (group = connector ? connector() : new Subject<any>()));\n\n            // Emit the grouped observable. Note that we can't do a simple `asObservable()` here,\n            // because the grouped observable has special semantics around reference counting\n            // to ensure we don't sever our connection to the source prematurely.\n            const grouped = createGroupedObservable(key, group);\n            subscriber.next(grouped);\n\n            if (duration) {\n              const durationSubscriber = createOperatorSubscriber(\n                // Providing the group here ensures that it is disposed of -- via `unsubscribe` --\n                // when the duration subscription is torn down. That is important, because then\n                // if someone holds a handle to the grouped observable and tries to subscribe to it\n                // after the connection to the source has been severed, they will get an\n                // `ObjectUnsubscribedError` and know they can't possibly get any notifications.\n                group as any,\n                () => {\n                  // Our duration notified! We can complete the group.\n                  // The group will be removed from the map in the finalization phase.\n                  group!.complete();\n                  durationSubscriber?.unsubscribe();\n                },\n                // Completions are also sent to the group, but just the group.\n                undefined,\n                // Errors on the duration subscriber are sent to the group\n                // but only the group. They are not sent to the main subscription.\n                undefined,\n                // Finalization: Remove this group from our map.\n                () => groups.delete(key)\n              );\n\n              // Start our duration notifier.\n              groupBySourceSubscriber.add(innerFrom(duration(grouped)).subscribe(durationSubscriber));\n            }\n          }\n\n          // Send the value to our group.\n          group.next(element ? element(value) : value);\n        } catch (err) {\n          handleError(err);\n        }\n      },\n      // Source completes.\n      () => notify((consumer) => consumer.complete()),\n      // Error from the source.\n      handleError,\n      // Free up memory.\n      // When the source subscription is _finally_ torn down, release the subjects and keys\n      // in our groups Map, they may be quite large and we don't want to keep them around if we\n      // don't have to.\n      () => groups.clear(),\n      () => {\n        teardownAttempted = true;\n        // We only kill our subscription to the source if we have\n        // no active groups. As stated above, consider this scenario:\n        // source$.pipe(groupBy(fn), take(2)).\n        return activeGroups === 0;\n      }\n    );\n\n    // Subscribe to the source\n    source.subscribe(groupBySourceSubscriber);\n\n    /**\n     * Creates the actual grouped observable returned.\n     * @param key The key of the group\n     * @param groupSubject The subject that fuels the group\n     */\n    function createGroupedObservable(key: K, groupSubject: SubjectLike<any>) {\n      const result: any = new Observable<T>((groupSubscriber) => {\n        activeGroups++;\n        const innerSub = groupSubject.subscribe(groupSubscriber);\n        return () => {\n          innerSub.unsubscribe();\n          // We can kill the subscription to our source if we now have no more\n          // active groups subscribed, and a finalization was already attempted on\n          // the source.\n          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();\n        };\n      });\n      result.key = key;\n      return result;\n    }\n  });\n}\n\n/**\n * An observable of values that is the emitted by the result of a {@link groupBy} operator,\n * contains a `key` property for the grouping.\n */\nexport interface GroupedObservable<K, T> extends Observable<T> {\n  /**\n   * The key value for the grouped notifications.\n   */\n  readonly key: K;\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits `false` if the input Observable emits any values, or emits `true` if the\n * input Observable completes without emitting any values.\n *\n * <span class=\"informal\">Tells whether any values are emitted by an Observable.</span>\n *\n * ![](isEmpty.png)\n *\n * `isEmpty` transforms an Observable that emits values into an Observable that\n * emits a single boolean value representing whether or not any values were\n * emitted by the source Observable. As soon as the source Observable emits a\n * value, `isEmpty` will emit a `false` and complete.  If the source Observable\n * completes having not emitted anything, `isEmpty` will emit a `true` and\n * complete.\n *\n * A similar effect could be achieved with {@link count}, but `isEmpty` can emit\n * a `false` value sooner.\n *\n * ## Examples\n *\n * Emit `false` for a non-empty Observable\n *\n * ```ts\n * import { Subject, isEmpty } from 'rxjs';\n *\n * const source = new Subject<string>();\n * const result = source.pipe(isEmpty());\n *\n * source.subscribe(x => console.log(x));\n * result.subscribe(x => console.log(x));\n *\n * source.next('a');\n * source.next('b');\n * source.next('c');\n * source.complete();\n *\n * // Outputs\n * // 'a'\n * // false\n * // 'b'\n * // 'c'\n * ```\n *\n * Emit `true` for an empty Observable\n *\n * ```ts\n * import { EMPTY, isEmpty } from 'rxjs';\n *\n * const result = EMPTY.pipe(isEmpty());\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // true\n * ```\n *\n * @see {@link count}\n * @see {@link EMPTY}\n *\n * @return A function that returns an Observable that emits boolean value\n * indicating whether the source Observable was empty or not.\n */\nexport function isEmpty<T>(): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          subscriber.next(false);\n          subscriber.complete();\n        },\n        () => {\n          subscriber.next(true);\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { EMPTY } from '../observable/empty';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Waits for the source to complete, then emits the last N values from the source,\n * as specified by the `count` argument.\n *\n * ![](takeLast.png)\n *\n * `takeLast` results in an observable that will hold values up to `count` values in memory,\n * until the source completes. It then pushes all values in memory to the consumer, in the\n * order they were received from the source, then notifies the consumer that it is\n * complete.\n *\n * If for some reason the source completes before the `count` supplied to `takeLast` is reached,\n * all values received until that point are emitted, and then completion is notified.\n *\n * **Warning**: Using `takeLast` with an observable that never completes will result\n * in an observable that never emits a value.\n *\n * ## Example\n *\n * Take the last 3 values of an Observable with many values\n *\n * ```ts\n * import { range, takeLast } from 'rxjs';\n *\n * const many = range(1, 100);\n * const lastThree = many.pipe(takeLast(3));\n * lastThree.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of values to emit from the end of\n * the sequence of values emitted by the source Observable.\n * @return A function that returns an Observable that emits at most the last\n * `count` values emitted by the source Observable.\n */\nexport function takeLast<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        // This buffer will hold the values we are going to emit\n        // when the source completes. Since we only want to take the\n        // last N values, we can't emit until we're sure we're not getting\n        // any more values.\n        let buffer: T[] = [];\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              // Add the most recent value onto the end of our buffer.\n              buffer.push(value);\n              // If our buffer is now larger than the number of values we\n              // want to take, we remove the oldest value from the buffer.\n              count < buffer.length && buffer.shift();\n            },\n            () => {\n              // The source completed, we now know what are last values\n              // are, emit them in the order they were received.\n              for (const value of buffer) {\n                subscriber.next(value);\n              }\n              subscriber.complete();\n            },\n            // Errors are passed through to the consumer\n            undefined,\n            () => {\n              // During finalization release the values in our buffer.\n              buffer = null!;\n            }\n          )\n        );\n      });\n}\n", "import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { takeLast } from './takeLast';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function last<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function last<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function last<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function last<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function last<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Returns an Observable that emits only the last item emitted by the source Observable.\n * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n * the last item from the source Observable, the resulting Observable will emit the last item\n * from the source Observable that satisfies the predicate.\n *\n * ![](last.png)\n *\n * It will emit an error notification if the source completes without notification or one that matches\n * the predicate. It returns the last value or if a predicate is provided last value that matches the\n * predicate. It returns the given default value if no notification is emitted or matches the predicate.\n *\n * ## Examples\n *\n * Last alphabet from the sequence\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last());\n *\n * result.subscribe(value => console.log(`Last alphabet: ${ value }`));\n *\n * // Outputs\n * // Last alphabet: z\n * ```\n *\n * Default value when the value in the predicate is not matched\n *\n * ```ts\n * import { from, last } from 'rxjs';\n *\n * const source = from(['x', 'y', 'z']);\n * const result = source.pipe(last(char => char === 'a', 'not found'));\n *\n * result.subscribe(value => console.log(`'a' is ${ value }.`));\n *\n * // Outputs\n * // 'a' is not found.\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n * @see {@link skipWhile}\n * @see {@link first}\n *\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n *\n * @param predicate The condition any source emitted item has to satisfy.\n * @param defaultValue An optional default value to provide if last `predicate`\n * isn't met or no values were emitted.\n * @return A function that returns an Observable that emits only the last item\n * satisfying the given condition from the source, or an error notification\n * with an `EmptyError` object if no such items are emitted.\n */\nexport function last<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      takeLast(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n", "import { Notification } from '../Notification';\nimport { OperatorFunction, ObservableNotification } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Represents all of the notifications from the source Observable as `next`\n * emissions marked with their original types within {@link Notification}\n * objects.\n *\n * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n * {@link Notification} objects, emitted as `next` on the output Observable.\n * </span>\n *\n * ![](materialize.png)\n *\n * `materialize` returns an Observable that emits a `next` notification for each\n * `next`, `error`, or `complete` emission of the source Observable. When the\n * source Observable emits `complete`, the output Observable will emit `next` as\n * a Notification of type \"complete\", and then it will emit `complete` as well.\n * When the source Observable emits `error`, the output will emit `next` as a\n * Notification of type \"error\", and then `complete`.\n *\n * This operator is useful for producing metadata of the source Observable, to\n * be consumed as `next` emissions. Use it in conjunction with\n * {@link dematerialize}.\n *\n * ## Example\n *\n * Convert a faulty Observable to an Observable of Notifications\n *\n * ```ts\n * import { of, materialize, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 13, 'd');\n * const upperCase = letters.pipe(map((x: any) => x.toUpperCase()));\n * const materialized = upperCase.pipe(materialize());\n *\n * materialized.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - Notification { kind: 'N', value: 'A', error: undefined, hasValue: true }\n * // - Notification { kind: 'N', value: 'B', error: undefined, hasValue: true }\n * // - Notification { kind: 'E', value: undefined, error: TypeError { message: x.toUpperCase is not a function }, hasValue: false }\n * ```\n *\n * @see {@link Notification}\n * @see {@link dematerialize}\n *\n * @return A function that returns an Observable that emits\n * {@link Notification} objects that wrap the original emissions from the\n * source Observable with metadata.\n */\nexport function materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          subscriber.next(Notification.createNext(value));\n        },\n        () => {\n          subscriber.next(Notification.createComplete());\n          subscriber.complete();\n        },\n        (err) => {\n          subscriber.next(Notification.createError(err));\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The `max` operator operates on an Observable that emits numbers (or items that\n * can be compared with a provided function), and when source Observable completes\n * it emits a single item: the item with the largest value.\n *\n * ![](max.png)\n *\n * ## Examples\n *\n * Get the maximal value of a series of numbers\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(max())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 8\n * ```\n *\n * Use a comparer function to get the maximal item\n *\n * ```ts\n * import { of, max } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   max((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Beer'\n * ```\n *\n * @see {@link min}\n *\n * @param comparer Optional comparer function that it will use instead of its\n * default to compare the value of two items.\n * @return A function that returns an Observable that emits item with the\n * largest value.\n */\nexport function max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) > 0 ? x : y) : (x, y) => (x > y ? x : y));\n}\n", "import { mergeMap } from './mergeMap';\n\n/**\n * @deprecated Renamed to {@link mergeMap}. Will be removed in v8.\n */\nexport const flatMap = mergeMap;\n", "import { OperatorFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { mergeMap } from './mergeMap';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)` */\nexport function mergeMapTo<O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  concurrent?: number\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/**\n * @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead.\n * Details: https://rxjs.dev/deprecations/resultSelector\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to the same Observable which is merged multiple\n * times in the output Observable.\n *\n * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n * to the same inner Observable.</span>\n *\n * ![](mergeMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then merges those resulting Observables into one\n * single Observable, which is the output Observable.\n *\n * ## Example\n *\n * For each click event, start an interval Observable ticking every 1 second\n *\n * ```ts\n * import { fromEvent, mergeMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(mergeMapTo(interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeScan}\n * @see {@link switchMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable`.\n * @deprecated Will be removed in v9. Use {@link mergeMap} instead: `mergeMap(() => result)`\n */\nexport function mergeMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    return mergeMap(() => innerObservable, resultSelector, concurrent);\n  }\n  if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n  return mergeMap(() => innerObservable, concurrent);\n}\n", "import { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, then each intermediate\n * Observable returned is merged into the output Observable.\n *\n * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n * by the accumulator are merged into the outer Observable.</span>\n *\n * The first parameter of the `mergeScan` is an `accumulator` function which is\n * being called every time the source Observable emits a value. `mergeScan` will\n * subscribe to the value returned by the `accumulator` function and will emit\n * values to the subscriber emitted by inner Observable.\n *\n * The `accumulator` function is being called with three parameters passed to it:\n * `acc`, `value` and `index`. The `acc` parameter is used as the state parameter\n * whose value is initially set to the `seed` parameter (the second parameter\n * passed to the `mergeScan` operator).\n *\n * `mergeScan` internally keeps the value of the `acc` parameter: as long as the\n * source Observable emits without inner Observable emitting, the `acc` will be\n * set to `seed`. The next time the inner Observable emits a value, `mergeScan`\n * will internally remember it and it will be passed to the `accumulator`\n * function as `acc` parameter the next time source emits.\n *\n * The `value` parameter of the `accumulator` function is the value emitted by the\n * source Observable, while the `index` is a number which represent the order of the\n * current emission by the source Observable. It starts with 0.\n *\n * The last parameter to the `mergeScan` is the `concurrent` value which defaults\n * to Infinity. It represents the maximum number of inner Observable subscriptions\n * at a time.\n *\n * ## Example\n *\n * Count the number of click events\n *\n * ```ts\n * import { fromEvent, map, mergeScan, of } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n * const one$ = click$.pipe(map(() => 1));\n * const seed = 0;\n * const count$ = one$.pipe(\n *   mergeScan((acc, one) => of(acc + one), seed)\n * );\n *\n * count$.subscribe(x => console.log(x));\n *\n * // Results:\n * // 1\n * // 2\n * // 3\n * // 4\n * // ...and so on for each click\n * ```\n *\n * @see {@link scan}\n * @see {@link switchScan}\n *\n * @param accumulator The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @param concurrent Maximum number of input Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function mergeScan<T, R>(\n  accumulator: (acc: R, value: T, index: number) => ObservableInput<R>,\n  seed: R,\n  concurrent = Infinity\n): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The accumulated state.\n    let state = seed;\n\n    return mergeInternals(\n      source,\n      subscriber,\n      (value, index) => accumulator(state, value, index),\n      concurrent,\n      (value) => {\n        state = value;\n      },\n      false,\n      undefined,\n      () => (state = null!)\n    );\n  });\n}\n", "import { ObservableInput, ObservableInputTuple, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { mergeAll } from './mergeAll';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from '../observable/from';\n\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrency: [...ObservableInputTuple<A>, number]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n/** @deprecated Replaced with {@link mergeWith}. Will be removed in v8. */\nexport function merge<T, A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number, SchedulerLike]\n): OperatorFunction<T, T | A[number]>;\n\nexport function merge<T>(...args: unknown[]): OperatorFunction<T, unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n\n  return operate((source, subscriber) => {\n    mergeAll(concurrent)(from([source, ...(args as ObservableInput<T>[])], scheduler)).subscribe(subscriber);\n  });\n}\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { merge } from './merge';\n\n/**\n * Merge the values from all observables to a single observable result.\n *\n * Creates an observable, that when subscribed to, subscribes to the source\n * observable, and all other sources provided as arguments. All values from\n * every source are emitted from the resulting subscription.\n *\n * When all sources complete, the resulting observable will complete.\n *\n * When any source errors, the resulting observable will error.\n *\n * ## Example\n *\n * Joining all outputs from multiple user input event streams\n *\n * ```ts\n * import { fromEvent, map, mergeWith } from 'rxjs';\n *\n * const clicks$ = fromEvent(document, 'click').pipe(map(() => 'click'));\n * const mousemoves$ = fromEvent(document, 'mousemove').pipe(map(() => 'mousemove'));\n * const dblclicks$ = fromEvent(document, 'dblclick').pipe(map(() => 'dblclick'));\n *\n * mousemoves$\n *   .pipe(mergeWith(clicks$, dblclicks$))\n *   .subscribe(x => console.log(x));\n *\n * // result (assuming user interactions)\n * // 'mousemove'\n * // 'mousemove'\n * // 'mousemove'\n * // 'click'\n * // 'click'\n * // 'dblclick'\n * ```\n *\n * @see {@link merge}\n *\n * @param otherSources the sources to combine the current source with.\n * @return A function that returns an Observable that merges the values from\n * all given Observables.\n */\nexport function mergeWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return merge(...otherSources);\n}\n", "import { reduce } from './reduce';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * The `min` operator operates on an Observable that emits numbers (or items that\n * can be compared with a provided function), and when source Observable completes\n * it emits a single item: the item with the smallest value.\n *\n * ![](min.png)\n *\n * ## Examples\n *\n * Get the minimal value of a series of numbers\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(5, 4, 7, 2, 8)\n *   .pipe(min())\n *   .subscribe(x => console.log(x));\n *\n * // Outputs\n * // 2\n * ```\n *\n * Use a comparer function to get the minimal item\n *\n * ```ts\n * import { of, min } from 'rxjs';\n *\n * of(\n *   { age: 7, name: 'Foo' },\n *   { age: 5, name: 'Bar' },\n *   { age: 9, name: 'Beer' }\n * ).pipe(\n *   min((a, b) => a.age < b.age ? -1 : 1)\n * )\n * .subscribe(x => console.log(x.name));\n *\n * // Outputs\n * // 'Bar'\n * ```\n *\n * @see {@link max}\n *\n * @param comparer Optional comparer function that it will use instead of its\n * default to compare the value of two items.\n * @return A function that returns an Observable that emits item with the\n * smallest value.\n */\nexport function min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T> {\n  return reduce(isFunction(comparer) ? (x, y) => (comparer(x, y) < 0 ? x : y) : (x, y) => (x < y ? x : y));\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { connect } from './connect';\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subject The subject to multicast through.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(subject), refCount()` is equivalent to\n * `share({ connector: () => subject, resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subject The subject used to multicast.\n * @param selector A setup function to setup the multicast\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subject, selector)` is equivalent to\n * `connect(selector, { connector: () => subject })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subject: Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * An operator that creates a {@link ConnectableObservable}, that when connected,\n * with the `connect` method, will use the provided subject to multicast the values\n * from the source to all consumers.\n *\n * @param subjectFactory A factory that will be called to create the subject. Passing a function here\n * will cause the underlying subject to be \"reset\" on error, completion, or refCounted unsubscription of\n * the source.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * If you're using {@link refCount} after `multicast`, use the {@link share} operator instead.\n * `multicast(() => new BehaviorSubject('test')), refCount()` is equivalent to\n * `share({ connector: () => new BehaviorSubject('test') })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T>(subjectFactory: () => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Because this is deprecated in favor of the {@link connect} operator, and was otherwise poorly documented,\n * rather than duplicate the effort of documenting the same behavior, please see documentation for the\n * {@link connect} operator.\n *\n * @param subjectFactory A factory that creates the subject used to multicast.\n * @param selector A function to setup the multicast and select the output.\n * @return A function that returns an observable that mirrors the observable returned by the selector.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `multicast(subjectFactory, selector)` is equivalent to\n * `connect(selector, { connector: subjectFactory })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, O extends ObservableInput<any>>(\n  subjectFactory: () => Subject<T>,\n  selector: (shared: Observable<T>) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function multicast<T, R>(\n  subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),\n  selector?: (source: Observable<T>) => Observable<R>\n): OperatorFunction<T, R> {\n  const subjectFactory = isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : () => subjectOrSubjectFactory;\n\n  if (isFunction(selector)) {\n    // If a selector function is provided, then we're a \"normal\" operator that isn't\n    // going to return a ConnectableObservable. We can use `connect` to do what we\n    // need to do.\n    return connect(selector, {\n      connector: subjectFactory,\n    });\n  }\n\n  return (source: Observable<T>) => new ConnectableObservable<any>(source, subjectFactory);\n}\n", "import { ObservableInputTuple, OperatorFunction } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { onErrorResumeNext as oERNCreate } from '../observable/onErrorResumeNext';\n\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]>;\n\n/**\n * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n * that was passed.\n *\n * <span class=\"informal\">Execute series of Observables, subscribes to next one on error or complete.</span>\n *\n * ![](onErrorResumeNext.png)\n *\n * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n * as the source.\n *\n * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n * be happening until there is no more Observables left in the series, at which point returned Observable will\n * complete - even if the last subscribed stream ended with an error.\n *\n * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n * an error.\n *\n * Note that you do not get any access to errors emitted by the Observables. In particular do not\n * expect these errors to appear in error callback passed to {@link Observable#subscribe}. If you want to take\n * specific actions based on what error was emitted by an Observable, you should try out {@link catchError} instead.\n *\n *\n * ## Example\n *\n * Subscribe to the next Observable after map fails\n *\n * ```ts\n * import { of, onErrorResumeNext, map } from 'rxjs';\n *\n * of(1, 2, 3, 0)\n *   .pipe(\n *     map(x => {\n *       if (x === 0) {\n *         throw Error();\n *       }\n *\n *       return 10 / x;\n *     }),\n *     onErrorResumeNext(of(1, 2, 3))\n *   )\n *   .subscribe({\n *     next: val => console.log(val),\n *     error: err => console.log(err),          // Will never be called.\n *     complete: () => console.log('that\\'s it!')\n *   });\n *\n * // Logs:\n * // 10\n * // 5\n * // 3.3333333333333335\n * // 1\n * // 2\n * // 3\n * // 'that's it!'\n * ```\n *\n * @see {@link concat}\n * @see {@link catchError}\n *\n * @param sources `ObservableInput`s passed either directly or as an array.\n * @return A function that returns an Observable that emits values from source\n * Observable, but - if it errors - subscribes to the next passed Observable\n * and so on, until it completes or runs out of Observables.\n */\nexport function onErrorResumeNextWith<T, A extends readonly unknown[]>(\n  ...sources: [[...ObservableInputTuple<A>]] | [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  // For some reason, TS 4.1 RC gets the inference wrong here and infers the\n  // result to be `A[number][]` - completely dropping the ObservableInput part\n  // of the type. This makes no sense whatsoever. As a workaround, the type is\n  // asserted explicitly.\n  const nextSources = argsOrArgArray(sources) as unknown as ObservableInputTuple<A>;\n\n  return (source) => oERNCreate(source, ...nextSources);\n}\n\n/**\n * @deprecated Renamed. Use {@link onErrorResumeNextWith} instead. Will be removed in v8.\n */\nexport const onErrorResumeNext = onErrorResumeNextWith;\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n", "import { map } from './map';\nimport { OperatorFunction } from '../types';\n\n/* tslint:disable:max-line-length */\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T>(k1: K1): OperatorFunction<T, T[K1]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1]>(k1: K1, k2: K2): OperatorFunction<T, T[K1][K2]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(\n  k1: K1,\n  k2: K2,\n  k3: K3\n): OperatorFunction<T, T[K1][K2][K3]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2], K4 extends keyof T[K1][K2][K3]>(\n  k1: K1,\n  k2: K2,\n  k3: K3,\n  k4: K4\n): OperatorFunction<T, T[K1][K2][K3][K4]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5): OperatorFunction<T, T[K1][K2][K3][K4][K5]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6): OperatorFunction<T, T[K1][K2][K3][K4][K5][K6]>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<\n  T,\n  K1 extends keyof T,\n  K2 extends keyof T[K1],\n  K3 extends keyof T[K1][K2],\n  K4 extends keyof T[K1][K2][K3],\n  K5 extends keyof T[K1][K2][K3][K4],\n  K6 extends keyof T[K1][K2][K3][K4][K5]\n>(k1: K1, k2: K2, k3: K3, k4: K4, k5: K5, k6: K6, ...rest: string[]): OperatorFunction<T, unknown>;\n/** @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8. */\nexport function pluck<T>(...properties: string[]): OperatorFunction<T, unknown>;\n/* tslint:enable:max-line-length */\n\n/**\n * Maps each source value to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted value.</span>\n *\n * ![](pluck.png)\n *\n * Given a list of strings or numbers describing a path to a property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * ## Example\n *\n * Map every click to the tagName of the clicked target element\n *\n * ```ts\n * import { fromEvent, pluck } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const tagNames = clicks.pipe(pluck('target', 'tagName'));\n *\n * tagNames.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param properties The nested properties to pluck from each source\n * value.\n * @return A function that returns an Observable of property values from the\n * source values.\n * @deprecated Use {@link map} and optional chaining: `pluck('foo', 'bar')` is `map(x => x?.foo?.bar)`. Will be removed in v8.\n */\nexport function pluck<T, R>(...properties: Array<string | number | symbol>): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return map((x) => {\n    let currentProp: any = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp?.[properties[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  });\n}\n", "import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { multicast } from './multicast';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { connect } from './connect';\n\n/**\n * Returns a connectable observable that, when connected, will multicast\n * all values through a single underlying {@link Subject} instance.\n *\n * @deprecated Will be removed in v8. To create a connectable observable, use {@link connectable}.\n * `source.pipe(publish())` is equivalent to\n * `connectable(source, { connector: () => new Subject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publish`, use {@link share} operator instead.\n * `source.pipe(publish(), refCount())` is equivalent to\n * `source.pipe(share({ resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>>;\n\n/**\n * Returns an observable, that when subscribed to, creates an underlying {@link Subject},\n * provides an observable view of it to a `selector` function, takes the observable result of\n * that selector function and subscribes to it, sending its values to the consumer, _then_ connects\n * the subject to the original source.\n *\n * @param selector A function used to setup multicasting prior to automatic connection.\n *\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `publish(selector)` is equivalent to `connect(selector)`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, O extends ObservableInput<any>>(selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n * before it begins emitting items to those Observers that have subscribed to it.\n *\n * <span class=\"informal\">Makes a cold Observable hot</span>\n *\n * ![](publish.png)\n *\n * ## Examples\n *\n * Make `source$` hot by applying `publish` operator, then merge each inner observable into a single one\n * and subscribe\n *\n * ```ts\n * import { zip, interval, of, map, publish, merge, tap } from 'rxjs';\n *\n * const source$ = zip(interval(2000), of(1, 2, 3, 4, 5, 6, 7, 8, 9))\n *   .pipe(map(([, number]) => number));\n *\n * source$\n *   .pipe(\n *     publish(multicasted$ =>\n *       merge(\n *         multicasted$.pipe(tap(x => console.log('Stream 1:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 2:', x))),\n *         multicasted$.pipe(tap(x => console.log('Stream 3:', x)))\n *       )\n *     )\n *   )\n *   .subscribe();\n *\n * // Results every two seconds\n * // Stream 1: 1\n * // Stream 2: 1\n * // Stream 3: 1\n * // ...\n * // Stream 1: 9\n * // Stream 2: 9\n * // Stream 3: 9\n * ```\n *\n * @see {@link publishLast}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @param selector Optional selector function which can use the multicasted source sequence as many times\n * as needed, without causing multiple subscriptions to the source sequence.\n * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n * @return A function that returns a ConnectableObservable that upon connection\n * causes the source Observable to emit items to its Observers.\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publish<T, R>(selector?: OperatorFunction<T, R>): MonoTypeOperatorFunction<T> | OperatorFunction<T, R> {\n  return selector ? (source) => connect(selector)(source) : (source) => multicast(new Subject<T>())(source);\n}\n", "import { Observable } from '../Observable';\nimport { BehaviorSubject } from '../BehaviorSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Creates a {@link ConnectableObservable} that utilizes a {@link BehaviorSubject}.\n *\n * @param initialValue The initial value passed to the {@link BehaviorSubject}.\n * @return A function that returns a {@link ConnectableObservable}\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link BehaviorSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishBehavior(initValue))` is equivalent to\n * `connectable(source, { connector: () => new BehaviorSubject(initValue), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishBehavior`, use the {@link share} operator instead.\n * `source.pipe(publishBehavior(initValue), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new BehaviorSubject(initValue), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false  }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishBehavior<T>(initialValue: T): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported the selector function.\n  return (source) => {\n    const subject = new BehaviorSubject<T>(initialValue);\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n", "import { Observable } from '../Observable';\nimport { AsyncSubject } from '../AsyncSubject';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { UnaryFunction } from '../types';\n\n/**\n * Returns a connectable observable sequence that shares a single subscription to the\n * underlying sequence containing only the last notification.\n *\n * ![](publishLast.png)\n *\n * Similar to {@link publish}, but it waits until the source observable completes and stores\n * the last emitted value.\n * Similarly to {@link publishReplay} and {@link publishBehavior}, this keeps storing the last\n * value even if it has no more subscribers. If subsequent subscriptions happen, they will\n * immediately get that last stored value and complete.\n *\n * ## Example\n *\n * ```ts\n * import { ConnectableObservable, interval, publishLast, tap, take } from 'rxjs';\n *\n * const connectable = <ConnectableObservable<number>>interval(1000)\n *   .pipe(\n *     tap(x => console.log('side effect', x)),\n *     take(3),\n *     publishLast()\n *   );\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. A', x),\n *   error: err => console.log('Sub. A Error', err),\n *   complete: () => console.log('Sub. A Complete')\n * });\n *\n * connectable.subscribe({\n *   next: x => console.log('Sub. B', x),\n *   error: err => console.log('Sub. B Error', err),\n *   complete: () => console.log('Sub. B Complete')\n * });\n *\n * connectable.connect();\n *\n * // Results:\n * // 'side effect 0'   - after one second\n * // 'side effect 1'   - after two seconds\n * // 'side effect 2'   - after three seconds\n * // 'Sub. A 2'        - immediately after 'side effect 2'\n * // 'Sub. B 2'\n * // 'Sub. A Complete'\n * // 'Sub. B Complete'\n * ```\n *\n * @see {@link ConnectableObservable}\n * @see {@link publish}\n * @see {@link publishReplay}\n * @see {@link publishBehavior}\n *\n * @return A function that returns an Observable that emits elements of a\n * sequence produced by multicasting the source sequence.\n * @deprecated Will be removed in v8. To create a connectable observable with an\n * {@link AsyncSubject} under the hood, use {@link connectable}.\n * `source.pipe(publishLast())` is equivalent to\n * `connectable(source, { connector: () => new AsyncSubject(), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishLast`, use the {@link share} operator instead.\n * `source.pipe(publishLast(), refCount())` is equivalent to\n * `source.pipe(share({ connector: () => new AsyncSubject(), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishLast<T>(): UnaryFunction<Observable<T>, ConnectableObservable<T>> {\n  // Note that this has *never* supported a selector function like `publish` and `publishReplay`.\n  return (source) => {\n    const subject = new AsyncSubject<T>();\n    return new ConnectableObservable(source, () => subject);\n  };\n}\n", "import { Observable } from '../Observable';\nimport { ReplaySubject } from '../ReplaySubject';\nimport { multicast } from './multicast';\nimport { MonoTypeOperatorFunction, OperatorFunction, TimestampProvider, ObservableInput, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T>(\n  bufferSize?: number,\n  windowTime?: number,\n  timestampProvider?: TimestampProvider\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Creates an observable, that when subscribed to, will create a {@link ReplaySubject},\n * and pass an observable from it (using [asObservable](api/index/class/Subject#asObservable)) to\n * the `selector` function, which then returns an observable that is subscribed to before\n * \"connecting\" the source to the internal `ReplaySubject`.\n *\n * Since this is deprecated, for additional details see the documentation for {@link connect}.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector A function used to setup the multicast.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. Use the {@link connect} operator instead.\n * `source.pipe(publishReplay(size, window, selector, scheduler))` is equivalent to\n * `source.pipe(connect(selector, { connector: () => new ReplaySubject(size, window, scheduler) }))`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: (shared: Observable<T>) => O,\n  timestampProvider?: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * Creates a {@link ConnectableObservable} that uses a {@link ReplaySubject}\n * internally.\n *\n * @param bufferSize The buffer size for the underlying {@link ReplaySubject}.\n * @param windowTime The window time for the underlying {@link ReplaySubject}.\n * @param selector Passing `undefined` here determines that this operator will return a {@link ConnectableObservable}.\n * @param timestampProvider The timestamp provider for the underlying {@link ReplaySubject}.\n * @deprecated Will be removed in v8. To create a connectable observable that uses a\n * {@link ReplaySubject} under the hood, use {@link connectable}.\n * `source.pipe(publishReplay(size, time, scheduler))` is equivalent to\n * `connectable(source, { connector: () => new ReplaySubject(size, time, scheduler), resetOnDisconnect: false })`.\n * If you're using {@link refCount} after `publishReplay`, use the {@link share} operator instead.\n * `publishReplay(size, time, scheduler), refCount()` is equivalent to\n * `share({ connector: () => new ReplaySubject(size, time, scheduler), resetOnError: false, resetOnComplete: false, resetOnRefCountZero: false })`.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, O extends ObservableInput<any>>(\n  bufferSize: number | undefined,\n  windowTime: number | undefined,\n  selector: undefined,\n  timestampProvider: TimestampProvider\n): OperatorFunction<T, ObservedValueOf<O>>;\n\n/**\n * @deprecated Will be removed in v8. Use the {@link connectable} observable, the {@link connect} operator or the\n * {@link share} operator instead. See the overloads below for equivalent replacement examples of this operator's\n * behaviors.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function publishReplay<T, R>(\n  bufferSize?: number,\n  windowTime?: number,\n  selectorOrScheduler?: TimestampProvider | OperatorFunction<T, R>,\n  timestampProvider?: TimestampProvider\n) {\n  if (selectorOrScheduler && !isFunction(selectorOrScheduler)) {\n    timestampProvider = selectorOrScheduler;\n  }\n  const selector = isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;\n  // Note, we're passing `selector!` here, because at runtime, `undefined` is an acceptable argument\n  // but it makes our TypeScript signature for `multicast` unhappy (as it should, because it's gross).\n  return (source: Observable<T>) => multicast(new ReplaySubject<T>(bufferSize, windowTime, timestampProvider), selector!)(source);\n}\n", "import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { raceInit } from '../observable/race';\nimport { operate } from '../util/lift';\nimport { identity } from '../util/identity';\n\n/**\n * Creates an Observable that mirrors the first source Observable to emit a next,\n * error or complete notification from the combination of the Observable to which\n * the operator is applied and supplied Observables.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, raceWith } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * obs1\n *   .pipe(raceWith(obs2, obs3))\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param otherSources Sources used to race for which Observable emits first.\n * @return A function that returns an Observable that mirrors the output of the\n * first Observable to emit an item.\n */\nexport function raceWith<T, A extends readonly unknown[]>(\n  ...otherSources: [...ObservableInputTuple<A>]\n): OperatorFunction<T, T | A[number]> {\n  return !otherSources.length\n    ? identity\n    : operate((source, subscriber) => {\n        raceInit<T | A[number]>([source, ...otherSources])(subscriber);\n      });\n}\n", "import { Subscription } from '../Subscription';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { timer } from '../observable/timer';\n\nexport interface RepeatConfig {\n  /**\n   * The number of times to repeat the source. Defaults to `Infinity`.\n   */\n  count?: number;\n\n  /**\n   * If a `number`, will delay the repeat of the source by that number of milliseconds.\n   * If a function, it will provide the number of times the source has been subscribed to,\n   * and the return value should be a valid observable input that will notify when the source\n   * should be repeated. If the notifier observable is empty, the result will complete.\n   */\n  delay?: number | ((count: number) => ObservableInput<any>);\n}\n\n/**\n * Returns an Observable that will resubscribe to the source stream when the source stream completes.\n *\n * <span class=\"informal\">Repeats all values emitted on the source. It's like {@link retry}, but for non error cases.</span>\n *\n * ![](repeat.png)\n *\n * Repeat will output values from a source until the source completes, then it will resubscribe to the\n * source a specified number of times, with a specified delay. Repeat can be particularly useful in\n * combination with closing operators like {@link take}, {@link takeUntil}, {@link first}, or {@link takeWhile},\n * as it can be used to restart a source again from scratch.\n *\n * Repeat is very similar to {@link retry}, where {@link retry} will resubscribe to the source in the error case, but\n * `repeat` will resubscribe if the source completes.\n *\n * Note that `repeat` will _not_ catch errors. Use {@link retry} for that.\n *\n * - `repeat(0)` returns an empty observable\n * - `repeat()` will repeat forever\n * - `repeat({ delay: 200 })` will repeat forever, with a delay of 200ms between repetitions.\n * - `repeat({ count: 2, delay: 400 })` will repeat twice, with a delay of 400ms between repetitions.\n * - `repeat({ delay: (count) => timer(count * 1000) })` will repeat forever, but will have a delay that grows by one second for each repetition.\n *\n * ## Example\n *\n * Repeat a message stream\n *\n * ```ts\n * import { of, repeat } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const result = source.pipe(repeat(3));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results\n * // 'Repeat message'\n * // 'Repeat message'\n * // 'Repeat message'\n * ```\n *\n * Repeat 3 values, 2 times\n *\n * ```ts\n * import { interval, take, repeat } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(take(3), repeat(2));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results every second\n * // 0\n * // 1\n * // 2\n * // 0\n * // 1\n * // 2\n * ```\n *\n * Defining two complex repeats with delays on the same source.\n * Note that the second repeat cannot be called until the first\n * repeat as exhausted it's count.\n *\n * ```ts\n * import { defer, of, repeat } from 'rxjs';\n *\n * const source = defer(() => {\n *    return of(`Hello, it is ${new Date()}`)\n * });\n *\n * source.pipe(\n *    // Repeat 3 times with a delay of 1 second between repetitions\n *    repeat({\n *      count: 3,\n *      delay: 1000,\n *    }),\n *\n *    // *Then* repeat forever, but with an exponential step-back\n *    // maxing out at 1 minute.\n *    repeat({\n *      delay: (count) => timer(Math.min(60000, 2 ^ count * 1000))\n *    })\n * )\n * ```\n *\n * @see {@link repeatWhen}\n * @see {@link retry}\n *\n * @param countOrConfig Either the number of times the source Observable items are repeated\n * (a count of 0 will yield an empty Observable) or a {@link RepeatConfig} object.\n */\nexport function repeat<T>(countOrConfig?: number | RepeatConfig): MonoTypeOperatorFunction<T> {\n  let count = Infinity;\n  let delay: RepeatConfig['delay'];\n\n  if (countOrConfig != null) {\n    if (typeof countOrConfig === 'object') {\n      ({ count = Infinity, delay } = countOrConfig);\n    } else {\n      count = countOrConfig;\n    }\n  }\n\n  return count <= 0\n    ? () => EMPTY\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let sourceSub: Subscription | null;\n\n        const resubscribe = () => {\n          sourceSub?.unsubscribe();\n          sourceSub = null;\n          if (delay != null) {\n            const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(soFar));\n            const notifierSubscriber = createOperatorSubscriber(subscriber, () => {\n              notifierSubscriber.unsubscribe();\n              subscribeToSource();\n            });\n            notifier.subscribe(notifierSubscriber);\n          } else {\n            subscribeToSource();\n          }\n        };\n\n        const subscribeToSource = () => {\n          let syncUnsub = false;\n          sourceSub = source.subscribe(\n            createOperatorSubscriber(subscriber, undefined, () => {\n              if (++soFar < count) {\n                if (sourceSub) {\n                  resubscribe();\n                } else {\n                  syncUnsub = true;\n                }\n              } else {\n                subscriber.complete();\n              }\n            })\n          );\n\n          if (syncUnsub) {\n            resubscribe();\n          }\n        };\n\n        subscribeToSource();\n      });\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * ![](repeatWhen.png)\n *\n * ## Example\n *\n * Repeat a message stream on click\n *\n * ```ts\n * import { of, fromEvent, repeatWhen } from 'rxjs';\n *\n * const source = of('Repeat message');\n * const documentClick$ = fromEvent(document, 'click');\n *\n * const result = source.pipe(repeatWhen(() => documentClick$));\n *\n * result.subscribe(data => console.log(data))\n * ```\n *\n * @see {@link repeat}\n * @see {@link retry}\n * @see {@link retryWhen}\n *\n * @param notifier Function that receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return A function that returns an Observable that mirrors the source\n * Observable with the exception of a `complete`.\n * @deprecated Will be removed in v9 or v10. Use {@link repeat}'s {@link RepeatConfig#delay delay} option instead.\n * Instead of `repeatWhen(() => notify$)`, use: `repeat({ delay: () => notify$ })`.\n */\nexport function repeatWhen<T>(notifier: (notifications: Observable<void>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let completions$: Subject<void>;\n    let isNotifierComplete = false;\n    let isMainComplete = false;\n\n    /**\n     * Checks to see if we can complete the result, completes it, and returns `true` if it was completed.\n     */\n    const checkComplete = () => isMainComplete && isNotifierComplete && (subscriber.complete(), true);\n    /**\n     * Gets the subject to send errors through. If it doesn't exist,\n     * we know we need to setup the notifier.\n     */\n    const getCompletionSubject = () => {\n      if (!completions$) {\n        completions$ = new Subject();\n\n        // If the call to `notifier` throws, it will be caught by the OperatorSubscriber\n        // In the main subscription -- in `subscribeForRepeatWhen`.\n        innerFrom(notifier(completions$)).subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            () => {\n              if (innerSub) {\n                subscribeForRepeatWhen();\n              } else {\n                // If we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                syncResub = true;\n              }\n            },\n            () => {\n              isNotifierComplete = true;\n              checkComplete();\n            }\n          )\n        );\n      }\n      return completions$;\n    };\n\n    const subscribeForRepeatWhen = () => {\n      isMainComplete = false;\n\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, () => {\n          isMainComplete = true;\n          // Check to see if we are complete, and complete if so.\n          // If we are not complete. Get the subject. This calls the `notifier` function.\n          // If that function fails, it will throw and `.next()` will not be reached on this\n          // line. The thrown error is caught by the _complete handler in this\n          // `OperatorSubscriber` and handled appropriately.\n          !checkComplete() && getCompletionSubject().next();\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        // It is important to null this out. Not only to free up memory, but\n        // to make sure code above knows we are in a subscribing state to\n        // handle synchronous resubscription.\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flags.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRepeatWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRepeatWhen();\n  });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { Subscription } from '../Subscription';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\nimport { timer } from '../observable/timer';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * The {@link retry} operator configuration object. `retry` either accepts a `number`\n * or an object described by this interface.\n */\nexport interface RetryConfig {\n  /**\n   * The maximum number of times to retry. If `count` is omitted, `retry` will try to\n   * resubscribe on errors infinite number of times.\n   */\n  count?: number;\n  /**\n   * The number of milliseconds to delay before retrying, OR a function to\n   * return a notifier for delaying. If a function is given, that function should\n   * return a notifier that, when it emits will retry the source. If the notifier\n   * completes _without_ emitting, the resulting observable will complete without error,\n   * if the notifier errors, the error will be pushed to the result.\n   */\n  delay?: number | ((error: any, retryCount: number) => ObservableInput<any>);\n  /**\n   * Whether or not to reset the retry counter when the retried subscription\n   * emits its first value.\n   */\n  resetOnSuccess?: boolean;\n}\n\nexport function retry<T>(count?: number): MonoTypeOperatorFunction<T>;\nexport function retry<T>(config: RetryConfig): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`.\n *\n * If the source Observable calls `error`, this method will resubscribe to the source Observable for a maximum of\n * `count` resubscriptions rather than propagating the `error` call.\n *\n * ![](retry.png)\n *\n * The number of retries is determined by the `count` parameter. It can be set either by passing a number to\n * `retry` function or by setting `count` property when `retry` is configured using {@link RetryConfig}. If\n * `count` is omitted, `retry` will try to resubscribe on errors infinite number of times.\n *\n * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those\n * emitted during failed subscriptions. For example, if an Observable fails at first but emits `[1, 2]` then\n * succeeds the second time and emits: `[1, 2, 3, 4, 5, complete]` then the complete stream of emissions and\n * notifications would be: `[1, 2, 1, 2, 3, 4, 5, complete]`.\n *\n * ## Example\n *\n * ```ts\n * import { interval, mergeMap, throwError, of, retry } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   mergeMap(val => val > 5 ? throwError(() => 'Error!') : of(val)),\n *   retry(2) // retry 2 times on error\n * );\n *\n * result.subscribe({\n *   next: value => console.log(value),\n *   error: err => console.log(`${ err }: Retried 2 times then quit!`)\n * });\n *\n * // Output:\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 0..1..2..3..4..5..\n * // 'Error!: Retried 2 times then quit!'\n * ```\n *\n * @see {@link retryWhen}\n *\n * @param configOrCount Either number of retry attempts before failing or a\n * {@link RetryConfig} object.\n * @return A function that returns an Observable that will resubscribe to the\n * source stream when the source stream errors, at most `count` times.\n */\nexport function retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T> {\n  let config: RetryConfig;\n  if (configOrCount && typeof configOrCount === 'object') {\n    config = configOrCount;\n  } else {\n    config = {\n      count: configOrCount as number,\n    };\n  }\n  const { count = Infinity, delay, resetOnSuccess: resetOnSuccess = false } = config;\n\n  return count <= 0\n    ? identity\n    : operate((source, subscriber) => {\n        let soFar = 0;\n        let innerSub: Subscription | null;\n        const subscribeForRetry = () => {\n          let syncUnsub = false;\n          innerSub = source.subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              (value) => {\n                // If we're resetting on success\n                if (resetOnSuccess) {\n                  soFar = 0;\n                }\n                subscriber.next(value);\n              },\n              // Completions are passed through to consumer.\n              undefined,\n              (err) => {\n                if (soFar++ < count) {\n                  // We are still under our retry count\n                  const resub = () => {\n                    if (innerSub) {\n                      innerSub.unsubscribe();\n                      innerSub = null;\n                      subscribeForRetry();\n                    } else {\n                      syncUnsub = true;\n                    }\n                  };\n\n                  if (delay != null) {\n                    // The user specified a retry delay.\n                    // They gave us a number, use a timer, otherwise, it's a function,\n                    // and we're going to call it to get a notifier.\n                    const notifier = typeof delay === 'number' ? timer(delay) : innerFrom(delay(err, soFar));\n                    const notifierSubscriber = createOperatorSubscriber(\n                      subscriber,\n                      () => {\n                        // After we get the first notification, we\n                        // unsubscribe from the notifier, because we don't want anymore\n                        // and we resubscribe to the source.\n                        notifierSubscriber.unsubscribe();\n                        resub();\n                      },\n                      () => {\n                        // The notifier completed without emitting.\n                        // The author is telling us they want to complete.\n                        subscriber.complete();\n                      }\n                    );\n                    notifier.subscribe(notifierSubscriber);\n                  } else {\n                    // There was no notifier given. Just resub immediately.\n                    resub();\n                  }\n                } else {\n                  // We're past our maximum number of retries.\n                  // Just send along the error.\n                  subscriber.error(err);\n                }\n              }\n            )\n          );\n          if (syncUnsub) {\n            innerSub.unsubscribe();\n            innerSub = null;\n            subscribeForRetry();\n          }\n        };\n        subscribeForRetry();\n      });\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n * calls `error`, this method will emit the Throwable that caused the error to the `ObservableInput` returned from `notifier`.\n * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n * subscription. Otherwise this method will resubscribe to the source Observable.\n *\n * ![](retryWhen.png)\n *\n * Retry an observable sequence on error based on custom criteria.\n *\n * ## Example\n *\n * ```ts\n * import { interval, map, retryWhen, tap, delayWhen, timer } from 'rxjs';\n *\n * const source = interval(1000);\n * const result = source.pipe(\n *   map(value => {\n *     if (value > 5) {\n *       // error will be picked up by retryWhen\n *       throw value;\n *     }\n *     return value;\n *   }),\n *   retryWhen(errors =>\n *     errors.pipe(\n *       // log error message\n *       tap(value => console.log(`Value ${ value } was too high!`)),\n *       // restart in 5 seconds\n *       delayWhen(value => timer(value * 1000))\n *     )\n *   )\n * );\n *\n * result.subscribe(value => console.log(value));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 'Value 6 was too high!'\n * // - Wait 5 seconds then repeat\n * ```\n *\n * @see {@link retry}\n *\n * @param notifier Function that receives an Observable of notifications with which a\n * user can `complete` or `error`, aborting the retry.\n * @return A function that returns an Observable that mirrors the source\n * Observable with the exception of an `error`.\n * @deprecated Will be removed in v9 or v10, use {@link retry}'s `delay` option instead.\n * Will be removed in v9 or v10. Use {@link retry}'s {@link RetryConfig#delay delay} option instead.\n * Instead of `retryWhen(() => notify$)`, use: `retry({ delay: () => notify$ })`.\n */\nexport function retryWhen<T>(notifier: (errors: Observable<any>) => ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null;\n    let syncResub = false;\n    let errors$: Subject<any>;\n\n    const subscribeForRetryWhen = () => {\n      innerSub = source.subscribe(\n        createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n          if (!errors$) {\n            errors$ = new Subject();\n            innerFrom(notifier(errors$)).subscribe(\n              createOperatorSubscriber(subscriber, () =>\n                // If we have an innerSub, this was an asynchronous call, kick off the retry.\n                // Otherwise, if we don't have an innerSub yet, that's because the inner subscription\n                // call hasn't even returned yet. We've arrived here synchronously.\n                // So we flag that we want to resub, such that we can ensure finalization\n                // happens before we resubscribe.\n                innerSub ? subscribeForRetryWhen() : (syncResub = true)\n              )\n            );\n          }\n          if (errors$) {\n            // We have set up the notifier without error.\n            errors$.next(err);\n          }\n        })\n      );\n\n      if (syncResub) {\n        // Ensure that the inner subscription is torn down before\n        // moving on to the next subscription in the synchronous case.\n        // If we don't do this here, all inner subscriptions will not be\n        // torn down until the entire observable is done.\n        innerSub.unsubscribe();\n        innerSub = null;\n        // We may need to do this multiple times, so reset the flag.\n        syncResub = false;\n        // Resubscribe\n        subscribeForRetryWhen();\n      }\n    };\n\n    // Start the subscription\n    subscribeForRetryWhen();\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { noop } from '../util/noop';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits the most recently emitted value from the source Observable whenever\n * another Observable, the `notifier`, emits.\n *\n * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n * the `notifier` `ObservableInput` emits something.</span>\n *\n * ![](sample.png)\n *\n * Whenever the `notifier` `ObservableInput` emits a value, `sample`\n * looks at the source Observable and emits whichever value it has most recently\n * emitted since the previous sampling, unless the source has not emitted\n * anything since the previous sampling. The `notifier` is subscribed to as soon\n * as the output Observable is subscribed.\n *\n * ## Example\n *\n * On every click, sample the most recent `seconds` timer\n *\n * ```ts\n * import { fromEvent, interval, sample } from 'rxjs';\n *\n * const seconds = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = seconds.pipe(sample(clicks));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param notifier The `ObservableInput` to use for sampling the\n * source Observable.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable whenever the notifier\n * Observable emits value or completes.\n */\nexport function sample<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let lastValue: T | null = null;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        hasValue = true;\n        lastValue = value;\n      })\n    );\n    innerFrom(notifier).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          if (hasValue) {\n            hasValue = false;\n            const value = lastValue!;\n            lastValue = null;\n            subscriber.next(value);\n          }\n        },\n        noop\n      )\n    );\n  });\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { sample } from './sample';\nimport { interval } from '../observable/interval';\n\n/**\n * Emits the most recently emitted value from the source Observable within\n * periodic time intervals.\n *\n * <span class=\"informal\">Samples the source Observable at periodic time\n * intervals, emitting what it samples.</span>\n *\n * ![](sampleTime.png)\n *\n * `sampleTime` periodically looks at the source Observable and emits whichever\n * value it has most recently emitted since the previous sampling, unless the\n * source has not emitted anything since the previous sampling. The sampling\n * happens periodically in time every `period` milliseconds (or the time unit\n * defined by the optional `scheduler` argument). The sampling starts as soon as\n * the output Observable is subscribed.\n *\n * ## Example\n *\n * Every second, emit the most recent click at most once\n *\n * ```ts\n * import { fromEvent, sampleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(sampleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param period The sampling period expressed in milliseconds or the time unit\n * determined internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the sampling.\n * @return A function that returns an Observable that emits the results of\n * sampling the values emitted by the source Observable at the specified time\n * interval.\n */\nexport function sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  return sample(interval(period, scheduler));\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { scanInternals } from './scanInternals';\n\nexport function scan<V, A = V>(accumulator: (acc: A | V, value: V, index: number) => A): OperatorFunction<V, V | A>;\nexport function scan<V, A>(accumulator: (acc: A, value: V, index: number) => A, seed: A): OperatorFunction<V, A>;\nexport function scan<V, A, S>(accumulator: (acc: A | S, value: V, index: number) => A, seed: S): OperatorFunction<V, A>;\n\n// TODO: link to a \"redux pattern\" section in the guide (location TBD)\n\n/**\n * Useful for encapsulating and managing state. Applies an accumulator (or \"reducer function\")\n * to each value from the source after an initial state is established -- either via\n * a `seed` value (second argument), or from the first value from the source.\n *\n * <span class=\"informal\">It's like {@link reduce}, but emits the current\n * accumulation state after each update</span>\n *\n * ![](scan.png)\n *\n * This operator maintains an internal state and emits it after processing each value as follows:\n *\n * 1. First value arrives\n *   - If a `seed` value was supplied (as the second argument to `scan`), let `state = seed` and `value = firstValue`.\n *   - If NO `seed` value was supplied (no second argument), let `state = firstValue` and go to 3.\n * 2. Let `state = accumulator(state, value)`.\n *   - If an error is thrown by `accumulator`, notify the consumer of an error. The process ends.\n * 3. Emit `state`.\n * 4. Next value arrives, let `value = nextValue`, go to 2.\n *\n * ## Examples\n *\n * An average of previous numbers. This example shows how\n * not providing a `seed` can prime the stream with the\n * first value from the source.\n *\n * ```ts\n * import { of, scan, map } from 'rxjs';\n *\n * const numbers$ = of(1, 2, 3);\n *\n * numbers$\n *   .pipe(\n *     // Get the sum of the numbers coming in.\n *     scan((total, n) => total + n),\n *     // Get the average by dividing the sum by the total number\n *     // received so far (which is 1 more than the zero-based index).\n *     map((sum, index) => sum / (index + 1))\n *   )\n *   .subscribe(console.log);\n * ```\n *\n * The Fibonacci sequence. This example shows how you can use\n * a seed to prime accumulation process. Also... you know... Fibonacci.\n * So important to like, computers and stuff that its whiteboarded\n * in job interviews. Now you can show them the Rx version! (Please don't, haha)\n *\n * ```ts\n * import { interval, scan, map, startWith } from 'rxjs';\n *\n * const firstTwoFibs = [0, 1];\n * // An endless stream of Fibonacci numbers.\n * const fibonacci$ = interval(1000).pipe(\n *   // Scan to get the fibonacci numbers (after 0, 1)\n *   scan(([a, b]) => [b, a + b], firstTwoFibs),\n *   // Get the second number in the tuple, it's the one you calculated\n *   map(([, n]) => n),\n *   // Start with our first two digits :)\n *   startWith(...firstTwoFibs)\n * );\n *\n * fibonacci$.subscribe(console.log);\n * ```\n *\n * @see {@link expand}\n * @see {@link mergeScan}\n * @see {@link reduce}\n * @see {@link switchScan}\n *\n * @param accumulator A \"reducer function\". This will be called for each value after an initial state is\n * acquired.\n * @param seed The initial state. If this is not provided, the first value from the source will\n * be used as the initial state, and emitted without going through the accumulator. All subsequent values\n * will be processed by the accumulator function. If this is provided, all values will go through\n * the accumulator function.\n * @return A function that returns an Observable of the accumulated values.\n */\nexport function scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A> {\n  // providing a seed of `undefined` *should* be valid and trigger\n  // hasSeed! so don't use `seed !== undefined` checks!\n  // For this reason, we have to check it here at the original call site\n  // otherwise inside Operator/Subscriber we won't know if `undefined`\n  // means they didn't provide anything or if they literally provided `undefined`\n  return operate(scanInternals(accumulator, seed as S, arguments.length >= 2, true));\n}\n", "import { OperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Compares all values of two observables in sequence using an optional comparator function\n * and returns an observable of a single boolean value representing whether or not the two sequences\n * are equal.\n *\n * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n *\n * ![](sequenceEqual.png)\n *\n * `sequenceEqual` subscribes to source observable and `compareTo` `ObservableInput` (that internally\n * gets converted to an observable) and buffers incoming values from each observable. Whenever either\n * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n * observables completes, the operator will wait for the other observable to complete; If the other\n * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n * completes or emits after the other completes, the returned observable will never complete.\n *\n * ## Example\n *\n * Figure out if the Konami code matches\n *\n * ```ts\n * import { from, fromEvent, map, bufferCount, mergeMap, sequenceEqual } from 'rxjs';\n *\n * const codes = from([\n *   'ArrowUp',\n *   'ArrowUp',\n *   'ArrowDown',\n *   'ArrowDown',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'ArrowLeft',\n *   'ArrowRight',\n *   'KeyB',\n *   'KeyA',\n *   'Enter', // no start key, clearly.\n * ]);\n *\n * const keys = fromEvent<KeyboardEvent>(document, 'keyup').pipe(map(e => e.code));\n * const matches = keys.pipe(\n *   bufferCount(11, 1),\n *   mergeMap(last11 => from(last11).pipe(sequenceEqual(codes)))\n * );\n * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n * ```\n *\n * @see {@link combineLatest}\n * @see {@link zip}\n * @see {@link withLatestFrom}\n *\n * @param compareTo The `ObservableInput` sequence to compare the source sequence to.\n * @param comparator An optional function to compare each value pair.\n *\n * @return A function that returns an Observable that emits a single boolean\n * value representing whether or not the values emitted by the source\n * Observable and provided `ObservableInput` were equal in sequence.\n */\nexport function sequenceEqual<T>(\n  compareTo: ObservableInput<T>,\n  comparator: (a: T, b: T) => boolean = (a, b) => a === b\n): OperatorFunction<T, boolean> {\n  return operate((source, subscriber) => {\n    // The state for the source observable\n    const aState = createState<T>();\n    // The state for the compareTo observable;\n    const bState = createState<T>();\n\n    /** A utility to emit and complete */\n    const emit = (isEqual: boolean) => {\n      subscriber.next(isEqual);\n      subscriber.complete();\n    };\n\n    /**\n     * Creates a subscriber that subscribes to one of the sources, and compares its collected\n     * state -- `selfState` -- to the other source's collected state -- `otherState`. This\n     * is used for both streams.\n     */\n    const createSubscriber = (selfState: SequenceState<T>, otherState: SequenceState<T>) => {\n      const sequenceEqualSubscriber = createOperatorSubscriber(\n        subscriber,\n        (a: T) => {\n          const { buffer, complete } = otherState;\n          if (buffer.length === 0) {\n            // If there's no values in the other buffer\n            // and the other stream is complete, we know\n            // this isn't a match, because we got one more value.\n            // Otherwise, we push onto our buffer, so when the other\n            // stream emits, it can pull this value off our buffer and check it\n            // at the appropriate time.\n            complete ? emit(false) : selfState.buffer.push(a);\n          } else {\n            // If the other stream *does* have values in its buffer,\n            // pull the oldest one off so we can compare it to what we\n            // just got. If it wasn't a match, emit `false` and complete.\n            !comparator(a, buffer.shift()!) && emit(false);\n          }\n        },\n        () => {\n          // Or observable completed\n          selfState.complete = true;\n          const { complete, buffer } = otherState;\n          // If the other observable is also complete, and there's\n          // still stuff left in their buffer, it doesn't match, if their\n          // buffer is empty, then it does match. This is because we can't\n          // possibly get more values here anymore.\n          complete && emit(buffer.length === 0);\n          // Be sure to clean up our stream as soon as possible if we can.\n          sequenceEqualSubscriber?.unsubscribe();\n        }\n      );\n\n      return sequenceEqualSubscriber;\n    };\n\n    // Subscribe to each source.\n    source.subscribe(createSubscriber(aState, bState));\n    innerFrom(compareTo).subscribe(createSubscriber(bState, aState));\n  });\n}\n\n/**\n * A simple structure for the data used to test each sequence\n */\ninterface SequenceState<T> {\n  /** A temporary store for arrived values before they are checked */\n  buffer: T[];\n  /** Whether or not the sequence source has completed. */\n  complete: boolean;\n}\n\n/**\n * Creates a simple structure that is used to represent\n * data used to test each sequence.\n */\nfunction createState<T>(): SequenceState<T> {\n  return {\n    buffer: [],\n    complete: false,\n  };\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n", "import { ReplaySubject } from '../ReplaySubject';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { share } from './share';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\n * but an errored source can be retried.\n *\n * ## Why use `shareReplay`?\n *\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ## Reference counting\n *\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\n * (and potentially run for ever).\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\n * observables which we want to keep running instead of having to do the expensive setup again.\n *\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\n * happens when the operators internal reference counter drops to zero.\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\n *\n * ## Examples\n *\n * Example with a third subscriber coming late to the party\n *\n * ```ts\n * import { interval, take, shareReplay } from 'rxjs';\n *\n * const shared$ = interval(2000).pipe(\n *   take(6),\n *   shareReplay(3)\n * );\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * setTimeout(() => {\n *   shared$.subscribe(y => console.log('sub C: ', y));\n * }, 11000);\n *\n * // Logs:\n * // (after ~2000 ms)\n * // sub A: 0\n * // sub B: 0\n * // (after ~4000 ms)\n * // sub A: 1\n * // sub B: 1\n * // (after ~6000 ms)\n * // sub A: 2\n * // sub B: 2\n * // (after ~8000 ms)\n * // sub A: 3\n * // sub B: 3\n * // (after ~10000 ms)\n * // sub A: 4\n * // sub B: 4\n * // (after ~11000 ms, sub C gets the last 3 values)\n * // sub C: 2\n * // sub C: 3\n * // sub C: 4\n * // (after ~12000 ms)\n * // sub A: 5\n * // sub B: 5\n * // sub C: 5\n * ```\n *\n * Example for `refCount` usage\n *\n * ```ts\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\n *\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\n *   tap({\n *     subscribe: () => console.log(`${ name }: subscribed`),\n *     next: value => console.log(`${ name }: ${ value }`),\n *     complete: () => console.log(`${ name }: completed`),\n *     finalize: () => console.log(`${ name }: unsubscribed`)\n *   })\n * );\n *\n * const obs$ = log('source', interval(1000));\n *\n * const shared$ = log('shared', obs$.pipe(\n *   shareReplay({ bufferSize: 1, refCount: true }),\n *   take(2)\n * ));\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * // PRINTS:\n * // shared: subscribed <-- reference count = 1\n * // source: subscribed\n * // shared: subscribed <-- reference count = 2\n * // source: 0\n * // shared: 0\n * // sub A: 0\n * // shared: 0\n * // sub B: 0\n * // source: 1\n * // shared: 1\n * // sub A: 1\n * // shared: completed <-- take(2) completes the subscription for sub A\n * // shared: unsubscribed <-- reference count = 1\n * // shared: 1\n * // sub B: 1\n * // shared: completed <-- take(2) completes the subscription for sub B\n * // shared: unsubscribed <-- reference count = 0\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\n *\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\n * // are listening.\n * // source: 2\n * // source: 3\n * // source: 4\n * // ...\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\n * object.\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\n * @param scheduler Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return A function that returns an Observable sequence that contains the\n * elements of a sequence produced by multicasting the source sequence within a\n * selector function.\n */\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let bufferSize: number;\n  let refCount = false;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n  } else {\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\n  }\n  return share<T>({\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n    resetOnError: true,\n    resetOnComplete: false,\n    resetOnRefCountZero: refCount,\n  });\n}\n", "import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\n\nimport { MonoTypeOperatorFunction, OperatorFunction, TruthyTypesOf } from '../types';\nimport { SequenceError } from '../util/SequenceError';\nimport { NotFoundError } from '../util/NotFoundError';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function single<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that asserts that only one value is\n * emitted from the observable that matches the predicate. If no\n * predicate is provided, then it will assert that the observable\n * only emits one value.\n *\n * If the source Observable did not emit `next` before completion, it\n * will emit an {@link EmptyError} to the Observer's `error` callback.\n *\n * In the event that two values are found that match the predicate,\n * or when there are two values emitted and no predicate, it will\n * emit a {@link SequenceError} to the Observer's `error` callback.\n *\n * In the event that no values match the predicate, if one is provided,\n * it will emit a {@link NotFoundError} to the Observer's `error` callback.\n *\n * ## Example\n *\n * Expect only `name` beginning with `'B'`\n *\n * ```ts\n * import { of, single } from 'rxjs';\n *\n * const source1 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Laney' },\n *  { name: 'Lily' }\n * );\n *\n * source1\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe(x => console.log(x));\n * // Emits 'Ben'\n *\n *\n * const source2 = of(\n *  { name: 'Ben' },\n *  { name: 'Tracy' },\n *  { name: 'Bradley' },\n *  { name: 'Lincoln' }\n * );\n *\n * source2\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: SequenceError('Too many values match')\n *\n *\n * const source3 = of(\n *  { name: 'Laney' },\n *  { name: 'Tracy' },\n *  { name: 'Lily' },\n *  { name: 'Lincoln' }\n * );\n *\n * source3\n *   .pipe(single(x => x.name.startsWith('B')))\n *   .subscribe({ error: err => console.error(err) });\n * // Error emitted: NotFoundError('No values match')\n * ```\n *\n * @see {@link first}\n * @see {@link find}\n * @see {@link findIndex}\n * @see {@link elementAt}\n *\n * @throws {NotFoundError} Delivers a `NotFoundError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * @throws {SequenceError} Delivers a `SequenceError` if more than one value is\n * emitted that matches the provided predicate. If no predicate is provided, it\n * will deliver a `SequenceError` if more than one value comes from the source.\n * @throws {EmptyError} Delivers an `EmptyError` if no values were `next`ed prior\n * to completion.\n *\n * @param predicate A predicate function to evaluate items emitted by the source\n * Observable.\n * @return A function that returns an Observable that emits the single item\n * emitted by the source Observable that matches the predicate.\n */\nexport function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    let singleValue: T;\n    let seenValue = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          seenValue = true;\n          if (!predicate || predicate(value, index++, source)) {\n            hasValue && subscriber.error(new SequenceError('Too many matching values'));\n            hasValue = true;\n            singleValue = value;\n          }\n        },\n        () => {\n          if (hasValue) {\n            subscriber.next(singleValue);\n            subscriber.complete();\n          } else {\n            subscriber.error(seenValue ? new NotFoundError('No matching values') : new EmptyError());\n          }\n        }\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { filter } from './filter';\n\n/**\n * Returns an Observable that skips the first `count` items emitted by the source Observable.\n *\n * ![](skip.png)\n *\n * Skips the values until the sent notifications are equal or less than provided skip count. It raises\n * an error if skip count is equal or more than the actual number of emits and source raises an error.\n *\n * ## Example\n *\n * Skip the values before the emission\n *\n * ```ts\n * import { interval, skip } from 'rxjs';\n *\n * // emit every half second\n * const source = interval(500);\n * // skip the first 10 emitted values\n * const result = source.pipe(skip(10));\n *\n * result.subscribe(value => console.log(value));\n * // output: 10...11...12...13...\n * ```\n *\n * @see {@link last}\n * @see {@link skipWhile}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param count The number of times, items emitted by source Observable should be skipped.\n * @return A function that returns an Observable that skips the first `count`\n * values emitted by the source Observable.\n */\nexport function skip<T>(count: number): MonoTypeOperatorFunction<T> {\n  return filter((_, index) => count <= index);\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Skip a specified number of values before the completion of an observable.\n *\n * ![](skipLast.png)\n *\n * Returns an observable that will emit values as soon as it can, given a number of\n * skipped values. For example, if you `skipLast(3)` on a source, when the source\n * emits its fourth value, the first value the source emitted will finally be emitted\n * from the returned observable, as it is no longer part of what needs to be skipped.\n *\n * All values emitted by the result of `skipLast(N)` will be delayed by `N` emissions,\n * as each value is held in a buffer until enough values have been emitted that that\n * the buffered value may finally be sent to the consumer.\n *\n * After subscribing, unsubscribing will not result in the emission of the buffered\n * skipped values.\n *\n * ## Example\n *\n * Skip the last 2 values of an observable with many values\n *\n * ```ts\n * import { of, skipLast } from 'rxjs';\n *\n * const numbers = of(1, 2, 3, 4, 5);\n * const skipLastTwo = numbers.pipe(skipLast(2));\n * skipLastTwo.subscribe(x => console.log(x));\n *\n * // Results in:\n * // 1 2 3\n * // (4 and 5 are skipped)\n * ```\n *\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipWhile}\n * @see {@link take}\n *\n * @param skipCount Number of elements to skip from the end of the source Observable.\n * @return A function that returns an Observable that skips the last `count`\n * values emitted by the source Observable.\n */\nexport function skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T> {\n  return skipCount <= 0\n    ? // For skipCounts less than or equal to zero, we are just mirroring the source.\n      identity\n    : operate((source, subscriber) => {\n        // A ring buffer to hold the values while we wait to see\n        // if we can emit it or it's part of the \"skipped\" last values.\n        // Note that it is the _same size_ as the skip count.\n        let ring: T[] = new Array(skipCount);\n        // The number of values seen so far. This is used to get\n        // the index of the current value when it arrives.\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Get the index of the value we have right now\n            // relative to all other values we've seen, then\n            // increment `seen`. This ensures we've moved to\n            // the next slot in our ring buffer.\n            const valueIndex = seen++;\n            if (valueIndex < skipCount) {\n              // If we haven't seen enough values to fill our buffer yet,\n              // Then we aren't to a number of seen values where we can\n              // emit anything, so let's just start by filling the ring buffer.\n              ring[valueIndex] = value;\n            } else {\n              // We are traversing over the ring array in such\n              // a way that when we get to the end, we loop back\n              // and go to the start.\n              const index = valueIndex % skipCount;\n              // Pull the oldest value out so we can emit it,\n              // and stuff the new value in it's place.\n              const oldValue = ring[index];\n              ring[index] = value;\n              // Emit the old value. It is important that this happens\n              // after we swap the value in the buffer, if it happens\n              // before we swap the value in the buffer, then a synchronous\n              // source can get the buffer out of whack.\n              subscriber.next(oldValue);\n            }\n          })\n        );\n\n        return () => {\n          // Release our values in memory\n          ring = null!;\n        };\n      });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n *\n * The `skipUntil` operator causes the observable stream to skip the emission of values until the passed in observable\n * emits the first value. This can be particularly useful in combination with user interactions, responses of HTTP\n * requests or waiting for specific times to pass by.\n *\n * ![](skipUntil.png)\n *\n * Internally, the `skipUntil` operator subscribes to the passed in `notifier` `ObservableInput` (which gets converted\n * to an Observable) in order to recognize the emission of its first value. When `notifier` emits next, the operator\n * unsubscribes from it and starts emitting the values of the *source* observable until it completes or errors. It\n * will never let the *source* observable emit any values if the `notifier` completes or throws an error without\n * emitting a value before.\n *\n * ## Example\n *\n * In the following example, all emitted values of the interval observable are skipped until the user clicks anywhere\n * within the page\n *\n * ```ts\n * import { interval, fromEvent, skipUntil } from 'rxjs';\n *\n * const intervalObservable = interval(1000);\n * const click = fromEvent(document, 'click');\n *\n * const emitAfterClick = intervalObservable.pipe(\n *   skipUntil(click)\n * );\n * // clicked at 4.6s. output: 5...6...7...8........ or\n * // clicked at 7.3s. output: 8...9...10..11.......\n * emitAfterClick.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipWhile}\n * @see {@link skipLast}\n *\n * @param notifier An `ObservableInput` that has to emit an item before the source Observable elements begin to\n * be mirrored by the resulting Observable.\n * @return A function that returns an Observable that skips items from the\n * source Observable until the `notifier` Observable emits an item, then emits the\n * remaining items.\n */\nexport function skipUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n\n    const skipSubscriber = createOperatorSubscriber(\n      subscriber,\n      () => {\n        skipSubscriber?.unsubscribe();\n        taking = true;\n      },\n      noop\n    );\n\n    innerFrom(notifier).subscribe(skipSubscriber);\n\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => taking && subscriber.next(value)));\n  });\n}\n", "import { Falsy, MonoTypeOperatorFunction, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function skipWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, Extract<T, Falsy> extends never ? never : T>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => true): OperatorFunction<T, never>;\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n * true, but emits all further source items as soon as the condition becomes false.\n *\n * ![](skipWhile.png)\n *\n * Skips all the notifications with a truthy predicate. It will not skip the notifications when the predicate is falsy.\n * It can also be skipped using index. Once the predicate is true, it will not be called again.\n *\n * ## Example\n *\n * Skip some super heroes\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from(['Green Arrow', 'SuperMan', 'Flash', 'SuperGirl', 'Black Canary'])\n * // Skip the heroes until SuperGirl\n * const example = source.pipe(skipWhile(hero => hero !== 'SuperGirl'));\n * // output: SuperGirl, Black Canary\n * example.subscribe(femaleHero => console.log(femaleHero));\n * ```\n *\n * Skip values from the array until index 5\n *\n * ```ts\n * import { from, skipWhile } from 'rxjs';\n *\n * const source = from([1, 2, 3, 4, 5, 6, 7, 9, 10]);\n * const example = source.pipe(skipWhile((_, i) => i !== 5));\n * // output: 6, 7, 9, 10\n * example.subscribe(value => console.log(value));\n * ```\n *\n * @see {@link last}\n * @see {@link skip}\n * @see {@link skipUntil}\n * @see {@link skipLast}\n *\n * @param predicate A function to test each item emitted from the source Observable.\n * @return A function that returns an Observable that begins emitting items\n * emitted by the source Observable when the specified predicate becomes false.\n */\nexport function skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let taking = false;\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => (taking || (taking = !predicate(value, index++))) && subscriber.next(value))\n    );\n  });\n}\n", "import { concat } from '../observable/concat';\nimport { OperatorFunction, SchedulerLike, ValueFromArray } from '../types';\nimport { popScheduler } from '../util/args';\nimport { operate } from '../util/lift';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function startWith<T>(value: null): OperatorFunction<T, T | null>;\nexport function startWith<T>(value: undefined): OperatorFunction<T, T | undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `concatAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function startWith<T, A extends readonly unknown[] = T[]>(\n  ...valuesAndScheduler: [...A, SchedulerLike]\n): OperatorFunction<T, T | ValueFromArray<A>>;\nexport function startWith<T, A extends readonly unknown[] = T[]>(...values: A): OperatorFunction<T, T | ValueFromArray<A>>;\n\n/**\n * Returns an observable that, at the moment of subscription, will synchronously emit all\n * values provided to this operator, then subscribe to the source and mirror all of its emissions\n * to subscribers.\n *\n * This is a useful way to know when subscription has occurred on an existing observable.\n *\n * <span class=\"informal\">First emits its arguments in order, and then any\n * emissions from the source.</span>\n *\n * ![](startWith.png)\n *\n * ## Examples\n *\n * Emit a value when a timer starts.\n *\n * ```ts\n * import { timer, map, startWith } from 'rxjs';\n *\n * timer(1000)\n *   .pipe(\n *     map(() => 'timer emit'),\n *     startWith('timer start')\n *   )\n *   .subscribe(x => console.log(x));\n *\n * // results:\n * // 'timer start'\n * // 'timer emit'\n * ```\n *\n * @param values Items you want the modified Observable to emit first.\n * @return A function that returns an Observable that synchronously emits\n * provided values before subscribing to the source Observable.\n *\n * @see {@link endWith}\n * @see {@link finalize}\n * @see {@link concat}\n */\nexport function startWith<T, D>(...values: D[]): OperatorFunction<T, T | D> {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    // Here we can't pass `undefined` as a scheduler, because if we did, the\n    // code inside of `concat` would be confused by the `undefined`, and treat it\n    // like an invalid observable. So we have to split it two different ways.\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n", "import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n", "import { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { switchMap } from './switchMap';\nimport { identity } from '../util/identity';\n\n/**\n * Converts a higher-order Observable into a first-order Observable\n * producing values only from the most recent observable sequence\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](switchAll.png)\n *\n * `switchAll` subscribes to a source that is an observable of observables, also known as a\n * \"higher-order observable\" (or `Observable<Observable<T>>`). It subscribes to the most recently\n * provided \"inner observable\" emitted by the source, unsubscribing from any previously subscribed\n * to inner observable, such that only the most recent inner observable may be subscribed to at\n * any point in time. The resulting observable returned by `switchAll` will only complete if the\n * source observable completes, *and* any currently subscribed to inner observable also has completed,\n * if there are any.\n *\n * ## Examples\n *\n * Spawn a new interval observable for each click event, but for every new\n * click, cancel the previous interval and subscribe to the new one\n *\n * ```ts\n * import { fromEvent, tap, map, interval, switchAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));\n * const source = clicks.pipe(map(() => interval(1000)));\n *\n * source\n *   .pipe(switchAll())\n *   .subscribe(x => console.log(x));\n *\n * // Output\n * // click\n * // 0\n * // 1\n * // 2\n * // 3\n * // ...\n * // click\n * // 0\n * // 1\n * // 2\n * // ...\n * // click\n * // ...\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link switchMap}\n * @see {@link switchMapTo}\n * @see {@link mergeAll}\n *\n * @return A function that returns an Observable that converts a higher-order\n * Observable into a first-order Observable producing values only from the most\n * recent Observable sequence.\n */\nexport function switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return switchMap(identity);\n}\n", "import { switchMap } from './switchMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/** @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)` */\nexport function switchMapTo<O extends ObservableInput<unknown>>(observable: O): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: undefined\n): OperatorFunction<unknown, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  observable: O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n\n/**\n * Projects each source value to the same Observable which is flattened multiple\n * times with {@link switchMap} in the output Observable.\n *\n * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n * always to the same inner Observable.</span>\n *\n * ![](switchMapTo.png)\n *\n * Maps each source value to the given Observable `innerObservable` regardless\n * of the source value, and then flattens those resulting Observables into one\n * single Observable, which is the output Observable. The output Observables\n * emits values only from the most recently emitted instance of\n * `innerObservable`.\n *\n * ## Example\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMapTo, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMapTo(interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMapTo}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link mergeMapTo}\n *\n * @param innerObservable An `ObservableInput` to replace each value from the\n * source Observable.\n * @return A function that returns an Observable that emits items from the\n * given `innerObservable` (and optionally transformed through the deprecated\n * `resultSelector`) every time a value is emitted on the source Observable,\n * and taking only the values from the most recently projected inner\n * Observable.\n * @deprecated Will be removed in v9. Use {@link switchMap} instead: `switchMap(() => result)`\n */\nexport function switchMapTo<T, R, O extends ObservableInput<unknown>>(\n  innerObservable: O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? switchMap(() => innerObservable, resultSelector) : switchMap(() => innerObservable);\n}\n", "import { ObservableInput, ObservedValueOf, OperatorFunction } from '../types';\nimport { switchMap } from './switchMap';\nimport { operate } from '../util/lift';\n\n// TODO: Generate a marble diagram for these docs.\n\n/**\n * Applies an accumulator function over the source Observable where the\n * accumulator function itself returns an Observable, emitting values\n * only from the most recently returned Observable.\n *\n * <span class=\"informal\">It's like {@link mergeScan}, but only the most recent\n * Observable returned by the accumulator is merged into the outer Observable.</span>\n *\n * @see {@link scan}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param accumulator\n * The accumulator function called on each source value.\n * @param seed The initial accumulation value.\n * @return A function that returns an observable of the accumulated values.\n */\nexport function switchScan<T, R, O extends ObservableInput<any>>(\n  accumulator: (acc: R, value: T, index: number) => O,\n  seed: R\n): OperatorFunction<T, ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    // The state we will keep up to date to pass into our\n    // accumulator function at each new value from the source.\n    let state = seed;\n\n    // Use `switchMap` on our `source` to do the work of creating\n    // this operator. Note the backwards order here of `switchMap()(source)`\n    // to avoid needing to use `pipe` unnecessarily\n    switchMap(\n      // On each value from the source, call the accumulator with\n      // our previous state, the value and the index.\n      (value: T, index) => accumulator(state, value, index),\n      // Using the deprecated result selector here as a dirty trick\n      // to update our state with the flattened value.\n      (_, innerValue) => ((state = innerValue), innerValue)\n    )(source).subscribe(subscriber);\n\n    return () => {\n      // Release state on finalization\n      state = null!;\n    };\n  });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param notifier The `ObservableInput` whose first emitted value will cause the output\n * Observable of `takeUntil` to stop emitting values from the source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: true): MonoTypeOperatorFunction<T>;\nexport function takeWhile<T>(predicate: BooleanConstructor, inclusive: false): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function takeWhile<T, S extends T>(predicate: (value: T, index: number) => value is S, inclusive: false): OperatorFunction<T, S>;\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive?: boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Emits values emitted by the source Observable so long as each value satisfies\n * the given `predicate`, and then completes as soon as this `predicate` is not\n * satisfied.\n *\n * <span class=\"informal\">Takes values from the source only while they pass the\n * condition given. When the first value does not satisfy, it completes.</span>\n *\n * ![](takeWhile.png)\n *\n * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n * emitted on the source is given to the `predicate` function which returns a\n * boolean, representing a condition to be satisfied by the source values. The\n * output Observable emits the source values until such time as the `predicate`\n * returns false, at which point `takeWhile` stops mirroring the source\n * Observable and completes the output Observable.\n *\n * ## Example\n *\n * Emit click events only while the clientX property is greater than 200\n *\n * ```ts\n * import { fromEvent, takeWhile } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const result = clicks.pipe(takeWhile(ev => ev.clientX > 200));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link skip}\n *\n * @param predicate A function that evaluates a value emitted by the source\n * Observable and returns a boolean. Also takes the (zero-based) index as the\n * second argument.\n * @param inclusive When set to `true` the value that caused `predicate` to\n * return `false` will also be emitted.\n * @return A function that returns an Observable that emits values from the\n * source Observable so long as each value satisfies the condition defined by\n * the `predicate`, then completes.\n */\nexport function takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive = false): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const result = predicate(value, index++);\n        (result || inclusive) && subscriber.next(value);\n        !result && subscriber.complete();\n      })\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n", "import { Subscription } from '../Subscription';\n\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * An object interface used by {@link throttle} or {@link throttleTime} that ensure\n * configuration options of these operators.\n *\n * @see {@link throttle}\n * @see {@link throttleTime}\n */\nexport interface ThrottleConfig {\n  /**\n   * If `true`, the resulting Observable will emit the first value from the source\n   * Observable at the **start** of the \"throttling\" process (when starting an\n   * internal timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the first value from the source Observable at the\n   * start of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `true`.\n   */\n  leading?: boolean;\n  /**\n   * If `true`, the resulting Observable will emit the last value from the source\n   * Observable at the **end** of the \"throttling\" process (when ending an internal\n   * timer that prevents other emissions from the source to pass through).\n   * If `false`, it will not emit the last value from the source Observable at the\n   * end of the \"throttling\" process.\n   *\n   * If not provided, defaults to: `false`.\n   */\n  trailing?: boolean;\n}\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for a duration determined by another Observable, then repeats this\n * process.\n *\n * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n * duration is determined by a second Observable.</span>\n *\n * ![](throttle.svg)\n *\n * `throttle` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled by calling the `durationSelector` function with the source value,\n * which returns the \"duration\" Observable. When the duration Observable emits a\n * value, the timer is disabled, and this process repeats for the\n * next source value.\n *\n * ## Example\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttle, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttle(() => interval(1000)));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link audit}\n * @see {@link debounce}\n * @see {@link delayWhen}\n * @see {@link sample}\n * @see {@link throttleTime}\n *\n * @param durationSelector A function that receives a value from the source\n * Observable, for computing the silencing duration for each source value,\n * returned as an `ObservableInput`.\n * @param config A configuration object to define `leading` and `trailing`\n * behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttle<T>(durationSelector: (value: T) => ObservableInput<any>, config?: ThrottleConfig): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    const { leading = true, trailing = false } = config ?? {};\n    let hasValue = false;\n    let sendValue: T | null = null;\n    let throttled: Subscription | null = null;\n    let isComplete = false;\n\n    const endThrottling = () => {\n      throttled?.unsubscribe();\n      throttled = null;\n      if (trailing) {\n        send();\n        isComplete && subscriber.complete();\n      }\n    };\n\n    const cleanupThrottling = () => {\n      throttled = null;\n      isComplete && subscriber.complete();\n    };\n\n    const startThrottle = (value: T) =>\n      (throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling)));\n\n    const send = () => {\n      if (hasValue) {\n        // Ensure we clear out our value and hasValue flag\n        // before we emit, otherwise reentrant code can cause\n        // issues here.\n        hasValue = false;\n        const value = sendValue!;\n        sendValue = null;\n        // Emit the value.\n        subscriber.next(value);\n        !isComplete && startThrottle(value);\n      }\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        // Regarding the presence of throttled.closed in the following\n        // conditions, if a synchronous duration selector is specified - weird,\n        // but legal - an already-closed subscription will be assigned to\n        // throttled, so the subscription's closed property needs to be checked,\n        // too.\n        (value) => {\n          hasValue = true;\n          sendValue = value;\n          !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));\n        },\n        () => {\n          isComplete = true;\n          !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { throttle, ThrottleConfig } from './throttle';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { timer } from '../observable/timer';\n\n/**\n * Emits a value from the source Observable, then ignores subsequent source\n * values for `duration` milliseconds, then repeats this process.\n *\n * <span class=\"informal\">Lets a value pass, then ignores source values for the\n * next `duration` milliseconds.</span>\n *\n * ![](throttleTime.png)\n *\n * `throttleTime` emits the source Observable values on the output Observable\n * when its internal timer is disabled, and ignores source values when the timer\n * is enabled. Initially, the timer is disabled. As soon as the first source\n * value arrives, it is forwarded to the output Observable, and then the timer\n * is enabled. After `duration` milliseconds (or the time unit determined\n * internally by the optional `scheduler`) has passed, the timer is disabled,\n * and this process repeats for the next source value. Optionally takes a\n * {@link SchedulerLike} for managing timers.\n *\n * ## Examples\n *\n * ### Limit click rate\n *\n * Emit clicks at a rate of at most one click per second\n *\n * ```ts\n * import { fromEvent, throttleTime } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(throttleTime(1000));\n *\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link auditTime}\n * @see {@link debounceTime}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttle}\n *\n * @param duration Time to wait before emitting another value after\n * emitting the last value, measured in milliseconds or the time unit determined\n * internally by the optional `scheduler`.\n * @param scheduler The {@link SchedulerLike} to use for\n * managing the timers that handle the throttling. Defaults to {@link asyncScheduler}.\n * @param config A configuration object to define `leading` and\n * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.\n * @return A function that returns an Observable that performs the throttle\n * operation to limit the rate of emissions from the source.\n */\nexport function throttleTime<T>(\n  duration: number,\n  scheduler: SchedulerLike = asyncScheduler,\n  config?: ThrottleConfig\n): MonoTypeOperatorFunction<T> {\n  const duration$ = timer(duration, scheduler);\n  return throttle(() => duration$, config);\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { SchedulerLike, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits an object containing the current value, and the time that has\n * passed between emitting the current value and the previous value, which is\n * calculated by using the provided `scheduler`'s `now()` method to retrieve\n * the current time at each emission, then calculating the difference. The `scheduler`\n * defaults to {@link asyncScheduler}, so by default, the `interval` will be in\n * milliseconds.\n *\n * <span class=\"informal\">Convert an Observable that emits items into one that\n * emits indications of the amount of time elapsed between those emissions.</span>\n *\n * ![](timeInterval.png)\n *\n * ## Example\n *\n * Emit interval between current value with the last value\n *\n * ```ts\n * import { interval, timeInterval } from 'rxjs';\n *\n * const seconds = interval(1000);\n *\n * seconds\n *   .pipe(timeInterval())\n *   .subscribe(value => console.log(value));\n *\n * // NOTE: The values will never be this precise,\n * // intervals created with `interval` or `setInterval`\n * // are non-deterministic.\n *\n * // { value: 0, interval: 1000 }\n * // { value: 1, interval: 1000 }\n * // { value: 2, interval: 1000 }\n * ```\n *\n * @param scheduler Scheduler used to get the current time.\n * @return A function that returns an Observable that emits information about\n * value and interval.\n */\nexport function timeInterval<T>(scheduler: SchedulerLike = asyncScheduler): OperatorFunction<T, TimeInterval<T>> {\n  return operate((source, subscriber) => {\n    let last = scheduler.now();\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const now = scheduler.now();\n        const interval = now - last;\n        last = now;\n        subscriber.next(new TimeInterval(value, interval));\n      })\n    );\n  });\n}\n\n// TODO(benlesh): make this an interface, export the interface, but not the implemented class,\n// there's no reason users should be manually creating this type.\n\nexport class TimeInterval<T> {\n  /**\n   * @deprecated Internal implementation detail, do not construct directly. Will be made an interface in v8.\n   */\n  constructor(public value: T, public interval: number) {}\n}\n", "import { async } from '../scheduler/async';\nimport { isValidDate } from '../util/isDate';\nimport { ObservableInput, OperatorFunction, SchedulerLike } from '../types';\nimport { timeout } from './timeout';\n\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(someDate, a$, scheduler)`, use the configuration object\n * `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(dueBy: Date, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n/** @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use the configuration object\n *  `timeout({ each: 100, with: () => a$, scheduler })`. Will be removed in v8. */\nexport function timeoutWith<T, R>(waitFor: number, switchTo: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>;\n\n/**\n * When the passed timespan elapses before the source emits any given value, it will unsubscribe from the source,\n * and switch the subscription to another observable.\n *\n * <span class=\"informal\">Used to switch to a different observable if your source is being slow.</span>\n *\n * Useful in cases where:\n *\n * - You want to switch to a different source that may be faster.\n * - You want to notify a user that the data stream is slow.\n * - You want to emit a custom error rather than the {@link TimeoutError} emitted\n *   by the default usage of {@link timeout}.\n *\n * If the first parameter is passed as Date and the time of the Date arrives before the first value arrives from the source,\n * it will unsubscribe from the source and switch the subscription to another observable.\n *\n * <span class=\"informal\">Use Date object to switch to a different observable if the first value doesn't arrive by a specific time.</span>\n *\n * Can be used to set a timeout only for the first value, however it's recommended to use the {@link timeout} operator with\n * the `first` configuration to get the same effect.\n *\n * ## Examples\n *\n * Fallback to a faster observable\n *\n * ```ts\n * import { interval, timeoutWith } from 'rxjs';\n *\n * const slow$ = interval(1000);\n * const faster$ = interval(500);\n *\n * slow$\n *   .pipe(timeoutWith(900, faster$))\n *   .subscribe(console.log);\n * ```\n *\n * Emit your own custom timeout error\n *\n * ```ts\n * import { interval, timeoutWith, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(1000);\n *\n * slow$\n *   .pipe(timeoutWith(900, throwError(() => new CustomTimeoutError())))\n *   .subscribe({\n *     error: err => console.error(err.message)\n *   });\n * ```\n *\n * @see {@link timeout}\n *\n * @param due When passed a number, used as the time (in milliseconds) allowed between each value from the source before timeout\n * is triggered. When passed a Date, used as the exact time at which the timeout will be triggered if the first value does not arrive.\n * @param withObservable The observable to switch to when timeout occurs.\n * @param scheduler The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it starts emitting values\n * from the `ObservableInput` passed as a second parameter.\n * @deprecated Replaced with {@link timeout}. Instead of `timeoutWith(100, a$, scheduler)`, use {@link timeout} with the configuration\n * object: `timeout({ each: 100, with: () => a$, scheduler })`. Instead of `timeoutWith(someDate, a$, scheduler)`, use {@link timeout}\n * with the configuration object: `timeout({ first: someDate, with: () => a$, scheduler })`. Will be removed in v8.\n */\nexport function timeoutWith<T, R>(\n  due: number | Date,\n  withObservable: ObservableInput<R>,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, T | R> {\n  let first: number | Date | undefined;\n  let each: number | undefined;\n  let _with: () => ObservableInput<R>;\n  scheduler = scheduler ?? async;\n\n  if (isValidDate(due)) {\n    first = due;\n  } else if (typeof due === 'number') {\n    each = due;\n  }\n\n  if (withObservable) {\n    _with = () => withObservable;\n  } else {\n    throw new TypeError('No observable provided to switch to');\n  }\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return timeout<T, ObservableInput<R>>({\n    first,\n    each,\n    scheduler,\n    with: _with,\n  });\n}\n", "import { OperatorFunction, TimestampProvider, Timestamp } from '../types';\nimport { dateTimestampProvider } from '../scheduler/dateTimestampProvider';\nimport { map } from './map';\n\n/**\n * Attaches a timestamp to each item emitted by an observable indicating when it was emitted\n *\n * The `timestamp` operator maps the *source* observable stream to an object of type\n * `{value: T, timestamp: R}`. The properties are generically typed. The `value` property contains the value\n * and type of the *source* observable. The `timestamp` is generated by the schedulers `now` function. By\n * default, it uses the `asyncScheduler` which simply returns `Date.now()` (milliseconds since 1970/01/01\n * 00:00:00:000) and therefore is of type `number`.\n *\n * ![](timestamp.png)\n *\n * ## Example\n *\n * In this example there is a timestamp attached to the document's click events\n *\n * ```ts\n * import { fromEvent, timestamp } from 'rxjs';\n *\n * const clickWithTimestamp = fromEvent(document, 'click').pipe(\n *   timestamp()\n * );\n *\n * // Emits data of type { value: PointerEvent, timestamp: number }\n * clickWithTimestamp.subscribe(data => {\n *   console.log(data);\n * });\n * ```\n *\n * @param timestampProvider An object with a `now()` method used to get the current timestamp.\n * @return A function that returns an Observable that attaches a timestamp to\n * each item emitted by the source Observable indicating when it was emitted.\n */\nexport function timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>> {\n  return map((value: T) => ({ value, timestamp: timestampProvider.now() }));\n}\n", "import { Observable } from '../Observable';\nimport { OperatorFunction, ObservableInput } from '../types';\nimport { Subject } from '../Subject';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable whenever\n * `windowBoundaries` emits.\n *\n * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n * instead of an array.</span>\n *\n * ![](window.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping\n * windows. It emits the current window and opens a new one whenever the\n * `windowBoundaries` emits an item. `windowBoundaries` can be any type that\n * `ObservableInput` accepts. It internally gets converted to an Observable.\n * Because each window is an Observable, the output is a higher-order Observable.\n *\n * ## Example\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, interval, window, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const sec = interval(1000);\n * const result = clicks.pipe(\n *   window(sec),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link buffer}\n *\n * @param windowBoundaries An `ObservableInput` that completes the\n * previous window and starts a new window.\n * @return A function that returns an Observable of windows, which are\n * Observables emitting values of the source Observable.\n */\nexport function window<T>(windowBoundaries: ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let windowSubject: Subject<T> = new Subject<T>();\n\n    subscriber.next(windowSubject.asObservable());\n\n    const errorHandler = (err: any) => {\n      windowSubject.error(err);\n      subscriber.error(err);\n    };\n\n    // Subscribe to our source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => windowSubject?.next(value),\n        () => {\n          windowSubject.complete();\n          subscriber.complete();\n        },\n        errorHandler\n      )\n    );\n\n    // Subscribe to the window boundaries.\n    innerFrom(windowBoundaries).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        () => {\n          windowSubject.complete();\n          subscriber.next((windowSubject = new Subject()));\n        },\n        noop,\n        errorHandler\n      )\n    );\n\n    return () => {\n      // Unsubscribing the subject ensures that anyone who has captured\n      // a reference to this window that tries to use it after it can\n      // no longer get values from the source will get an ObjectUnsubscribedError.\n      windowSubject?.unsubscribe();\n      windowSubject = null!;\n    };\n  });\n}\n", "import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Branch out the source Observable values as a nested Observable with each\n * nested Observable emitting at most `windowSize` values.\n *\n * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowCount.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows every `startWindowEvery`\n * items, each containing no more than `windowSize` items. When the source\n * Observable completes or encounters an error, the output Observable emits\n * the current window and propagates the notification from the source\n * Observable. If `startWindowEvery` is not provided, then new windows are\n * started immediately at the start of the source and when each window completes\n * with size `windowSize`.\n *\n * ## Examples\n *\n * Ignore every 3rd click event, starting from the first one\n *\n * ```ts\n * import { fromEvent, windowCount, map, skip, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(3),\n *   map(win => win.pipe(skip(1))), // skip first of every 3 clicks\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Ignore every 3rd click event, starting from the third one\n *\n * ```ts\n * import { fromEvent, windowCount, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowCount(2, 3),\n *   mergeAll() // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferCount}\n *\n * @param windowSize The maximum number of values emitted by each window.\n * @param startWindowEvery Interval at which to start a new window. For example\n * if `startWindowEvery` is `2`, then a new window will be started on every\n * other value from the source. A new window is started at the beginning of the\n * source by default.\n * @return A function that returns an Observable of windows, which in turn are\n * Observable of values.\n */\nexport function windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>> {\n  const startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;\n\n  return operate((source, subscriber) => {\n    let windows = [new Subject<T>()];\n    let starts: number[] = [];\n    let count = 0;\n\n    // Open the first window.\n    subscriber.next(windows[0].asObservable());\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Emit the value through all current windows.\n          // We don't need to create a new window yet, we\n          // do that as soon as we close one.\n          for (const window of windows) {\n            window.next(value);\n          }\n          // Here we're using the size of the window array to figure\n          // out if the oldest window has emitted enough values. We can do this\n          // because the size of the window array is a function of the values\n          // seen by the subscription. If it's time to close it, we complete\n          // it and remove it.\n          const c = count - windowSize + 1;\n          if (c >= 0 && c % startEvery === 0) {\n            windows.shift()!.complete();\n          }\n\n          // Look to see if the next count tells us it's time to open a new window.\n          // TODO: We need to figure out if this really makes sense. We're technically\n          // emitting windows *before* we have a value to emit them for. It's probably\n          // more expected that we should be emitting the window when the start\n          // count is reached -- not before.\n          if (++count % startEvery === 0) {\n            const window = new Subject<T>();\n            windows.push(window);\n            subscriber.next(window.asObservable());\n          }\n        },\n        () => {\n          while (windows.length > 0) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        (err) => {\n          while (windows.length > 0) {\n            windows.shift()!.error(err);\n          }\n          subscriber.error(err);\n        },\n        () => {\n          starts = null!;\n          windows = null!;\n        }\n      )\n    );\n  });\n}\n", "import { Subject } from '../Subject';\nimport { asyncScheduler } from '../scheduler/async';\nimport { Observable } from '../Observable';\nimport { Subscription } from '../Subscription';\nimport { Observer, OperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { arrRemove } from '../util/arrRemove';\nimport { popScheduler } from '../util/args';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function windowTime<T>(windowTimeSpan: number, scheduler?: SchedulerLike): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\nexport function windowTime<T>(\n  windowTimeSpan: number,\n  windowCreationInterval: number | null | void,\n  maxWindowSize: number,\n  scheduler?: SchedulerLike\n): OperatorFunction<T, Observable<T>>;\n\n/**\n * Branch out the source Observable values as a nested Observable periodically\n * in time.\n *\n * <span class=\"informal\">It's like {@link bufferTime}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowTime.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable starts a new window periodically, as\n * determined by the `windowCreationInterval` argument. It emits each window\n * after a fixed timespan, specified by the `windowTimeSpan` argument. When the\n * source Observable completes or encounters an error, the output Observable\n * emits the current window and propagates the notification from the source\n * Observable. If `windowCreationInterval` is not provided, the output\n * Observable starts a new window when the previous window of duration\n * `windowTimeSpan` completes. If `maxWindowCount` is provided, each window\n * will emit at most fixed number of values. Window will complete immediately\n * after emitting last value and next one still will open as specified by\n * `windowTimeSpan` and `windowCreationInterval` arguments.\n *\n * ## Examples\n *\n * In every window of 1 second each, emit at most 2 click events\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Every 5 seconds start a window 1 second long, and emit at most 2 click events per window\n *\n * ```ts\n * import { fromEvent, windowTime, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Same as example above but with `maxWindowCount` instead of `take`\n *\n * ```ts\n * import { fromEvent, windowTime, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowTime(1000, 5000, 2), // take at most 2 emissions from each window\n *   mergeAll()                 // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowToggle}\n * @see {@link windowWhen}\n * @see {@link bufferTime}\n *\n * @param windowTimeSpan The amount of time, in milliseconds, to fill each window.\n * @param windowCreationInterval The interval at which to start new\n * windows.\n * @param maxWindowSize Max number of\n * values each window can emit before completion.\n * @param scheduler The scheduler on which to schedule the\n * intervals that determine window boundaries.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>> {\n  const scheduler = popScheduler(otherArgs) ?? asyncScheduler;\n  const windowCreationInterval = (otherArgs[0] as number) ?? null;\n  const maxWindowSize = (otherArgs[1] as number) || Infinity;\n\n  return operate((source, subscriber) => {\n    // The active windows, their related subscriptions, and removal functions.\n    let windowRecords: WindowRecord<T>[] | null = [];\n    // If true, it means that every time we close a window, we want to start a new window.\n    // This is only really used for when *just* the time span is passed.\n    let restartOnClose = false;\n\n    const closeWindow = (record: { window: Subject<T>; subs: Subscription }) => {\n      const { window, subs } = record;\n      window.complete();\n      subs.unsubscribe();\n      arrRemove(windowRecords, record);\n      restartOnClose && startWindow();\n    };\n\n    /**\n     * Called every time we start a new window. This also does\n     * the work of scheduling the job to close the window.\n     */\n    const startWindow = () => {\n      if (windowRecords) {\n        const subs = new Subscription();\n        subscriber.add(subs);\n        const window = new Subject<T>();\n        const record = {\n          window,\n          subs,\n          seen: 0,\n        };\n        windowRecords.push(record);\n        subscriber.next(window.asObservable());\n        executeSchedule(subs, scheduler, () => closeWindow(record), windowTimeSpan);\n      }\n    };\n\n    if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n      // The user passed both a windowTimeSpan (required), and a creation interval\n      // That means we need to start new window on the interval, and those windows need\n      // to wait the required time span before completing.\n      executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);\n    } else {\n      restartOnClose = true;\n    }\n\n    startWindow();\n\n    /**\n     * We need to loop over a copy of the window records several times in this operator.\n     * This is to save bytes over the wire more than anything.\n     * The reason we copy the array is that reentrant code could mutate the array while\n     * we are iterating over it.\n     */\n    const loop = (cb: (record: WindowRecord<T>) => void) => windowRecords!.slice().forEach(cb);\n\n    /**\n     * Used to notify all of the windows and the subscriber in the same way\n     * in the error and complete handlers.\n     */\n    const terminate = (cb: (consumer: Observer<any>) => void) => {\n      loop(({ window }) => cb(window));\n      cb(subscriber);\n      subscriber.unsubscribe();\n    };\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Notify all windows of the value.\n          loop((record) => {\n            record.window.next(value);\n            // If the window is over the max size, we need to close it.\n            maxWindowSize <= ++record.seen && closeWindow(record);\n          });\n        },\n        // Complete the windows and the downstream subscriber and clean up.\n        () => terminate((consumer) => consumer.complete()),\n        // Notify the windows and the downstream subscriber of the error and clean up.\n        (err) => terminate((consumer) => consumer.error(err))\n      )\n    );\n\n    // Additional finalization. This will be called when the\n    // destination tears down. Other finalizations are registered implicitly\n    // above via subscription.\n    return () => {\n      // Ensure that the buffer is released.\n      windowRecords = null!;\n    };\n  });\n}\n\ninterface WindowRecord<T> {\n  seen: number;\n  window: Subject<T>;\n  subs: Subscription;\n}\n", "import { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\nimport { arrRemove } from '../util/arrRemove';\n\n/**\n * Branch out the source Observable values as a nested Observable starting from\n * an emission from `openings` and ending when the output of `closingSelector`\n * emits.\n *\n * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowToggle.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits windows that contain those items\n * emitted by the source Observable between the time when the `openings`\n * Observable emits an item and when the Observable returned by\n * `closingSelector` emits an item.\n *\n * ## Example\n *\n * Every other second, emit the click events from the next 500ms\n *\n * ```ts\n * import { fromEvent, interval, windowToggle, EMPTY, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const openings = interval(1000);\n * const result = clicks.pipe(\n *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),\n *   mergeAll()\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowWhen}\n * @see {@link bufferToggle}\n *\n * @param openings An observable of notifications to start new windows.\n * @param closingSelector A function that takes the value emitted by the\n * `openings` observable and returns an Observable, which, when it emits a next\n * notification, signals that the associated window should complete.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowToggle<T, O>(\n  openings: ObservableInput<O>,\n  closingSelector: (openValue: O) => ObservableInput<any>\n): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    const windows: Subject<T>[] = [];\n\n    const handleError = (err: any) => {\n      while (0 < windows.length) {\n        windows.shift()!.error(err);\n      }\n      subscriber.error(err);\n    };\n\n    innerFrom(openings).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (openValue) => {\n          const window = new Subject<T>();\n          windows.push(window);\n          const closingSubscription = new Subscription();\n          const closeWindow = () => {\n            arrRemove(windows, window);\n            window.complete();\n            closingSubscription.unsubscribe();\n          };\n\n          let closingNotifier: Observable<any>;\n          try {\n            closingNotifier = innerFrom(closingSelector(openValue));\n          } catch (err) {\n            handleError(err);\n            return;\n          }\n\n          subscriber.next(window.asObservable());\n\n          closingSubscription.add(closingNotifier.subscribe(createOperatorSubscriber(subscriber, closeWindow, noop, handleError)));\n        },\n        noop\n      )\n    );\n\n    // Subscribe to the source to get things started.\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // Copy the windows array before we emit to\n          // make sure we don't have issues with reentrant code.\n          const windowsCopy = windows.slice();\n          for (const window of windowsCopy) {\n            window.next(value);\n          }\n        },\n        () => {\n          // Complete all of our windows before we complete.\n          while (0 < windows.length) {\n            windows.shift()!.complete();\n          }\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Add this finalization so that all window subjects are\n          // disposed of. This way, if a user tries to subscribe\n          // to a window *after* the outer subscription has been unsubscribed,\n          // they will get an error, instead of waiting forever to\n          // see if a value arrives.\n          while (0 < windows.length) {\n            windows.shift()!.unsubscribe();\n          }\n        }\n      )\n    );\n  });\n}\n", "import { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { Subject } from '../Subject';\nimport { ObservableInput, OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\n\n/**\n * Branch out the source Observable values as a nested Observable using a\n * factory function of closing Observables to determine when to start a new\n * window.\n *\n * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n * Observable instead of an array.</span>\n *\n * ![](windowWhen.png)\n *\n * Returns an Observable that emits windows of items it collects from the source\n * Observable. The output Observable emits connected, non-overlapping windows.\n * It emits the current window and opens a new one whenever the Observable\n * produced by the specified `closingSelector` function emits an item. The first\n * window is opened immediately when subscribing to the output Observable.\n *\n * ## Example\n *\n * Emit only the first two clicks events in every window of [1-5] random seconds\n *\n * ```ts\n * import { fromEvent, windowWhen, interval, map, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   windowWhen(() => interval(1000 + Math.random() * 4000)),\n *   map(win => win.pipe(take(2))), // take at most 2 emissions from each window\n *   mergeAll()                     // flatten the Observable-of-Observables\n * );\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link window}\n * @see {@link windowCount}\n * @see {@link windowTime}\n * @see {@link windowToggle}\n * @see {@link bufferWhen}\n *\n * @param closingSelector A function that takes no arguments and returns an\n * {@link ObservableInput} (that gets converted to Observable) that signals\n * (on either `next` or `complete`) when to close the previous window and\n * start a new one.\n * @return A function that returns an Observable of windows, which in turn are\n * Observables.\n */\nexport function windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>> {\n  return operate((source, subscriber) => {\n    let window: Subject<T> | null;\n    let closingSubscriber: Subscriber<any> | undefined;\n\n    /**\n     * When we get an error, we have to notify both the\n     * destination subscriber and the window.\n     */\n    const handleError = (err: any) => {\n      window!.error(err);\n      subscriber.error(err);\n    };\n\n    /**\n     * Called every time we need to open a window.\n     * Recursive, as it will start the closing notifier, which\n     * inevitably *should* call openWindow -- but may not if\n     * it is a \"never\" observable.\n     */\n    const openWindow = () => {\n      // We need to clean up our closing subscription,\n      // we only cared about the first next or complete notification.\n      closingSubscriber?.unsubscribe();\n\n      // Close our window before starting a new one.\n      window?.complete();\n\n      // Start the new window.\n      window = new Subject<T>();\n      subscriber.next(window.asObservable());\n\n      // Get our closing notifier.\n      let closingNotifier: Observable<any>;\n      try {\n        closingNotifier = innerFrom(closingSelector());\n      } catch (err) {\n        handleError(err);\n        return;\n      }\n\n      // Subscribe to the closing notifier, be sure\n      // to capture the subscriber (aka Subscription)\n      // so we can clean it up when we close the window\n      // and open a new one.\n      closingNotifier.subscribe((closingSubscriber = createOperatorSubscriber(subscriber, openWindow, openWindow, handleError)));\n    };\n\n    // Start the first window.\n    openWindow();\n\n    // Subscribe to the source\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => window!.next(value),\n        () => {\n          // The source completed, close the window and complete.\n          window!.complete();\n          subscriber.complete();\n        },\n        handleError,\n        () => {\n          // Be sure to clean up our closing subscription\n          // when this tears down.\n          closingSubscriber?.unsubscribe();\n          window = null!;\n        }\n      )\n    );\n  });\n}\n", "import { OperatorFunction, ObservableInputTuple } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { identity } from '../util/identity';\nimport { noop } from '../util/noop';\nimport { popResultSelector } from '../util/args';\n\nexport function withLatestFrom<T, O extends unknown[]>(...inputs: [...ObservableInputTuple<O>]): OperatorFunction<T, [T, ...O]>;\n\nexport function withLatestFrom<T, O extends unknown[], R>(\n  ...inputs: [...ObservableInputTuple<O>, (...value: [T, ...O]) => R]\n): OperatorFunction<T, R>;\n\n/**\n * Combines the source Observable with other Observables to create an Observable\n * whose values are calculated from the latest values of each, only when the\n * source emits.\n *\n * <span class=\"informal\">Whenever the source Observable emits a value, it\n * computes a formula using that value plus the latest values from other input\n * Observables, then emits the output of that formula.</span>\n *\n * ![](withLatestFrom.png)\n *\n * `withLatestFrom` combines each value from the source Observable (the\n * instance) with the latest values from the other input Observables only when\n * the source emits a value, optionally using a `project` function to determine\n * the value to be emitted on the output Observable. All input Observables must\n * emit at least one value before the output Observable will emit a value.\n *\n * ## Example\n *\n * On every click event, emit an array with the latest timer event plus the click event\n *\n * ```ts\n * import { fromEvent, interval, withLatestFrom } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const result = clicks.pipe(withLatestFrom(timer));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatest}\n *\n * @param inputs An input Observable to combine with the source Observable. More\n * than one input Observables may be given as argument. If the last parameter is\n * a function, it will be used as a projection function for combining values\n * together. When the function is called, it receives all values in order of the\n * Observables passed, where the first parameter is a value from the source\n * Observable. (e.g.\n * `a.pipe(withLatestFrom(b, c), map(([a1, b1, c1]) => a1 + b1 + c1))`). If this\n * is not passed, arrays will be emitted on the output Observable.\n * @return A function that returns an Observable of projected values from the\n * most recent values from each input Observable, or an array of the most\n * recent values from each input Observable.\n */\nexport function withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]> {\n  const project = popResultSelector(inputs) as ((...args: any[]) => R) | undefined;\n\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    // An array of whether or not the other sources have emitted. Matched with them by index.\n    // TODO: At somepoint, we should investigate the performance implications here, and look\n    // into using a `Set()` and checking the `size` to see if we're ready.\n    let hasValue = inputs.map(() => false);\n    // Flipped true when we have at least one value from all other sources and\n    // we are ready to start emitting values.\n    let ready = false;\n\n    // Other sources. Note that here we are not checking `subscriber.closed`,\n    // this causes all inputs to be subscribed to, even if nothing can be emitted\n    // from them. This is an important distinction because subscription constitutes\n    // a side-effect.\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(\n        createOperatorSubscriber(\n          subscriber,\n          (value) => {\n            otherValues[i] = value;\n            if (!ready && !hasValue[i]) {\n              // If we're not ready yet, flag to show this observable has emitted.\n              hasValue[i] = true;\n              // Intentionally terse code.\n              // If all of our other observables have emitted, set `ready` to `true`,\n              // so we know we can start emitting values, then clean up the `hasValue` array,\n              // because we don't need it anymore.\n              (ready = hasValue.every(identity)) && (hasValue = null!);\n            }\n          },\n          // Completing one of the other sources has\n          // no bearing on the completion of our result.\n          noop\n        )\n      );\n    }\n\n    // Source subscription\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        if (ready) {\n          // We have at least one value from the other sources. Go ahead and emit.\n          const values = [value, ...otherValues];\n          subscriber.next(project ? project(...values) : values);\n        }\n      })\n    );\n  });\n}\n", "import { OperatorFunction, ObservableInput } from '../types';\nimport { zip } from '../observable/zip';\nimport { joinAllInternals } from './joinAllInternals';\n\n/**\n * Collects all observable inner sources from the source, once the source completes,\n * it will subscribe to all inner sources, combining their values by index and emitting\n * them.\n *\n * @see {@link zipWith}\n * @see {@link zip}\n */\nexport function zipAll<T>(): OperatorFunction<ObservableInput<T>, T[]>;\nexport function zipAll<T>(): OperatorFunction<any, T[]>;\nexport function zipAll<T, R>(project: (...values: T[]) => R): OperatorFunction<ObservableInput<T>, R>;\nexport function zipAll<R>(project: (...values: Array<any>) => R): OperatorFunction<any, R>;\n\nexport function zipAll<T, R>(project?: (...values: T[]) => R) {\n  return joinAllInternals(zip, project);\n}\n", "import { zip as zipStatic } from '../observable/zip';\nimport { ObservableInput, ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { operate } from '../util/lift';\n\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  otherInputsAndProject: [...ObservableInputTuple<A>],\n  project: (...values: Cons<T, A>) => R\n): OperatorFunction<T, R>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>>;\n/** @deprecated Replaced with {@link zipWith}. Will be removed in v8. */\nexport function zip<T, A extends readonly unknown[], R>(\n  ...otherInputsAndProject: [...ObservableInputTuple<A>, (...values: Cons<T, A>) => R]\n): OperatorFunction<T, R>;\n\n/**\n * @deprecated Replaced with {@link zipWith}. Will be removed in v8.\n */\nexport function zip<T, R>(...sources: Array<ObservableInput<any> | ((...values: Array<any>) => R)>): OperatorFunction<T, any> {\n  return operate((source, subscriber) => {\n    zipStatic(source as ObservableInput<any>, ...(sources as Array<ObservableInput<any>>)).subscribe(subscriber);\n  });\n}\n", "import { ObservableInputTuple, OperatorFunction, Cons } from '../types';\nimport { zip } from './zip';\n\n/**\n * Subscribes to the source, and the observable inputs provided as arguments, and combines their values, by index, into arrays.\n *\n * What is meant by \"combine by index\": The first value from each will be made into a single array, then emitted,\n * then the second value from each will be combined into a single array and emitted, then the third value\n * from each will be combined into a single array and emitted, and so on.\n *\n * This will continue until it is no longer able to combine values of the same index into an array.\n *\n * After the last value from any one completed source is emitted in an array, the resulting observable will complete,\n * as there is no way to continue \"zipping\" values together by index.\n *\n * Use-cases for this operator are limited. There are memory concerns if one of the streams is emitting\n * values at a much faster rate than the others. Usage should likely be limited to streams that emit\n * at a similar pace, or finite streams of known length.\n *\n * In many cases, authors want `combineLatestWith` and not `zipWith`.\n *\n * @param otherInputs other observable inputs to collate values from.\n * @return A function that returns an Observable that emits items by index\n * combined from the source Observable and provided Observables, in form of an\n * array.\n */\nexport function zipWith<T, A extends readonly unknown[]>(...otherInputs: [...ObservableInputTuple<A>]): OperatorFunction<T, Cons<T, A>> {\n  return zip(...otherInputs);\n}\n", "//////////////////////////////////////////////////////////\n// Here we need to reference our other deep imports\n// so VS code will figure out where they are\n// see conversation here:\n// https://github.com/microsoft/TypeScript/issues/43034\n//////////////////////////////////////////////////////////\n\n// tslint:disable: no-reference\n// It's tempting to add references to all of the deep-import locations, but\n// adding references to those that require DOM types breaks Node projects.\n/// <reference path=\"./operators/index.ts\" />\n/// <reference path=\"./testing/index.ts\" />\n// tslint:enable: no-reference\n\n/* Observable */\nexport { Observable } from './internal/Observable';\nexport { ConnectableObservable } from './internal/observable/ConnectableObservable';\nexport { GroupedObservable } from './internal/operators/groupBy';\nexport { Operator } from './internal/Operator';\nexport { observable } from './internal/symbol/observable';\nexport { animationFrames } from './internal/observable/dom/animationFrames';\n\n/* Subjects */\nexport { Subject } from './internal/Subject';\nexport { BehaviorSubject } from './internal/BehaviorSubject';\nexport { ReplaySubject } from './internal/ReplaySubject';\nexport { AsyncSubject } from './internal/AsyncSubject';\n\n/* Schedulers */\nexport { asap, asapScheduler } from './internal/scheduler/asap';\nexport { async, asyncScheduler } from './internal/scheduler/async';\nexport { queue, queueScheduler } from './internal/scheduler/queue';\nexport { animationFrame, animationFrameScheduler } from './internal/scheduler/animationFrame';\nexport { VirtualTimeScheduler, VirtualAction } from './internal/scheduler/VirtualTimeScheduler';\nexport { Scheduler } from './internal/Scheduler';\n\n/* Subscription */\nexport { Subscription } from './internal/Subscription';\nexport { Subscriber } from './internal/Subscriber';\n\n/* Notification */\nexport { Notification, NotificationKind } from './internal/Notification';\n\n/* Utils */\nexport { pipe } from './internal/util/pipe';\nexport { noop } from './internal/util/noop';\nexport { identity } from './internal/util/identity';\nexport { isObservable } from './internal/util/isObservable';\n\n/* Promise Conversion */\nexport { lastValueFrom } from './internal/lastValueFrom';\nexport { firstValueFrom } from './internal/firstValueFrom';\n\n/* Error types */\nexport { ArgumentOutOfRangeError } from './internal/util/ArgumentOutOfRangeError';\nexport { EmptyError } from './internal/util/EmptyError';\nexport { NotFoundError } from './internal/util/NotFoundError';\nexport { ObjectUnsubscribedError } from './internal/util/ObjectUnsubscribedError';\nexport { SequenceError } from './internal/util/SequenceError';\nexport { TimeoutError } from './internal/operators/timeout';\nexport { UnsubscriptionError } from './internal/util/UnsubscriptionError';\n\n/* Static observable creation exports */\nexport { bindCallback } from './internal/observable/bindCallback';\nexport { bindNodeCallback } from './internal/observable/bindNodeCallback';\nexport { combineLatest } from './internal/observable/combineLatest';\nexport { concat } from './internal/observable/concat';\nexport { connectable } from './internal/observable/connectable';\nexport { defer } from './internal/observable/defer';\nexport { empty } from './internal/observable/empty';\nexport { forkJoin } from './internal/observable/forkJoin';\nexport { from } from './internal/observable/from';\nexport { fromEvent } from './internal/observable/fromEvent';\nexport { fromEventPattern } from './internal/observable/fromEventPattern';\nexport { generate } from './internal/observable/generate';\nexport { iif } from './internal/observable/iif';\nexport { interval } from './internal/observable/interval';\nexport { merge } from './internal/observable/merge';\nexport { never } from './internal/observable/never';\nexport { of } from './internal/observable/of';\nexport { onErrorResumeNext } from './internal/observable/onErrorResumeNext';\nexport { pairs } from './internal/observable/pairs';\nexport { partition } from './internal/observable/partition';\nexport { race } from './internal/observable/race';\nexport { range } from './internal/observable/range';\nexport { throwError } from './internal/observable/throwError';\nexport { timer } from './internal/observable/timer';\nexport { using } from './internal/observable/using';\nexport { zip } from './internal/observable/zip';\nexport { scheduled } from './internal/scheduled/scheduled';\n\n/* Constants */\nexport { EMPTY } from './internal/observable/empty';\nexport { NEVER } from './internal/observable/never';\n\n/* Types */\nexport * from './internal/types';\n\n/* Config */\nexport { config, GlobalConfig } from './internal/config';\n\n/* Operators */\nexport { audit } from './internal/operators/audit';\nexport { auditTime } from './internal/operators/auditTime';\nexport { buffer } from './internal/operators/buffer';\nexport { bufferCount } from './internal/operators/bufferCount';\nexport { bufferTime } from './internal/operators/bufferTime';\nexport { bufferToggle } from './internal/operators/bufferToggle';\nexport { bufferWhen } from './internal/operators/bufferWhen';\nexport { catchError } from './internal/operators/catchError';\nexport { combineAll } from './internal/operators/combineAll';\nexport { combineLatestAll } from './internal/operators/combineLatestAll';\nexport { combineLatestWith } from './internal/operators/combineLatestWith';\nexport { concatAll } from './internal/operators/concatAll';\nexport { concatMap } from './internal/operators/concatMap';\nexport { concatMapTo } from './internal/operators/concatMapTo';\nexport { concatWith } from './internal/operators/concatWith';\nexport { connect, ConnectConfig } from './internal/operators/connect';\nexport { count } from './internal/operators/count';\nexport { debounce } from './internal/operators/debounce';\nexport { debounceTime } from './internal/operators/debounceTime';\nexport { defaultIfEmpty } from './internal/operators/defaultIfEmpty';\nexport { delay } from './internal/operators/delay';\nexport { delayWhen } from './internal/operators/delayWhen';\nexport { dematerialize } from './internal/operators/dematerialize';\nexport { distinct } from './internal/operators/distinct';\nexport { distinctUntilChanged } from './internal/operators/distinctUntilChanged';\nexport { distinctUntilKeyChanged } from './internal/operators/distinctUntilKeyChanged';\nexport { elementAt } from './internal/operators/elementAt';\nexport { endWith } from './internal/operators/endWith';\nexport { every } from './internal/operators/every';\nexport { exhaust } from './internal/operators/exhaust';\nexport { exhaustAll } from './internal/operators/exhaustAll';\nexport { exhaustMap } from './internal/operators/exhaustMap';\nexport { expand } from './internal/operators/expand';\nexport { filter } from './internal/operators/filter';\nexport { finalize } from './internal/operators/finalize';\nexport { find } from './internal/operators/find';\nexport { findIndex } from './internal/operators/findIndex';\nexport { first } from './internal/operators/first';\nexport { groupBy, BasicGroupByOptions, GroupByOptionsWithElement } from './internal/operators/groupBy';\nexport { ignoreElements } from './internal/operators/ignoreElements';\nexport { isEmpty } from './internal/operators/isEmpty';\nexport { last } from './internal/operators/last';\nexport { map } from './internal/operators/map';\nexport { mapTo } from './internal/operators/mapTo';\nexport { materialize } from './internal/operators/materialize';\nexport { max } from './internal/operators/max';\nexport { mergeAll } from './internal/operators/mergeAll';\nexport { flatMap } from './internal/operators/flatMap';\nexport { mergeMap } from './internal/operators/mergeMap';\nexport { mergeMapTo } from './internal/operators/mergeMapTo';\nexport { mergeScan } from './internal/operators/mergeScan';\nexport { mergeWith } from './internal/operators/mergeWith';\nexport { min } from './internal/operators/min';\nexport { multicast } from './internal/operators/multicast';\nexport { observeOn } from './internal/operators/observeOn';\nexport { onErrorResumeNextWith } from './internal/operators/onErrorResumeNextWith';\nexport { pairwise } from './internal/operators/pairwise';\nexport { pluck } from './internal/operators/pluck';\nexport { publish } from './internal/operators/publish';\nexport { publishBehavior } from './internal/operators/publishBehavior';\nexport { publishLast } from './internal/operators/publishLast';\nexport { publishReplay } from './internal/operators/publishReplay';\nexport { raceWith } from './internal/operators/raceWith';\nexport { reduce } from './internal/operators/reduce';\nexport { repeat, RepeatConfig } from './internal/operators/repeat';\nexport { repeatWhen } from './internal/operators/repeatWhen';\nexport { retry, RetryConfig } from './internal/operators/retry';\nexport { retryWhen } from './internal/operators/retryWhen';\nexport { refCount } from './internal/operators/refCount';\nexport { sample } from './internal/operators/sample';\nexport { sampleTime } from './internal/operators/sampleTime';\nexport { scan } from './internal/operators/scan';\nexport { sequenceEqual } from './internal/operators/sequenceEqual';\nexport { share, ShareConfig } from './internal/operators/share';\nexport { shareReplay, ShareReplayConfig } from './internal/operators/shareReplay';\nexport { single } from './internal/operators/single';\nexport { skip } from './internal/operators/skip';\nexport { skipLast } from './internal/operators/skipLast';\nexport { skipUntil } from './internal/operators/skipUntil';\nexport { skipWhile } from './internal/operators/skipWhile';\nexport { startWith } from './internal/operators/startWith';\nexport { subscribeOn } from './internal/operators/subscribeOn';\nexport { switchAll } from './internal/operators/switchAll';\nexport { switchMap } from './internal/operators/switchMap';\nexport { switchMapTo } from './internal/operators/switchMapTo';\nexport { switchScan } from './internal/operators/switchScan';\nexport { take } from './internal/operators/take';\nexport { takeLast } from './internal/operators/takeLast';\nexport { takeUntil } from './internal/operators/takeUntil';\nexport { takeWhile } from './internal/operators/takeWhile';\nexport { tap, TapObserver } from './internal/operators/tap';\nexport { throttle, ThrottleConfig } from './internal/operators/throttle';\nexport { throttleTime } from './internal/operators/throttleTime';\nexport { throwIfEmpty } from './internal/operators/throwIfEmpty';\nexport { timeInterval } from './internal/operators/timeInterval';\nexport { timeout, TimeoutConfig, TimeoutInfo } from './internal/operators/timeout';\nexport { timeoutWith } from './internal/operators/timeoutWith';\nexport { timestamp } from './internal/operators/timestamp';\nexport { toArray } from './internal/operators/toArray';\nexport { window } from './internal/operators/window';\nexport { windowCount } from './internal/operators/windowCount';\nexport { windowTime } from './internal/operators/windowTime';\nexport { windowToggle } from './internal/operators/windowToggle';\nexport { windowWhen } from './internal/operators/windowWhen';\nexport { withLatestFrom } from './internal/operators/withLatestFrom';\nexport { zipAll } from './internal/operators/zipAll';\nexport { zipWith } from './internal/operators/zipWith';\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { v4 as uuid } from 'uuid'\r\n\r\nimport { Activity, Attachment, ConversationAccount } from '@microsoft/agents-activity'\r\nimport { Observable, BehaviorSubject, type Subscriber } from 'rxjs'\r\n\r\nimport { CopilotStudioClient } from './copilotStudioClient'\r\nimport { debug } from '@microsoft/agents-activity/logger'\r\n\r\nconst logger = debug('copilot-studio:webchat')\r\n\r\n/**\r\n * Configuration settings for the Copilot Studio WebChat connection.\r\n * These settings control the behavior and appearance of the WebChat interface\r\n * when connected to the Copilot Studio service.\r\n */\r\nexport interface CopilotStudioWebChatSettings {\r\n  /**\r\n   * Whether to show typing indicators in the WebChat when the agent is processing a response.\r\n   * When enabled, users will see a typing indicator while waiting for the agent's reply,\r\n   * providing visual feedback that their message is being processed.\r\n   * @default false\r\n   */\r\n  showTyping?: boolean;\r\n}\r\n\r\n/**\r\n * Represents a connection interface for integrating Copilot Studio with WebChat.\r\n *\r\n * @remarks\r\n * This interface provides the necessary methods and observables to facilitate\r\n * bidirectional communication between a WebChat client and the Copilot Studio service.\r\n *\r\n * The connection follows the DirectLine protocol pattern, making it compatible with\r\n * Microsoft Bot Framework WebChat components.\r\n */\r\nexport interface CopilotStudioWebChatConnection {\r\n  /**\r\n   * An observable that emits the current connection status as numeric values.\r\n   * This allows WebChat clients to monitor and react to connection state changes.\r\n   *\r\n   * Connection status values:\r\n   * - 0: Disconnected - No active connection to the service\r\n   * - 1: Connecting - Attempting to establish connection\r\n   * - 2: Connected - Successfully connected and ready for communication\r\n   */\r\n  connectionStatus$: BehaviorSubject<number>;\r\n\r\n  /**\r\n   * An observable stream that emits incoming activities from the Copilot Studio service.\r\n   * Each activity represents a message, card, or other interactive element sent by the agent.\r\n   *\r\n   * All emitted activities include:\r\n   * - A timestamp indicating when the activity was received\r\n   * - A 'webchat:sequence-id' in their channelData for proper message ordering\r\n   * - Standard Bot Framework Activity properties (type, text, attachments, etc.)\r\n   */\r\n  activity$: Observable<Partial<Activity>>;\r\n\r\n  /**\r\n   * Posts a user activity to the Copilot Studio service and returns an observable\r\n   * that emits the activity ID once the message is successfully sent.\r\n   *\r\n   * The method validates that the activity contains meaningful content and handles\r\n   * the complete message flow including optional typing indicators.\r\n   *\r\n   * @param activity - The user activity to send.\r\n   * @returns An observable that emits the unique activity ID upon successful posting.\r\n   * @throws Error if the activity text is empty or if the connection is not properly initialized.\r\n   */\r\n  postActivity(activity: Activity): Observable<string>;\r\n\r\n  /**\r\n   * Gracefully terminates the connection to the Copilot Studio service.\r\n   * This method ensures proper cleanup by completing all active observables\r\n   * and releasing associated resources.\r\n   *\r\n   * After calling this method:\r\n   * - The connectionStatus$ observable will be completed\r\n   * - The activity$ observable will stop emitting new activities\r\n   * - No further activities can be posted through this connection\r\n   */\r\n  end(): void;\r\n}\r\n\r\n/**\r\n * A utility class that provides WebChat integration capabilities for Copilot Studio services.\r\n *\r\n * @remarks\r\n * This class acts as a bridge between Microsoft Bot Framework WebChat and Copilot Studio,\r\n * enabling seamless communication through a DirectLine-compatible interface.\r\n *\r\n * ## Key Features:\r\n * - DirectLine protocol compatibility for easy WebChat integration\r\n * - Real-time bidirectional messaging with Copilot Studio agents\r\n * - Automatic conversation management and message sequencing\r\n * - Optional typing indicators for enhanced user experience\r\n * - Observable-based architecture for reactive programming patterns\r\n *\r\n * ## Usage Scenarios:\r\n * - Embedding Copilot Studio agents in web applications\r\n * - Creating custom chat interfaces with WebChat components\r\n * - Building conversational AI experiences with Microsoft's bot ecosystem\r\n *\r\n * @example Basic WebChat Integration\r\n * ```typescript\r\n * import { CopilotStudioClient } from '@microsoft/agents-copilotstudio-client';\r\n * import { CopilotStudioWebChat } from '@microsoft/agents-copilotstudio-client';\r\n *\r\n * // Initialize the Copilot Studio client\r\n * const client = new CopilotStudioClient({\r\n *   botId: 'your-bot-id',\r\n *   tenantId: 'your-tenant-id'\r\n * });\r\n *\r\n * // Create a WebChat-compatible connection\r\n * const directLine = CopilotStudioWebChat.createConnection(client, {\r\n *   showTyping: true\r\n * });\r\n *\r\n * // Integrate with WebChat\r\n * window.WebChat.renderWebChat({\r\n *   directLine: directLine,\r\n *   // ... other WebChat options\r\n * }, document.getElementById('webchat'));\r\n * ```\r\n *\r\n * @example Advanced Usage with Connection Monitoring\r\n * ```typescript\r\n * const connection = CopilotStudioWebChat.createConnection(client);\r\n *\r\n * // Monitor connection status\r\n * connection.connectionStatus$.subscribe(status => {\r\n *   switch (status) {\r\n *     case 0: console.log('Disconnected'); break;\r\n *     case 1: console.log('Connecting...'); break;\r\n *     case 2: console.log('Connected and ready'); break;\r\n *   }\r\n * });\r\n *\r\n * // Listen for incoming activities\r\n * connection.activity$.subscribe(activity => {\r\n *   console.log('Received activity:', activity);\r\n * });\r\n * ```\r\n */\r\nexport class CopilotStudioWebChat {\r\n  /**\r\n   * Creates a DirectLine-compatible connection for integrating Copilot Studio with WebChat.\r\n   *\r\n\r\n   * @param client - A configured CopilotStudioClient instance that handles the underlying\r\n   *                 communication with the Copilot Studio service. This client should be\r\n   *                 properly authenticated and configured with the target bot details.\r\n   *\r\n   * @param settings - Optional configuration settings that control the behavior of the\r\n   *                   WebChat connection. These settings allow customization of features\r\n   *                   like typing indicators and other user experience enhancements.\r\n   *\r\n   * @returns A new CopilotStudioWebChatConnection instance that can be passed directly\r\n   *          to WebChat's renderWebChat function as the directLine parameter. The\r\n   *          connection is immediately ready for use and will automatically manage\r\n   *          the conversation lifecycle.\r\n   *\r\n   * @throws Error if the provided client is not properly configured or if there are\r\n   *         issues establishing the initial connection to the Copilot Studio service.\r\n   *\r\n   * @remarks\r\n   * This method establishes a real-time communication channel between WebChat and the\r\n   * Copilot Studio service. The returned connection object implements the DirectLine\r\n   * protocol, making it fully compatible with Microsoft Bot Framework WebChat components.\r\n   *\r\n   * ## Connection Lifecycle:\r\n   * 1. **Initialization**: Creates observables for connection status and activity streaming\r\n   * 2. **Conversation Start**: Automatically initiates conversation when first activity is posted\r\n   * 3. **Message Flow**: Handles bidirectional message exchange with proper sequencing\r\n   * 4. **Cleanup**: Provides graceful connection termination\r\n   *\r\n   * ## Message Processing:\r\n   * - User messages are validated and sent to Copilot Studio\r\n   * - Agent responses are received and formatted for WebChat\r\n   * - All activities include timestamps and sequence IDs for proper ordering\r\n   * - Optional typing indicators provide visual feedback during processing\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const connection = CopilotStudioWebChat.createConnection(client, {\r\n   *   showTyping: true\r\n   * });\r\n   *\r\n   * // Use with WebChat\r\n   * window.WebChat.renderWebChat({\r\n   *   directLine: connection\r\n   * }, document.getElementById('webchat'));\r\n   * ```\r\n   */\r\n  static createConnection (\r\n    client: CopilotStudioClient,\r\n    settings?: CopilotStudioWebChatSettings\r\n  ):CopilotStudioWebChatConnection {\r\n    logger.info('--> Creating connection between Copilot Studio and WebChat ...')\r\n    let sequence = 0\r\n    let activitySubscriber: Subscriber<Partial<Activity>> | undefined\r\n    let conversation: ConversationAccount | undefined\r\n\r\n    const connectionStatus$ = new BehaviorSubject(0)\r\n    const activity$ = createObservable<Partial<Activity>>(async (subscriber) => {\r\n      activitySubscriber = subscriber\r\n\r\n      if (connectionStatus$.value < 2) {\r\n        connectionStatus$.next(2)\r\n        return\r\n      }\r\n\r\n      logger.debug('--> Connection established.')\r\n      notifyTyping()\r\n\r\n      for await (const activity of client.startConversationAsync()) {\r\n        delete activity.replyToId\r\n        conversation = activity.conversation\r\n        notifyActivity(activity)\r\n      }\r\n    })\r\n\r\n    const notifyActivity = (activity: Partial<Activity>) => {\r\n      const newActivity = {\r\n        ...activity,\r\n        timestamp: new Date().toISOString(),\r\n        channelData: {\r\n          ...activity.channelData,\r\n          'webchat:sequence-id': sequence,\r\n        },\r\n      }\r\n      sequence++\r\n      logger.debug(`Notify '${newActivity.type}' activity to WebChat:`, newActivity)\r\n      activitySubscriber?.next(newActivity)\r\n    }\r\n\r\n    const notifyTyping = () => {\r\n      if (!settings?.showTyping) {\r\n        return\r\n      }\r\n\r\n      const from = conversation\r\n        ? { id: conversation.id, name: conversation.name }\r\n        : { id: 'agent', name: 'Agent' }\r\n      notifyActivity({ type: 'typing', from })\r\n    }\r\n\r\n    return {\r\n      connectionStatus$,\r\n      activity$,\r\n      postActivity (activity: Activity) {\r\n        logger.info('--> Preparing to send activity to Copilot Studio ...')\r\n\r\n        if (!activity) {\r\n          throw new Error('Activity cannot be null.')\r\n        }\r\n\r\n        if (!activitySubscriber) {\r\n          throw new Error('Activity subscriber is not initialized.')\r\n        }\r\n\r\n        return createObservable<string>(async (subscriber) => {\r\n          try {\r\n            logger.info('--> Sending activity to Copilot Studio ...')\r\n            const newActivity = Activity.fromObject({\r\n              ...activity,\r\n              id: uuid(),\r\n              attachments: await processAttachments(activity)\r\n            })\r\n\r\n            notifyActivity(newActivity)\r\n            notifyTyping()\r\n\r\n            // Notify WebChat immediately that the message was sent\r\n            subscriber.next(newActivity.id!)\r\n\r\n            // Stream the agent's response, but don't block the UI\r\n            for await (const responseActivity of client.sendActivity(newActivity)) {\r\n              notifyActivity(responseActivity)\r\n              logger.info('<-- Activity received correctly from Copilot Studio.')\r\n            }\r\n\r\n            subscriber.complete()\r\n          } catch (error) {\r\n            logger.error('Error sending Activity to Copilot Studio:', error)\r\n            subscriber.error(error)\r\n          }\r\n        })\r\n      },\r\n\r\n      end () {\r\n        logger.info('--> Ending connection between Copilot Studio and WebChat ...')\r\n        connectionStatus$.complete()\r\n        if (activitySubscriber) {\r\n          activitySubscriber.complete()\r\n          activitySubscriber = undefined\r\n        }\r\n      },\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Processes activity attachments.\r\n * @param activity The activity to process for attachments.\r\n * @returns A promise that resolves to the activity with all attachments converted.\r\n */\r\nasync function processAttachments (activity: Activity): Promise<Attachment[]> {\r\n  if (activity.type !== 'message' || !activity.attachments?.length) {\r\n    return activity.attachments || []\r\n  }\r\n\r\n  const attachments: Attachment[] = []\r\n  for (const attachment of activity.attachments) {\r\n    const processed = await processBlobAttachment(attachment)\r\n    attachments.push(processed)\r\n  }\r\n\r\n  return attachments\r\n}\r\n\r\n/**\r\n * Processes a blob attachment to convert its content URL to a data URL.\r\n * @param attachment The attachment to process.\r\n * @returns A promise that resolves to the processed attachment.\r\n */\r\nasync function processBlobAttachment (attachment: Attachment): Promise<Attachment> {\r\n  let newContentUrl = attachment.contentUrl\r\n  if (!newContentUrl?.startsWith('blob:')) {\r\n    return attachment\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(newContentUrl)\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch blob URL: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    const blob = await response.blob()\r\n    const arrayBuffer = await blob.arrayBuffer()\r\n    const base64 = arrayBufferToBase64(arrayBuffer)\r\n    newContentUrl = `data:${blob.type};base64,${base64}`\r\n  } catch (error) {\r\n    newContentUrl = attachment.contentUrl\r\n    logger.error('Error processing blob attachment:', newContentUrl, error)\r\n  }\r\n\r\n  return { ...attachment, contentUrl: newContentUrl }\r\n}\r\n\r\n/**\r\n * Converts an ArrayBuffer to a base64 string.\r\n * @param buffer The ArrayBuffer to convert.\r\n * @returns The base64 encoded string.\r\n */\r\nfunction arrayBufferToBase64 (buffer: ArrayBuffer): string {\r\n  // Node.js environment\r\n  const BufferClass = typeof globalThis.Buffer === 'function' ? globalThis.Buffer : undefined\r\n  if (BufferClass && typeof BufferClass.from === 'function') {\r\n    return BufferClass.from(buffer).toString('base64')\r\n  }\r\n\r\n  // Browser environment\r\n  let binary = ''\r\n  for (const byte of new Uint8Array(buffer)) {\r\n    binary += String.fromCharCode(byte)\r\n  }\r\n  return btoa(binary)\r\n}\r\n\r\n/**\r\n * Creates an RxJS Observable that wraps an asynchronous function execution.\r\n *\r\n * @typeParam T - The type of value that the observable will emit\r\n * @param fn - An asynchronous function that receives a Subscriber and performs\r\n *             the desired async operation. The function should call subscriber.next()\r\n *             with results and subscriber.complete() when finished.\r\n * @returns A new Observable that executes the provided function and emits its results\r\n *\r\n * @remarks\r\n * This utility function provides a clean way to convert async/await patterns\r\n * into Observable streams, enabling integration with reactive programming patterns\r\n * used throughout the WebChat connection implementation.\r\n *\r\n * The created Observable handles promise resolution and rejection automatically,\r\n * converting them to appropriate next/error signals for subscribers.\r\n *\r\n * @example\r\n * ```typescript\r\n * const dataObservable = createObservable<string>(async (subscriber) => {\r\n *   try {\r\n *     const result = await fetchData();\r\n *     subscriber.next(result);\r\n *     subscriber.complete();\r\n *   } catch (error) {\r\n *     subscriber.error(error);\r\n *   }\r\n * });\r\n * ```\r\n */\r\nfunction createObservable<T> (fn: (subscriber: Subscriber<T>) => void): Observable<T> {\r\n  return new Observable<T>((subscriber: Subscriber<T>) => {\r\n    Promise.resolve(fn(subscriber)).catch((error) => subscriber.error(error))\r\n  })\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Activity } from '@microsoft/agents-activity'\r\n\r\n/**\r\n * Represents a request to execute a turn in a conversation.\r\n * This class encapsulates the activity to be executed during the turn.\r\n */\r\nexport class ExecuteTurnRequest {\r\n  /** The activity to be executed. */\r\n  activity?: Activity\r\n\r\n  /**\r\n   * Creates an instance of ExecuteTurnRequest.\r\n   * @param activity The activity to be executed.\r\n   */\r\n  constructor (activity?: Activity) {\r\n    this.activity = activity\r\n  }\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * Enum representing different Power Platform cloud environments.\r\n */\r\nexport enum PowerPlatformCloud {\r\n  /**\r\n   * Unknown cloud environment.\r\n   */\r\n  Unknown = 'Unknown',\r\n  /**\r\n   * Experimental cloud environment.\r\n   */\r\n  Exp = 'Exp',\r\n  /**\r\n   * Development cloud environment.\r\n   */\r\n  Dev = 'Dev',\r\n  /**\r\n   * Test cloud environment.\r\n   */\r\n  Test = 'Test',\r\n  /**\r\n   * Pre-production cloud environment.\r\n   */\r\n  Preprod = 'Preprod',\r\n  /**\r\n   * First release cloud environment.\r\n   */\r\n  FirstRelease = 'FirstRelease',\r\n  /**\r\n   * Production cloud environment.\r\n   */\r\n  Prod = 'Prod',\r\n  /**\r\n   * Government cloud environment.\r\n   */\r\n  Gov = 'Gov',\r\n  /**\r\n   * High security cloud environment.\r\n   */\r\n  High = 'High',\r\n  /**\r\n   * Department of Defense cloud environment.\r\n   */\r\n  DoD = 'DoD',\r\n  /**\r\n   * Mooncake cloud environment.\r\n   */\r\n  Mooncake = 'Mooncake',\r\n  /**\r\n   * Ex cloud environment.\r\n   */\r\n  Ex = 'Ex',\r\n  /**\r\n   * Rx cloud environment.\r\n   */\r\n  Rx = 'Rx',\r\n  /**\r\n   * Private cloud environment.\r\n   */\r\n  Prv = 'Prv',\r\n  /**\r\n   * Local cloud environment.\r\n   */\r\n  Local = 'Local',\r\n  /**\r\n   * French government cloud environment.\r\n   */\r\n  GovFR = 'GovFR',\r\n  /**\r\n   * Other cloud environment.\r\n   */\r\n  Other = 'Other',\r\n}\r\n", "/**\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AgentType } from './agentType'\r\nimport { ConnectionSettings } from './connectionSettings'\r\nimport { debug } from '@microsoft/agents-activity/logger'\r\nimport { PowerPlatformCloud } from './powerPlatformCloud'\r\nimport { PrebuiltBotStrategy } from './strategies/prebuiltBotStrategy'\r\nimport { PublishedBotStrategy } from './strategies/publishedBotStrategy'\r\n\r\nconst logger = debug('copilot-studio:power-platform')\r\n\r\n/**\r\n * Generates the connection URL for Copilot Studio.\r\n * @param settings - The connection settings.\r\n * @param conversationId - Optional conversation ID.\r\n * @returns The connection URL.\r\n * @throws Will throw an error if required settings are missing or invalid.\r\n */\r\nexport function getCopilotStudioConnectionUrl (\r\n  settings: ConnectionSettings,\r\n  conversationId?: string\r\n): string {\r\n  if (settings.directConnectUrl?.trim()) {\r\n    logger.debug(`Using direct connection: ${settings.directConnectUrl}`)\r\n    if (!isValidUri(settings.directConnectUrl)) {\r\n      throw new Error('directConnectUrl must be a valid URL')\r\n    }\r\n\r\n    // FIX for Missing Tenant ID\r\n    if (settings.directConnectUrl.toLowerCase().includes('tenants/00000000-0000-0000-0000-000000000000')) {\r\n      logger.debug(`Direct connection cannot be used, forcing default settings flow. Tenant ID is missing in the URL: ${settings.directConnectUrl}`)\r\n      // Direct connection cannot be used, ejecting and forcing the normal settings flow:\r\n      return getCopilotStudioConnectionUrl({ ...settings, directConnectUrl: '' }, conversationId)\r\n    }\r\n\r\n    return createURL(settings.directConnectUrl, conversationId).href\r\n  }\r\n\r\n  const cloudSetting = settings.cloud ?? PowerPlatformCloud.Prod\r\n  const agentType = settings.copilotAgentType ?? AgentType.Published\r\n\r\n  logger.debug(`Using cloud setting: ${cloudSetting}`)\r\n  logger.debug(`Using agent type: ${agentType}`)\r\n\r\n  if (!settings.environmentId?.trim()) {\r\n    throw new Error('EnvironmentId must be provided')\r\n  }\r\n\r\n  if (!settings.agentIdentifier?.trim()) {\r\n    throw new Error('AgentIdentifier must be provided')\r\n  }\r\n\r\n  if (cloudSetting === PowerPlatformCloud.Other) {\r\n    if (!settings.customPowerPlatformCloud?.trim()) {\r\n      throw new Error('customPowerPlatformCloud must be provided when PowerPlatformCloud is Other')\r\n    } else if (isValidUri(settings.customPowerPlatformCloud)) {\r\n      logger.debug(`Using custom Power Platform cloud: ${settings.customPowerPlatformCloud}`)\r\n    } else {\r\n      throw new Error(\r\n        'customPowerPlatformCloud must be a valid URL'\r\n      )\r\n    }\r\n  }\r\n\r\n  const host = getEnvironmentEndpoint(cloudSetting, settings.environmentId, settings.customPowerPlatformCloud)\r\n\r\n  const strategy = {\r\n    [AgentType.Published]: () => new PublishedBotStrategy({\r\n      host,\r\n      schema: settings.agentIdentifier!,\r\n    }),\r\n    [AgentType.Prebuilt]: () => new PrebuiltBotStrategy({\r\n      host,\r\n      identifier: settings.agentIdentifier!,\r\n    }),\r\n  }[agentType]()\r\n\r\n  const url = strategy.getConversationUrl(conversationId)\r\n  logger.debug(`Generated Copilot Studio connection URL: ${url}`)\r\n  return url\r\n}\r\n\r\n/**\r\n * Returns the Power Platform API Audience.\r\n * @param settings - Configuration Settings to use.\r\n * @param cloud - Optional Power Platform Cloud Hosting Agent.\r\n * @param cloudBaseAddress - Optional Power Platform API endpoint to use if Cloud is configured as \"other\".\r\n * @param directConnectUrl - Optional DirectConnection URL to a given Copilot Studio agent, if provided all other settings are ignored.\r\n * @returns The Power Platform Audience.\r\n * @throws Will throw an error if required settings are missing or invalid.\r\n */\r\nexport function getTokenAudience (\r\n  settings?: ConnectionSettings,\r\n  cloud: PowerPlatformCloud = PowerPlatformCloud.Unknown,\r\n  cloudBaseAddress: string = '',\r\n  directConnectUrl: string = ''): string {\r\n  if (!directConnectUrl && !settings?.directConnectUrl) {\r\n    if (cloud === PowerPlatformCloud.Other && !cloudBaseAddress) {\r\n      throw new Error('cloudBaseAddress must be provided when PowerPlatformCloudCategory is Other')\r\n    }\r\n    if (!settings && cloud === PowerPlatformCloud.Unknown) {\r\n      throw new Error('Either settings or cloud must be provided')\r\n    }\r\n    if (settings && settings.cloud && settings.cloud !== PowerPlatformCloud.Unknown) {\r\n      cloud = settings.cloud\r\n    }\r\n    if (cloud === PowerPlatformCloud.Other) {\r\n      if (cloudBaseAddress && isValidUri(cloudBaseAddress)) {\r\n        cloud = PowerPlatformCloud.Other\r\n      } else if (settings?.customPowerPlatformCloud && isValidUri(settings!.customPowerPlatformCloud)) {\r\n        cloud = PowerPlatformCloud.Other\r\n        cloudBaseAddress = settings.customPowerPlatformCloud\r\n      } else {\r\n        throw new Error('Either CustomPowerPlatformCloud or cloudBaseAddress must be provided when PowerPlatformCloudCategory is Other')\r\n      }\r\n    }\r\n    cloudBaseAddress ??= 'api.unknown.powerplatform.com'\r\n    return `https://${getEndpointSuffix(cloud, cloudBaseAddress)}/.default`\r\n  } else {\r\n    if (!directConnectUrl) {\r\n      directConnectUrl = settings?.directConnectUrl ?? ''\r\n    }\r\n    if (directConnectUrl && isValidUri(directConnectUrl)) {\r\n      if (decodeCloudFromURI(new URL(directConnectUrl)) === PowerPlatformCloud.Unknown) {\r\n        const cloudToTest: PowerPlatformCloud = settings?.cloud ?? cloud\r\n\r\n        if (cloudToTest === PowerPlatformCloud.Other || cloudToTest === PowerPlatformCloud.Unknown) {\r\n          throw new Error('Unable to resolve the PowerPlatform Cloud from DirectConnectUrl. The Token Audience resolver requires a specific PowerPlatformCloudCategory.')\r\n        }\r\n        if ((cloudToTest as PowerPlatformCloud) !== PowerPlatformCloud.Unknown) {\r\n          return `https://${getEndpointSuffix(cloudToTest, '')}/.default`\r\n        } else {\r\n          throw new Error('Unable to resolve the PowerPlatform Cloud from DirectConnectUrl. The Token Audience resolver requires a specific PowerPlatformCloudCategory.')\r\n        }\r\n      }\r\n      return `https://${getEndpointSuffix(decodeCloudFromURI(new URL(directConnectUrl)), '')}/.default`\r\n    } else {\r\n      throw new Error('DirectConnectUrl must be provided when DirectConnectUrl is set')\r\n    }\r\n  }\r\n}\r\nfunction isValidUri (uri: string): boolean {\r\n  try {\r\n    const absoluteUrl = uri.startsWith('http') ? uri : `https://${uri}`\r\n    const newUri = new URL(absoluteUrl)\r\n    return !!newUri\r\n  } catch {\r\n    return false\r\n  }\r\n}\r\n\r\nfunction createURL (base: string, conversationId?: string): URL {\r\n  const url = new URL(base)\r\n\r\n  if (!url.searchParams.has('api-version')) {\r\n    url.searchParams.append('api-version', '2022-03-01-preview')\r\n  }\r\n\r\n  if (url.pathname.endsWith('/')) {\r\n    url.pathname = url.pathname.slice(0, -1)\r\n  }\r\n\r\n  if (url.pathname.includes('/conversations')) {\r\n    url.pathname = url.pathname.substring(0, url.pathname.indexOf('/conversations'))\r\n  }\r\n\r\n  url.pathname = `${url.pathname}/conversations`\r\n  if (conversationId) {\r\n    url.pathname = `${url.pathname}/${conversationId}`\r\n  }\r\n\r\n  return url\r\n}\r\n\r\nfunction getEnvironmentEndpoint (\r\n  cloud: PowerPlatformCloud,\r\n  environmentId: string,\r\n  cloudBaseAddress?: string\r\n): URL {\r\n  if (cloud === PowerPlatformCloud.Other && (!cloudBaseAddress || !cloudBaseAddress.trim())) {\r\n    throw new Error('cloudBaseAddress must be provided when PowerPlatformCloud is Other')\r\n  }\r\n\r\n  cloudBaseAddress = cloudBaseAddress ?? 'api.unknown.powerplatform.com'\r\n\r\n  const normalizedResourceId = environmentId.toLowerCase().replaceAll('-', '')\r\n  const idSuffixLength = getIdSuffixLength(cloud)\r\n  const hexPrefix = normalizedResourceId.substring(0, normalizedResourceId.length - idSuffixLength)\r\n  const hexSuffix = normalizedResourceId.substring(normalizedResourceId.length - idSuffixLength)\r\n\r\n  return new URL(`https://${hexPrefix}.${hexSuffix}.environment.${getEndpointSuffix(cloud, cloudBaseAddress)}`)\r\n}\r\n\r\nfunction getEndpointSuffix (\r\n  category: PowerPlatformCloud,\r\n  cloudBaseAddress: string\r\n): string {\r\n  switch (category) {\r\n    case PowerPlatformCloud.Local:\r\n      return 'api.powerplatform.localhost'\r\n    case PowerPlatformCloud.Exp:\r\n      return 'api.exp.powerplatform.com'\r\n    case PowerPlatformCloud.Dev:\r\n      return 'api.dev.powerplatform.com'\r\n    case PowerPlatformCloud.Prv:\r\n      return 'api.prv.powerplatform.com'\r\n    case PowerPlatformCloud.Test:\r\n      return 'api.test.powerplatform.com'\r\n    case PowerPlatformCloud.Preprod:\r\n      return 'api.preprod.powerplatform.com'\r\n    case PowerPlatformCloud.FirstRelease:\r\n    case PowerPlatformCloud.Prod:\r\n      return 'api.powerplatform.com'\r\n    case PowerPlatformCloud.GovFR:\r\n      return 'api.gov.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.Gov:\r\n      return 'api.gov.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.High:\r\n      return 'api.high.powerplatform.microsoft.us'\r\n    case PowerPlatformCloud.DoD:\r\n      return 'api.appsplatform.us'\r\n    case PowerPlatformCloud.Mooncake:\r\n      return 'api.powerplatform.partner.microsoftonline.cn'\r\n    case PowerPlatformCloud.Ex:\r\n      return 'api.powerplatform.eaglex.ic.gov'\r\n    case PowerPlatformCloud.Rx:\r\n      return 'api.powerplatform.microsoft.scloud'\r\n    case PowerPlatformCloud.Other:\r\n      return cloudBaseAddress\r\n    default:\r\n      throw new Error(`Invalid cluster category value: ${category}`)\r\n  }\r\n}\r\n\r\nfunction getIdSuffixLength (cloud: PowerPlatformCloud): number {\r\n  switch (cloud) {\r\n    case PowerPlatformCloud.FirstRelease:\r\n    case PowerPlatformCloud.Prod:\r\n      return 2\r\n    default:\r\n      return 1\r\n  }\r\n}\r\n\r\nfunction decodeCloudFromURI (uri: URL): PowerPlatformCloud {\r\n  const host = uri.host.toLowerCase()\r\n\r\n  switch (host) {\r\n    case 'api.powerplatform.localhost':\r\n      return PowerPlatformCloud.Local\r\n    case 'api.exp.powerplatform.com':\r\n      return PowerPlatformCloud.Exp\r\n    case 'api.dev.powerplatform.com':\r\n      return PowerPlatformCloud.Dev\r\n    case 'api.prv.powerplatform.com':\r\n      return PowerPlatformCloud.Prv\r\n    case 'api.test.powerplatform.com':\r\n      return PowerPlatformCloud.Test\r\n    case 'api.preprod.powerplatform.com':\r\n      return PowerPlatformCloud.Preprod\r\n    case 'api.powerplatform.com':\r\n      return PowerPlatformCloud.Prod\r\n    case 'api.gov.powerplatform.microsoft.us':\r\n      return PowerPlatformCloud.GovFR\r\n    case 'api.high.powerplatform.microsoft.us':\r\n      return PowerPlatformCloud.High\r\n    case 'api.appsplatform.us':\r\n      return PowerPlatformCloud.DoD\r\n    case 'api.powerplatform.partner.microsoftonline.cn':\r\n      return PowerPlatformCloud.Mooncake\r\n    default:\r\n      return PowerPlatformCloud.Unknown\r\n  }\r\n}\r\n", "export * from './agentType.js'\r\nexport * from './connectionSettings.js'\r\nexport * from './copilotStudioClient.js'\r\nexport * from './copilotStudioConnectionSettings.js'\r\nexport * from './copilotStudioWebChat.js'\r\nexport * from './executeTurnRequest.js'\r\nexport * from './powerPlatformCloud.js'\r\nexport * from './powerPlatformEnvironment.js'\r\n"],
  "mappings": "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",
  "names": ["AgentType", "exports", "agentType_exports", "__export", "AgentType", "init_agentType", "__esmMin", "powerPlatformCloud_exports", "__export", "PowerPlatformCloud", "init_powerPlatformCloud", "__esmMin", "agentType_1", "powerPlatformCloud_1", "ConnectionOptions", "ConnectionSettings", "options", "cloud", "_a", "copilotAgentType", "_b", "authority", "exports", "loadCopilotStudioConnectionSettingsFromEnv", "_c", "_d", "_e", "_f", "ParseError", "message", "options", "noop", "_arg", "createParser", "callbacks", "onEvent", "onError", "onRetry", "onComment", "incompleteLine", "isFirstChunk", "id", "data", "eventType", "feed", "newChunk", "chunk", "complete", "incomplete", "splitLines", "line", "parseLine", "dispatchEvent", "fieldSeparatorIndex", "field", "offset", "value", "processField", "reset", "lines", "searchIndex", "crIndex", "lfIndex", "lineEnd", "CONNECTING", "OPEN", "CLOSED", "noop", "createEventSource", "optionsOrUrl", "getStream", "options", "onMessage", "onComment", "onConnect", "onDisconnect", "onScheduleReconnect", "fetch", "url", "initialLastEventId", "validate", "requestHeaders", "onCloseSubscribers", "subscribers", "emit", "event", "fn", "parser", "createParser", "onEvent", "onRetry", "request", "currentUrl", "controller", "lastEventId", "reconnectMs", "reconnectTimer", "readyState", "connect", "close", "getEventIterator", "getRequestOptions", "onFetchResponse", "err", "scheduleReconnect", "pullQueue", "pushQueue", "pullValue", "resolve", "value", "pushValue", "unsubscribe", "onClose", "error", "response", "body", "redirected", "status", "stream", "decoder", "reader", "open", "done", "msg", "ms", "mode", "credentials", "method", "redirect", "referrer", "referrerPolicy", "headers", "isFetchLike", "defaultAbstractions", "createSource", "require_ms", "__commonJSMin", "exports", "module", "s", "m", "h", "d", "w", "y", "val", "options", "type", "parse", "fmtLong", "fmtShort", "str", "match", "n", "ms", "msAbs", "plural", "name", "isPlural", "require_common", "__commonJSMin", "exports", "module", "setup", "env", "createDebug", "coerce", "disable", "enable", "enabled", "destroy", "key", "selectColor", "namespace", "hash", "i", "prevTime", "enableOverride", "namespacesCache", "enabledCache", "debug", "args", "self", "curr", "ms", "index", "match", "format", "formatter", "val", "extend", "v", "delimiter", "newDebug", "namespaces", "split", "ns", "matchesTemplate", "search", "template", "searchIndex", "templateIndex", "starIndex", "matchIndex", "name", "skip", "require_browser", "__commonJSMin", "exports", "module", "formatArgs", "save", "load", "useColors", "localstorage", "warned", "m", "args", "c", "index", "lastC", "match", "namespaces", "r", "formatters", "v", "error", "exports", "debug", "debug_1", "__importDefault", "loggerLevels", "Logger", "namespace", "level", "logger", "message", "args", "prebuiltBotStrategy_exports", "__export", "PrebuiltBotStrategy", "init_prebuiltBotStrategy", "__esmMin", "settings", "identifier", "host", "conversationId", "conversationUrl", "publishedBotStrategy_exports", "__export", "PublishedBotStrategy", "init_publishedBotStrategy", "__esmMin", "settings", "schema", "host", "conversationId", "conversationUrl", "powerPlatformEnvironment_exports", "__export", "getCopilotStudioConnectionUrl", "getTokenAudience", "settings", "conversationId", "_a", "_b", "_c", "_d", "_e", "_f", "logger", "isValidUri", "createURL", "cloudSetting", "agentType", "host", "getEnvironmentEndpoint", "url", "PublishedBotStrategy", "PrebuiltBotStrategy", "cloud", "cloudBaseAddress", "directConnectUrl", "getEndpointSuffix", "decodeCloudFromURI", "cloudToTest", "uri", "absoluteUrl", "base", "environmentId", "normalizedResourceId", "idSuffixLength", "getIdSuffixLength", "hexPrefix", "hexSuffix", "category", "import_logger", "init_powerPlatformEnvironment", "__esmMin", "init_agentType", "init_powerPlatformCloud", "init_prebuiltBotStrategy", "init_publishedBotStrategy", "require_util", "__commonJSMin", "exports", "util", "_", "assertIs", "_arg", "assertNever", "_x", "items", "obj", "item", "validKeys", "k", "filtered", "e", "object", "keys", "key", "arr", "checker", "val", "joinValues", "array", "separator", "value", "objectUtil", "first", "second", "getParsedType", "data", "require_ZodError", "__commonJSMin", "exports", "util_js_1", "quotelessJson", "obj", "ZodError", "_ZodError", "issues", "sub", "subs", "actualProto", "_mapper", "mapper", "issue", "fieldErrors", "processError", "error", "curr", "i", "el", "value", "formErrors", "firstEl", "require_en", "__commonJSMin", "exports", "ZodError_js_1", "util_js_1", "errorMap", "issue", "_ctx", "message", "require_errors", "__commonJSMin", "exports", "__importDefault", "mod", "setErrorMap", "getErrorMap", "en_js_1", "overrideErrorMap", "map", "require_parseUtil", "__commonJSMin", "exports", "__importDefault", "mod", "addIssueToContext", "errors_js_1", "en_js_1", "makeIssue", "params", "data", "path", "errorMaps", "issueData", "fullPath", "fullIssue", "errorMessage", "maps", "m", "map", "ctx", "overrideMap", "issue", "x", "ParseStatus", "_ParseStatus", "status", "results", "arrayValue", "s", "pairs", "syncPairs", "pair", "key", "value", "finalObject", "DIRTY", "OK", "isAborted", "isDirty", "isValid", "isAsync", "require_typeAliases", "__commonJSMin", "exports", "require_errorUtil", "__commonJSMin", "exports", "errorUtil", "message", "require_types", "__commonJSMin", "exports", "datetimeRegex", "custom", "ZodError_js_1", "errors_js_1", "errorUtil_js_1", "parseUtil_js_1", "util_js_1", "ParseInputLazyPath", "parent", "value", "path", "key", "handleResult", "ctx", "result", "error", "processCreateParams", "params", "errorMap", "invalid_type_error", "required_error", "description", "iss", "_a", "_b", "message", "ZodType", "input", "data", "err", "maybeAsyncResult", "check", "getIssueProperties", "val", "setError", "refinementData", "refinement", "ZodEffects", "ZodFirstPartyTypeKind", "def", "ZodOptional", "ZodNullable", "ZodArray", "ZodPromise", "option", "ZodUnion", "incoming", "ZodIntersection", "transform", "defaultValueFunc", "ZodDefault", "ZodBranded", "catchValueFunc", "ZodCatch", "This", "target", "ZodPipeline", "ZodReadonly", "cuidRegex", "cuid2Regex", "ulidRegex", "uuidRegex", "nanoidRegex", "jwtRegex", "durationRegex", "emailRegex", "_emojiRegex", "emojiRegex", "ipv4Regex", "ipv4CidrRegex", "ipv6Regex", "ipv6CidrRegex", "base64Regex", "base64urlRegex", "dateRegexSource", "dateRegex", "timeRegexSource", "args", "secondsRegexSource", "secondsQuantifier", "timeRegex", "regex", "opts", "isValidIP", "ip", "version", "isValidJWT", "jwt", "alg", "header", "base64", "decoded", "isValidCidr", "ZodString", "_ZodString", "status", "tooBig", "tooSmall", "validation", "options", "minLength", "maxLength", "len", "ch", "min", "max", "floatSafeRemainder", "step", "valDecCount", "stepDecCount", "decCount", "valInt", "stepInt", "ZodNumber", "_ZodNumber", "kind", "inclusive", "ZodBigInt", "_ZodBigInt", "ZodBoolean", "ZodDate", "_ZodDate", "minDate", "maxDate", "ZodSymbol", "ZodUndefined", "ZodNull", "ZodAny", "ZodUnknown", "ZodNever", "ZodVoid", "_ZodArray", "item", "i", "schema", "deepPartialify", "ZodObject", "newShape", "fieldSchema", "ZodTuple", "_ZodObject", "shape", "keys", "shapeKeys", "extraKeys", "pairs", "keyValidator", "unknownKeys", "catchall", "syncPairs", "pair", "issue", "_c", "_d", "defaultError", "augmentation", "merging", "index", "mask", "newField", "createZodEnum", "handleResults", "results", "unionErrors", "childCtx", "dirty", "issues", "types", "getDiscriminator", "type", "ZodLazy", "ZodLiteral", "ZodEnum", "ZodNativeEnum", "ZodDiscriminatedUnion", "_ZodDiscriminatedUnion", "discriminator", "discriminatorValue", "optionsMap", "discriminatorValues", "mergeValues", "a", "b", "aType", "bType", "bKeys", "sharedKeys", "newObj", "sharedValue", "newArray", "itemA", "itemB", "handleParsed", "parsedLeft", "parsedRight", "merged", "left", "right", "_ZodTuple", "items", "itemIndex", "x", "rest", "schemas", "ZodRecord", "_ZodRecord", "keyType", "valueType", "first", "second", "third", "ZodMap", "finalMap", "ZodSet", "_ZodSet", "finalizeSet", "elements", "parsedSet", "element", "minSize", "maxSize", "size", "ZodFunction", "_ZodFunction", "makeArgsIssue", "makeReturnsIssue", "returns", "fn", "me", "parsedArgs", "e", "parsedReturns", "returnType", "func", "getter", "values", "_ZodEnum", "expectedValues", "enumValues", "newDef", "opt", "nativeEnumValues", "promisified", "effect", "checkCtx", "arg", "processed", "executeRefinement", "acc", "inner", "base", "preprocess", "newCtx", "ZodNaN", "_ZodPipeline", "inResult", "freeze", "cleanParams", "p", "_params", "fatal", "r", "_fatal", "instanceOfType", "cls", "stringType", "numberType", "nanType", "bigIntType", "booleanType", "dateType", "symbolType", "undefinedType", "nullType", "anyType", "unknownType", "neverType", "voidType", "arrayType", "objectType", "strictObjectType", "unionType", "discriminatedUnionType", "intersectionType", "tupleType", "recordType", "mapType", "setType", "functionType", "lazyType", "literalType", "enumType", "nativeEnumType", "promiseType", "effectsType", "optionalType", "nullableType", "preprocessType", "pipelineType", "ostring", "onumber", "oboolean", "require_external", "__commonJSMin", "exports", "__createBinding", "o", "m", "k", "k2", "desc", "__exportStar", "p", "require_zod", "__commonJSMin", "exports", "__createBinding", "o", "m", "k", "k2", "desc", "__setModuleDefault", "v", "__importStar", "mod", "result", "__exportStar", "p", "z", "zod_1", "ActionTypes", "exports", "zod_1", "SemanticActionStateTypes", "exports", "zod_1", "AttachmentLayoutTypes", "exports", "Channels", "exports", "zod_1", "EndOfConversationCodes", "exports", "zod_1", "MembershipSourceTypes", "exports", "zod_1", "MembershipTypes", "exports", "zod_1", "RoleTypes", "exports", "addAIToActivity", "activity", "citations", "usageInfo", "aiEntity", "_a", "exports", "zod_1", "exports", "require_max", "__commonJSMin", "exports", "require_nil", "__commonJSMin", "exports", "require_regex", "__commonJSMin", "exports", "require_validate", "__commonJSMin", "exports", "regex_js_1", "validate", "uuid", "require_parse", "__commonJSMin", "exports", "validate_js_1", "parse", "uuid", "v", "require_stringify", "__commonJSMin", "exports", "validate_js_1", "byteToHex", "i", "unsafeStringify", "arr", "offset", "stringify", "uuid", "require_rng", "__commonJSMin", "exports", "getRandomValues", "rnds8", "rng", "require_v1", "__commonJSMin", "exports", "rng_js_1", "stringify_js_1", "_state", "v1", "options", "buf", "offset", "_a", "_b", "_c", "_d", "bytes", "isV6", "optionsKeys", "v1Bytes", "now", "rnds", "updateV1State", "state", "msecs", "nsecs", "clockseq", "node", "tl", "tmh", "n", "require_v1ToV6", "__commonJSMin", "exports", "parse_js_1", "stringify_js_1", "v1ToV6", "uuid", "v1Bytes", "v6Bytes", "_v1ToV6", "require_md5", "__commonJSMin", "exports", "md5", "bytes", "words", "uint8ToUint32", "md5Bytes", "wordsToMd5", "uint32ToUint8", "input", "i", "getOutputLength", "inputLength8", "x", "len", "xpad", "a", "b", "c", "d", "olda", "oldb", "oldc", "oldd", "md5ff", "md5gg", "md5hh", "md5ii", "safeAdd", "output", "y", "lsw", "bitRotateLeft", "num", "cnt", "md5cmn", "q", "s", "t", "require_v35", "__commonJSMin", "exports", "parse_js_1", "stringify_js_1", "stringToBytes", "str", "bytes", "i", "v35", "version", "hash", "value", "namespace", "buf", "offset", "valueBytes", "namespaceBytes", "require_v3", "__commonJSMin", "exports", "md5_js_1", "v35_js_1", "v35_js_2", "v3", "value", "namespace", "buf", "offset", "require_native", "__commonJSMin", "exports", "randomUUID", "require_v4", "__commonJSMin", "exports", "native_js_1", "rng_js_1", "stringify_js_1", "v4", "options", "buf", "offset", "_a", "_b", "_c", "rnds", "i", "require_sha1", "__commonJSMin", "exports", "f", "s", "x", "y", "z", "ROTL", "n", "sha1", "bytes", "K", "H", "newBytes", "l", "N", "M", "i", "arr", "j", "W", "t", "a", "b", "c", "d", "e", "T", "require_v5", "__commonJSMin", "exports", "sha1_js_1", "v35_js_1", "v35_js_2", "v5", "value", "namespace", "buf", "offset", "require_v6", "__commonJSMin", "exports", "stringify_js_1", "v1_js_1", "v1ToV6_js_1", "v6", "options", "buf", "offset", "bytes", "require_v6ToV1", "__commonJSMin", "exports", "parse_js_1", "stringify_js_1", "v6ToV1", "uuid", "v6Bytes", "v1Bytes", "_v6ToV1", "require_v7", "__commonJSMin", "exports", "rng_js_1", "stringify_js_1", "_state", "v7", "options", "buf", "offset", "_a", "_b", "_c", "bytes", "v7Bytes", "now", "rnds", "updateV7State", "state", "msecs", "seq", "require_version", "__commonJSMin", "exports", "validate_js_1", "version", "uuid", "require_cjs_browser", "__commonJSMin", "exports", "max_js_1", "nil_js_1", "parse_js_1", "stringify_js_1", "v1_js_1", "v1ToV6_js_1", "v3_js_1", "v4_js_1", "v5_js_1", "v6_js_1", "v6ToV1_js_1", "v7_js_1", "validate_js_1", "version_js_1", "zod_1", "exports", "zod_1", "entity_1", "semanticActionStateTypes_1", "exports", "zod_1", "actionTypes_1", "exports", "zod_1", "cardAction_1", "exports", "zod_1", "ActivityEventNames", "exports", "zod_1", "ActivityImportance", "exports", "zod_1", "ActivityTypes", "exports", "zod_1", "exports", "zod_1", "roleTypes_1", "exports", "zod_1", "roleTypes_1", "exports", "zod_1", "channelAccount_1", "conversationAccount_1", "exports", "zod_1", "DeliveryModes", "exports", "zod_1", "InputHints", "exports", "zod_1", "MessageReactionTypes", "exports", "zod_1", "messageReactionTypes_1", "exports", "zod_1", "TextFormatTypes", "exports", "zod_1", "exports", "uuid_1", "zod_1", "semanticAction_1", "suggestedActions_1", "activityEventNames_1", "activityImportance_1", "activityTypes_1", "attachment_1", "attachmentLayoutTypes_1", "channelAccount_1", "channels_1", "conversationAccount_1", "conversationReference_1", "endOfConversationCodes_1", "deliveryModes_1", "entity_1", "inputHints_1", "messageReaction_1", "textFormatTypes_1", "textHighlight_1", "exports", "s", "Activity", "_Activity", "t", "json", "o", "parsedActivity", "activity", "reference", "continuationActivityObj", "isIncoming", "_a", "_b", "_c", "activityCopy", "key", "result", "i", "removeMention", "entity", "mentions", "mention", "text", "foundTag", "iAtStart", "iAtEnd", "iAtClose", "followingText", "tagContent", "prefixText", "id", "mentionsFiltered", "replyId", "exports", "zod_1", "ActivityTreatments", "exports", "actionTypes_1", "exports", "semanticActionStateTypes_1", "attachmentLayoutTypes_1", "channels_1", "endOfConversationCodes_1", "membershipSourceTypes_1", "membershipTypes_1", "roleTypes_1", "__exportStar", "activity_1", "activityEventNames_1", "activityImportance_1", "activityTypes_1", "callerIdConstants_1", "deliveryModes_1", "inputHints_1", "messageReactionTypes_1", "textFormatTypes_1", "activityTreatments_1", "logger_1", "executeTurnRequest_exports", "__export", "ExecuteTurnRequest", "init_executeTurnRequest", "__esmMin", "activity", "require_package", "__commonJSMin", "exports", "module", "os_exports", "__export", "os_default", "init_os", "__esmMin", "eventsource_client_1", "powerPlatformEnvironment_1", "agents_activity_1", "executeTurnRequest_1", "logger_1", "package_json_1", "os_1", "__importDefault", "logger", "CopilotStudioClient", "_CopilotStudioClient", "settings", "token", "url", "body", "method", "eventSource", "init", "response", "data", "event", "activity", "_b", "_a", "error", "versionString", "userAgent", "responseHeaders", "islandExperimentalUrl", "sanitizedHeaders", "value", "key", "emitStartConversationEvent", "uriStart", "question", "conversationId", "activityObj", "localConversationId", "uriExecute", "qbody", "exports", "isFunction", "value", "exports", "createErrorClass", "createImpl", "_super", "instance", "ctorFunc", "exports", "createErrorClass_1", "exports", "_super", "errors", "err", "arrRemove", "arr", "item", "index", "exports", "isFunction_1", "UnsubscriptionError_1", "arrRemove_1", "Subscription", "initialTeardown", "errors", "_parentage", "_parentage_1", "__values", "_parentage_1_1", "parent_1", "initialFinalizer", "e", "_finalizers", "_finalizers_1", "_finalizers_1_1", "finalizer", "execFinalizer", "err", "__spreadArray", "__read", "teardown", "_a", "parent", "empty", "exports", "isSubscription", "value", "exports", "exports", "handler", "timeout", "args", "_i", "delegate", "__spreadArray", "__read", "handle", "config_1", "timeoutProvider_1", "reportUnhandledError", "err", "onUnhandledError", "exports", "noop", "exports", "exports", "createNotification", "errorNotification", "error", "nextNotification", "value", "kind", "config_1", "context", "errorContext", "cb", "isRoot", "_a", "errorThrown", "error", "exports", "captureError", "err", "isFunction_1", "Subscription_1", "config_1", "reportUnhandledError_1", "noop_1", "NotificationFactories_1", "timeoutProvider_1", "errorContext_1", "Subscriber", "_super", "__extends", "destination", "_this", "exports", "next", "error", "complete", "SafeSubscriber", "value", "handleStoppedNotification", "err", "_bind", "bind", "fn", "thisArg", "ConsumerObserver", "partialObserver", "handleUnhandledError", "observerOrNext", "context_1", "defaultErrorHandler", "notification", "subscriber", "onStoppedNotification", "exports", "identity", "x", "exports", "identity_1", "pipe", "fns", "_i", "pipeFromArray", "exports", "input", "prev", "fn", "Subscriber_1", "Subscription_1", "observable_1", "pipe_1", "config_1", "isFunction_1", "errorContext_1", "Observable", "subscribe", "operator", "observable", "observerOrNext", "error", "complete", "_this", "subscriber", "isSubscriber", "_a", "source", "sink", "err", "next", "promiseCtor", "getPromiseCtor", "resolve", "reject", "value", "operations", "_i", "x", "exports", "isObserver", "isFunction_1", "hasLift", "source", "exports", "operate", "init", "liftedSource", "err", "Subscriber_1", "createOperatorSubscriber", "destination", "onNext", "onComplete", "onError", "onFinalize", "OperatorSubscriber", "exports", "_super", "__extends", "shouldUnsubscribe", "_this", "value", "err", "closed_1", "_a", "lift_1", "OperatorSubscriber_1", "refCount", "source", "subscriber", "connection", "refCounter", "sharedConnection", "conn", "exports", "Observable_1", "Subscription_1", "refCount_1", "OperatorSubscriber_1", "lift_1", "ConnectableObservable", "_super", "__extends", "source", "subjectFactory", "_this", "subscriber", "subject", "_connection", "connection", "subject_1", "err", "exports", "exports", "Subscription_1", "exports", "callback", "request", "cancel", "delegate", "handle", "timestamp", "args", "_i", "__spreadArray", "__read", "Observable_1", "performanceTimestampProvider_1", "animationFrameProvider_1", "animationFrames", "timestampProvider", "animationFramesFactory", "DEFAULT_ANIMATION_FRAMES", "exports", "subscriber", "provider", "start", "id", "run", "timestamp", "now", "createErrorClass_1", "exports", "_super", "Observable_1", "Subscription_1", "ObjectUnsubscribedError_1", "arrRemove_1", "errorContext_1", "Subject", "_super", "__extends", "_this", "operator", "subject", "AnonymousSubject", "value", "_b", "__values", "_c", "observer", "err", "observers", "_a", "subscriber", "hasError", "isStopped", "thrownError", "observable", "destination", "source", "exports", "Subject_1", "BehaviorSubject", "_super", "__extends", "_value", "_this", "subscriber", "subscription", "_a", "hasError", "thrownError", "value", "exports", "exports", "Subject_1", "dateTimestampProvider_1", "ReplaySubject", "_super", "__extends", "_bufferSize", "_windowTime", "_timestampProvider", "_this", "value", "_a", "isStopped", "_buffer", "_infiniteTimeWindow", "subscriber", "subscription", "copy", "i", "adjustedBufferSize", "now", "last", "exports", "Subject_1", "AsyncSubject", "_super", "__extends", "_this", "subscriber", "_a", "hasError", "_hasValue", "_value", "thrownError", "isStopped", "_isComplete", "value", "exports", "Subscription_1", "Action", "_super", "__extends", "scheduler", "work", "state", "delay", "exports", "exports", "handler", "timeout", "args", "_i", "delegate", "__spreadArray", "__read", "handle", "Action_1", "intervalProvider_1", "arrRemove_1", "AsyncAction", "_super", "__extends", "scheduler", "work", "_this", "state", "delay", "id", "_a", "_id", "_scheduler", "error", "_delay", "errored", "errorValue", "e", "actions", "exports", "nextHandle", "resolved", "activeHandles", "findAndClearHandle", "handle", "exports", "cb", "Immediate_1", "setImmediate", "clearImmediate", "exports", "args", "_i", "delegate", "__spreadArray", "__read", "handle", "AsyncAction_1", "immediateProvider_1", "AsapAction", "_super", "__extends", "scheduler", "work", "_this", "id", "delay", "actions", "_a", "exports", "dateTimestampProvider_1", "Scheduler", "schedulerActionCtor", "now", "work", "delay", "state", "exports", "Scheduler_1", "AsyncScheduler", "_super", "__extends", "SchedulerAction", "now", "_this", "action", "actions", "error", "exports", "AsyncScheduler_1", "AsapScheduler", "_super", "__extends", "action", "flushId", "actions", "error", "exports", "AsapAction_1", "AsapScheduler_1", "exports", "AsyncAction_1", "AsyncScheduler_1", "exports", "AsyncAction_1", "QueueAction", "_super", "__extends", "scheduler", "work", "_this", "state", "delay", "id", "exports", "AsyncScheduler_1", "QueueScheduler", "_super", "__extends", "exports", "QueueAction_1", "QueueScheduler_1", "exports", "AsyncAction_1", "animationFrameProvider_1", "AnimationFrameAction", "_super", "__extends", "scheduler", "work", "_this", "id", "delay", "actions", "_a", "exports", "AsyncScheduler_1", "AnimationFrameScheduler", "_super", "__extends", "action", "flushId", "actions", "error", "exports", "AnimationFrameAction_1", "AnimationFrameScheduler_1", "exports", "AsyncAction_1", "Subscription_1", "AsyncScheduler_1", "VirtualTimeScheduler", "_super", "__extends", "schedulerActionCtor", "maxFrames", "VirtualAction", "_this", "_a", "actions", "error", "action", "exports", "scheduler", "work", "index", "state", "delay", "id", "a", "b", "Observable_1", "exports", "subscriber", "empty", "scheduler", "emptyScheduled", "isFunction_1", "isScheduler", "value", "exports", "isFunction_1", "isScheduler_1", "last", "arr", "popResultSelector", "args", "exports", "popScheduler", "popNumber", "defaultValue", "exports", "x", "isFunction_1", "isPromise", "value", "exports", "observable_1", "isFunction_1", "isInteropObservable", "input", "exports", "isFunction_1", "isAsyncIterable", "obj", "exports", "createInvalidObservableTypeError", "input", "exports", "getSymbolIterator", "exports", "iterator_1", "isFunction_1", "isIterable", "input", "exports", "isFunction_1", "readableStreamLikeToAsyncGenerator", "readableStream", "reader", "__await", "_a", "_b", "value", "done", "exports", "isReadableStreamLike", "obj", "isArrayLike_1", "isPromise_1", "Observable_1", "isInteropObservable_1", "isAsyncIterable_1", "throwUnobservableError_1", "isIterable_1", "isReadableStreamLike_1", "isFunction_1", "reportUnhandledError_1", "observable_1", "innerFrom", "input", "fromInteropObservable", "fromArrayLike", "fromPromise", "fromAsyncIterable", "fromIterable", "fromReadableStreamLike", "exports", "obj", "subscriber", "obs", "array", "i", "promise", "value", "err", "iterable", "iterable_1", "__values", "iterable_1_1", "asyncIterable", "process", "readableStream", "asyncIterable_1", "__asyncValues", "asyncIterable_1_1", "executeSchedule", "parentSubscription", "scheduler", "work", "delay", "repeat", "scheduleSubscription", "exports", "executeSchedule_1", "lift_1", "OperatorSubscriber_1", "observeOn", "scheduler", "delay", "source", "subscriber", "value", "err", "exports", "lift_1", "subscribeOn", "scheduler", "delay", "source", "subscriber", "exports", "innerFrom_1", "observeOn_1", "subscribeOn_1", "scheduleObservable", "input", "scheduler", "exports", "innerFrom_1", "observeOn_1", "subscribeOn_1", "schedulePromise", "input", "scheduler", "exports", "Observable_1", "scheduleArray", "input", "scheduler", "subscriber", "i", "exports", "Observable_1", "iterator_1", "isFunction_1", "executeSchedule_1", "scheduleIterable", "input", "scheduler", "subscriber", "iterator", "value", "done", "_a", "err", "exports", "Observable_1", "executeSchedule_1", "scheduleAsyncIterable", "input", "scheduler", "subscriber", "iterator", "result", "exports", "scheduleAsyncIterable_1", "isReadableStreamLike_1", "scheduleReadableStreamLike", "input", "scheduler", "exports", "scheduleObservable_1", "schedulePromise_1", "scheduleArray_1", "scheduleIterable_1", "scheduleAsyncIterable_1", "isInteropObservable_1", "isPromise_1", "isArrayLike_1", "isIterable_1", "isAsyncIterable_1", "throwUnobservableError_1", "isReadableStreamLike_1", "scheduleReadableStreamLike_1", "scheduled", "input", "scheduler", "exports", "scheduled_1", "innerFrom_1", "from", "input", "scheduler", "exports", "args_1", "from_1", "of", "args", "_i", "scheduler", "exports", "Observable_1", "isFunction_1", "throwError", "errorOrErrorFactory", "scheduler", "errorFactory", "init", "subscriber", "exports", "empty_1", "of_1", "throwError_1", "isFunction_1", "NotificationKind", "exports", "Notification", "kind", "value", "error", "observer", "observeNotification", "nextHandler", "errorHandler", "completeHandler", "_a", "nextOrObserver", "complete", "result", "err", "notification", "_d", "_b", "_c", "Observable_1", "isFunction_1", "isObservable", "obj", "exports", "createErrorClass_1", "exports", "_super", "EmptyError_1", "lastValueFrom", "source", "config", "hasConfig", "resolve", "reject", "_hasValue", "_value", "value", "exports", "EmptyError_1", "Subscriber_1", "firstValueFrom", "source", "config", "hasConfig", "resolve", "reject", "subscriber", "value", "exports", "createErrorClass_1", "exports", "_super", "createErrorClass_1", "exports", "_super", "message", "createErrorClass_1", "exports", "_super", "message", "isValidDate", "value", "exports", "async_1", "isDate_1", "lift_1", "innerFrom_1", "createErrorClass_1", "OperatorSubscriber_1", "executeSchedule_1", "exports", "_super", "info", "timeout", "config", "schedulerArg", "_a", "first", "each", "_b", "_with", "timeoutErrorFactory", "_c", "scheduler", "_d", "meta", "source", "subscriber", "originalSourceSubscription", "timerSubscription", "lastValue", "seen", "startTimer", "delay", "err", "value", "lift_1", "OperatorSubscriber_1", "map", "project", "thisArg", "source", "subscriber", "index", "value", "exports", "map_1", "isArray", "callOrApply", "fn", "args", "__spreadArray", "__read", "mapOneOrManyArgs", "exports", "isScheduler_1", "Observable_1", "subscribeOn_1", "mapOneOrManyArgs_1", "observeOn_1", "AsyncSubject_1", "bindCallbackInternals", "isNodeStyle", "callbackFunc", "resultSelector", "scheduler", "args", "_i", "_this", "subject", "uninitialized", "subscriber", "subs", "isAsync_1", "isComplete_1", "__spreadArray", "__read", "results", "err", "exports", "bindCallbackInternals_1", "bindCallback", "callbackFunc", "resultSelector", "scheduler", "exports", "bindCallbackInternals_1", "bindNodeCallback", "callbackFunc", "resultSelector", "scheduler", "exports", "isArray", "getPrototypeOf", "objectProto", "getKeys", "argsArgArrayOrObject", "args", "first_1", "isPOJO", "keys", "key", "exports", "obj", "createObject", "keys", "values", "result", "key", "exports", "Observable_1", "argsArgArrayOrObject_1", "from_1", "identity_1", "mapOneOrManyArgs_1", "args_1", "createObject_1", "OperatorSubscriber_1", "executeSchedule_1", "combineLatest", "args", "_i", "scheduler", "resultSelector", "_a", "observables", "keys", "result", "combineLatestInit", "values", "exports", "valueTransform", "subscriber", "maybeSchedule", "length", "active", "remainingFirstValues", "i", "source", "hasFirstValue", "value", "execute", "subscription", "innerFrom_1", "executeSchedule_1", "OperatorSubscriber_1", "mergeInternals", "source", "subscriber", "project", "concurrent", "onBeforeNext", "expand", "innerSubScheduler", "additionalFinalizer", "buffer", "active", "index", "isComplete", "checkComplete", "outerNext", "value", "doInnerSub", "innerComplete", "innerValue", "bufferedValue", "err", "exports", "map_1", "innerFrom_1", "lift_1", "mergeInternals_1", "isFunction_1", "mergeMap", "project", "resultSelector", "concurrent", "a", "b", "ii", "source", "subscriber", "exports", "mergeMap_1", "identity_1", "mergeAll", "concurrent", "exports", "mergeAll_1", "concatAll", "exports", "concatAll_1", "args_1", "from_1", "concat", "args", "_i", "exports", "Observable_1", "innerFrom_1", "defer", "observableFactory", "subscriber", "exports", "Subject_1", "Observable_1", "defer_1", "DEFAULT_CONFIG", "connectable", "source", "config", "connection", "connector", "_a", "resetOnDisconnect", "subject", "result", "subscriber", "exports", "Observable_1", "argsArgArrayOrObject_1", "innerFrom_1", "args_1", "OperatorSubscriber_1", "mapOneOrManyArgs_1", "createObject_1", "forkJoin", "args", "_i", "resultSelector", "_a", "sources", "keys", "result", "subscriber", "length", "values", "remainingCompletions", "remainingEmissions", "sourceIndex", "hasValue", "value", "exports", "innerFrom_1", "Observable_1", "mergeMap_1", "isArrayLike_1", "isFunction_1", "mapOneOrManyArgs_1", "nodeEventEmitterMethods", "eventTargetMethods", "jqueryMethods", "fromEvent", "target", "eventName", "options", "resultSelector", "_a", "__read", "isEventTarget", "methodName", "handler", "isNodeStyleEventEmitter", "toCommonHandlerRegistry", "isJQueryStyleEventEmitter", "add", "remove", "subTarget", "subscriber", "args", "_i", "exports", "Observable_1", "isFunction_1", "mapOneOrManyArgs_1", "fromEventPattern", "addHandler", "removeHandler", "resultSelector", "subscriber", "handler", "e", "_i", "retValue", "exports", "identity_1", "isScheduler_1", "defer_1", "scheduleIterable_1", "generate", "initialStateOrOptions", "condition", "iterate", "resultSelectorOrScheduler", "scheduler", "resultSelector", "initialState", "_a", "_b", "gen", "state", "exports", "defer_1", "iif", "condition", "trueResult", "falseResult", "exports", "Observable_1", "async_1", "isScheduler_1", "isDate_1", "timer", "dueTime", "intervalOrScheduler", "scheduler", "intervalDuration", "subscriber", "due", "n", "exports", "async_1", "timer_1", "interval", "period", "scheduler", "exports", "mergeAll_1", "innerFrom_1", "empty_1", "args_1", "from_1", "merge", "args", "_i", "scheduler", "concurrent", "sources", "exports", "Observable_1", "noop_1", "exports", "never", "isArray", "argsOrArgArray", "args", "exports", "Observable_1", "argsOrArgArray_1", "OperatorSubscriber_1", "noop_1", "innerFrom_1", "onErrorResumeNext", "sources", "_i", "nextSources", "subscriber", "sourceIndex", "subscribeNext", "nextSource", "innerSubscriber", "exports", "from_1", "pairs", "obj", "scheduler", "exports", "not", "pred", "thisArg", "value", "index", "exports", "lift_1", "OperatorSubscriber_1", "filter", "predicate", "thisArg", "source", "subscriber", "index", "value", "exports", "not_1", "filter_1", "innerFrom_1", "partition", "source", "predicate", "thisArg", "exports", "Observable_1", "innerFrom_1", "argsOrArgArray_1", "OperatorSubscriber_1", "race", "sources", "_i", "raceInit", "exports", "subscriber", "subscriptions", "i", "value", "s", "Observable_1", "empty_1", "range", "start", "count", "scheduler", "end", "subscriber", "n", "exports", "Observable_1", "innerFrom_1", "empty_1", "using", "resourceFactory", "observableFactory", "subscriber", "resource", "result", "source", "exports", "Observable_1", "innerFrom_1", "argsOrArgArray_1", "empty_1", "OperatorSubscriber_1", "args_1", "zip", "args", "_i", "resultSelector", "sources", "subscriber", "buffers", "completed", "sourceIndex", "value", "buffer", "result", "__spreadArray", "__read", "i", "exports", "require_types", "__commonJSMin", "exports", "lift_1", "innerFrom_1", "OperatorSubscriber_1", "audit", "durationSelector", "source", "subscriber", "hasValue", "lastValue", "durationSubscriber", "isComplete", "endDuration", "value", "cleanupDuration", "exports", "async_1", "audit_1", "timer_1", "auditTime", "duration", "scheduler", "exports", "lift_1", "noop_1", "OperatorSubscriber_1", "innerFrom_1", "buffer", "closingNotifier", "source", "subscriber", "currentBuffer", "value", "b", "exports", "lift_1", "OperatorSubscriber_1", "arrRemove_1", "bufferCount", "bufferSize", "startBufferEvery", "source", "subscriber", "buffers", "count", "value", "toEmit", "buffers_1", "__values", "buffers_1_1", "buffer", "toEmit_1", "toEmit_1_1", "buffers_2", "buffers_2_1", "exports", "Subscription_1", "lift_1", "OperatorSubscriber_1", "arrRemove_1", "async_1", "args_1", "executeSchedule_1", "bufferTime", "bufferTimeSpan", "otherArgs", "_i", "scheduler", "_a", "bufferCreationInterval", "_b", "maxBufferSize", "source", "subscriber", "bufferRecords", "restartOnEmit", "emit", "record", "buffer", "subs", "startBuffer", "record_1", "bufferTimeSubscriber", "value", "recordsCopy", "recordsCopy_1", "__values", "recordsCopy_1_1", "exports", "Subscription_1", "lift_1", "innerFrom_1", "OperatorSubscriber_1", "noop_1", "arrRemove_1", "bufferToggle", "openings", "closingSelector", "source", "subscriber", "buffers", "openValue", "buffer", "closingSubscription", "emitBuffer", "value", "buffers_1", "__values", "buffers_1_1", "exports", "lift_1", "noop_1", "OperatorSubscriber_1", "innerFrom_1", "bufferWhen", "closingSelector", "source", "subscriber", "buffer", "closingSubscriber", "openBuffer", "b", "value", "exports", "innerFrom_1", "OperatorSubscriber_1", "lift_1", "catchError", "selector", "source", "subscriber", "innerSub", "syncUnsub", "handledResult", "err", "exports", "OperatorSubscriber_1", "scanInternals", "accumulator", "seed", "hasSeed", "emitOnNext", "emitBeforeComplete", "source", "subscriber", "hasState", "state", "index", "value", "i", "exports", "scanInternals_1", "lift_1", "reduce", "accumulator", "seed", "exports", "reduce_1", "lift_1", "arrReducer", "arr", "value", "toArray", "source", "subscriber", "exports", "identity_1", "mapOneOrManyArgs_1", "pipe_1", "mergeMap_1", "toArray_1", "joinAllInternals", "joinFn", "project", "sources", "exports", "combineLatest_1", "joinAllInternals_1", "combineLatestAll", "project", "exports", "combineLatestAll_1", "exports", "combineLatest_1", "lift_1", "argsOrArgArray_1", "mapOneOrManyArgs_1", "pipe_1", "args_1", "combineLatest", "args", "_i", "resultSelector", "__spreadArray", "__read", "source", "subscriber", "exports", "combineLatest_1", "combineLatestWith", "otherSources", "_i", "__spreadArray", "__read", "exports", "mergeMap_1", "isFunction_1", "concatMap", "project", "resultSelector", "exports", "concatMap_1", "isFunction_1", "concatMapTo", "innerObservable", "resultSelector", "exports", "lift_1", "concatAll_1", "args_1", "from_1", "concat", "args", "_i", "scheduler", "source", "subscriber", "__spreadArray", "__read", "exports", "concat_1", "concatWith", "otherSources", "_i", "__spreadArray", "__read", "exports", "Observable_1", "fromSubscribable", "subscribable", "subscriber", "exports", "Subject_1", "innerFrom_1", "lift_1", "fromSubscribable_1", "DEFAULT_CONFIG", "connect", "selector", "config", "connector", "source", "subscriber", "subject", "exports", "reduce_1", "count", "predicate", "total", "value", "i", "exports", "lift_1", "noop_1", "OperatorSubscriber_1", "innerFrom_1", "debounce", "durationSelector", "source", "subscriber", "hasValue", "lastValue", "durationSubscriber", "emit", "value", "exports", "async_1", "lift_1", "OperatorSubscriber_1", "debounceTime", "dueTime", "scheduler", "source", "subscriber", "activeTask", "lastValue", "lastTime", "emit", "value", "emitWhenIdle", "targetTime", "now", "exports", "lift_1", "OperatorSubscriber_1", "defaultIfEmpty", "defaultValue", "source", "subscriber", "hasValue", "value", "exports", "empty_1", "lift_1", "OperatorSubscriber_1", "take", "count", "source", "subscriber", "seen", "value", "exports", "lift_1", "OperatorSubscriber_1", "noop_1", "ignoreElements", "source", "subscriber", "exports", "map_1", "mapTo", "value", "exports", "concat_1", "take_1", "ignoreElements_1", "mapTo_1", "mergeMap_1", "innerFrom_1", "delayWhen", "delayDurationSelector", "subscriptionDelay", "source", "value", "index", "exports", "async_1", "delayWhen_1", "timer_1", "delay", "due", "scheduler", "duration", "exports", "Notification_1", "lift_1", "OperatorSubscriber_1", "dematerialize", "source", "subscriber", "notification", "exports", "lift_1", "OperatorSubscriber_1", "noop_1", "innerFrom_1", "distinct", "keySelector", "flushes", "source", "subscriber", "distinctKeys", "value", "key", "exports", "identity_1", "lift_1", "OperatorSubscriber_1", "distinctUntilChanged", "comparator", "keySelector", "defaultCompare", "source", "subscriber", "previousKey", "first", "value", "currentKey", "exports", "a", "b", "distinctUntilChanged_1", "distinctUntilKeyChanged", "key", "compare", "x", "y", "exports", "EmptyError_1", "lift_1", "OperatorSubscriber_1", "throwIfEmpty", "errorFactory", "defaultErrorFactory", "source", "subscriber", "hasValue", "value", "exports", "ArgumentOutOfRangeError_1", "filter_1", "throwIfEmpty_1", "defaultIfEmpty_1", "take_1", "elementAt", "index", "defaultValue", "hasDefaultValue", "source", "v", "i", "exports", "concat_1", "of_1", "endWith", "values", "_i", "source", "__spreadArray", "__read", "exports", "lift_1", "OperatorSubscriber_1", "every", "predicate", "thisArg", "source", "subscriber", "index", "value", "exports", "map_1", "innerFrom_1", "lift_1", "OperatorSubscriber_1", "exhaustMap", "project", "resultSelector", "source", "a", "b", "ii", "subscriber", "index", "innerSub", "isComplete", "outerValue", "exports", "exhaustMap_1", "identity_1", "exhaustAll", "exports", "exhaustAll_1", "exports", "lift_1", "mergeInternals_1", "expand", "project", "concurrent", "scheduler", "source", "subscriber", "exports", "lift_1", "finalize", "callback", "source", "subscriber", "exports", "lift_1", "OperatorSubscriber_1", "find", "predicate", "thisArg", "createFind", "exports", "emit", "findIndex", "source", "subscriber", "index", "value", "i", "lift_1", "find_1", "findIndex", "predicate", "thisArg", "exports", "EmptyError_1", "filter_1", "take_1", "defaultIfEmpty_1", "throwIfEmpty_1", "identity_1", "first", "predicate", "defaultValue", "hasDefaultValue", "source", "v", "i", "exports", "Observable_1", "innerFrom_1", "Subject_1", "lift_1", "OperatorSubscriber_1", "groupBy", "keySelector", "elementOrOptions", "duration", "connector", "source", "subscriber", "element", "groups", "notify", "cb", "handleError", "err", "consumer", "activeGroups", "teardownAttempted", "groupBySourceSubscriber", "value", "key_1", "group_1", "grouped", "createGroupedObservable", "durationSubscriber_1", "key", "groupSubject", "result", "groupSubscriber", "innerSub", "exports", "lift_1", "OperatorSubscriber_1", "isEmpty", "source", "subscriber", "exports", "empty_1", "lift_1", "OperatorSubscriber_1", "takeLast", "count", "source", "subscriber", "buffer", "value", "buffer_1", "__values", "buffer_1_1", "exports", "EmptyError_1", "filter_1", "takeLast_1", "throwIfEmpty_1", "defaultIfEmpty_1", "identity_1", "last", "predicate", "defaultValue", "hasDefaultValue", "source", "v", "i", "exports", "Notification_1", "lift_1", "OperatorSubscriber_1", "materialize", "source", "subscriber", "value", "err", "exports", "reduce_1", "isFunction_1", "max", "comparer", "x", "y", "exports", "mergeMap_1", "exports", "mergeMap_1", "isFunction_1", "mergeMapTo", "innerObservable", "resultSelector", "concurrent", "exports", "lift_1", "mergeInternals_1", "mergeScan", "accumulator", "seed", "concurrent", "source", "subscriber", "state", "value", "index", "exports", "lift_1", "mergeAll_1", "args_1", "from_1", "merge", "args", "_i", "scheduler", "concurrent", "source", "subscriber", "__spreadArray", "__read", "exports", "merge_1", "mergeWith", "otherSources", "_i", "__spreadArray", "__read", "exports", "reduce_1", "isFunction_1", "min", "comparer", "x", "y", "exports", "ConnectableObservable_1", "isFunction_1", "connect_1", "multicast", "subjectOrSubjectFactory", "selector", "subjectFactory", "source", "exports", "argsOrArgArray_1", "onErrorResumeNext_1", "onErrorResumeNextWith", "sources", "_i", "nextSources", "source", "__spreadArray", "__read", "exports", "lift_1", "OperatorSubscriber_1", "pairwise", "source", "subscriber", "prev", "hasPrev", "value", "p", "exports", "map_1", "pluck", "properties", "_i", "length", "x", "currentProp", "i", "p", "exports", "Subject_1", "multicast_1", "connect_1", "publish", "selector", "source", "exports", "BehaviorSubject_1", "ConnectableObservable_1", "publishBehavior", "initialValue", "source", "subject", "exports", "AsyncSubject_1", "ConnectableObservable_1", "publishLast", "source", "subject", "exports", "ReplaySubject_1", "multicast_1", "isFunction_1", "publishReplay", "bufferSize", "windowTime", "selectorOrScheduler", "timestampProvider", "selector", "source", "exports", "race_1", "lift_1", "identity_1", "raceWith", "otherSources", "_i", "source", "subscriber", "__spreadArray", "__read", "exports", "empty_1", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "timer_1", "repeat", "countOrConfig", "count", "delay", "_a", "source", "subscriber", "soFar", "sourceSub", "resubscribe", "notifier", "notifierSubscriber_1", "subscribeToSource", "syncUnsub", "exports", "innerFrom_1", "Subject_1", "lift_1", "OperatorSubscriber_1", "repeatWhen", "notifier", "source", "subscriber", "innerSub", "syncResub", "completions$", "isNotifierComplete", "isMainComplete", "checkComplete", "getCompletionSubject", "subscribeForRepeatWhen", "exports", "lift_1", "OperatorSubscriber_1", "identity_1", "timer_1", "innerFrom_1", "retry", "configOrCount", "config", "_a", "count", "delay", "_b", "resetOnSuccess", "source", "subscriber", "soFar", "innerSub", "subscribeForRetry", "syncUnsub", "value", "err", "resub_1", "notifier", "notifierSubscriber_1", "exports", "innerFrom_1", "Subject_1", "lift_1", "OperatorSubscriber_1", "retryWhen", "notifier", "source", "subscriber", "innerSub", "syncResub", "errors$", "subscribeForRetryWhen", "err", "exports", "innerFrom_1", "lift_1", "noop_1", "OperatorSubscriber_1", "sample", "notifier", "source", "subscriber", "hasValue", "lastValue", "value", "exports", "async_1", "sample_1", "interval_1", "sampleTime", "period", "scheduler", "exports", "lift_1", "scanInternals_1", "scan", "accumulator", "seed", "exports", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "sequenceEqual", "compareTo", "comparator", "a", "b", "source", "subscriber", "aState", "createState", "bState", "emit", "isEqual", "createSubscriber", "selfState", "otherState", "sequenceEqualSubscriber", "buffer", "complete", "exports", "innerFrom_1", "Subject_1", "Subscriber_1", "lift_1", "share", "options", "_a", "connector", "_b", "resetOnError", "_c", "resetOnComplete", "_d", "resetOnRefCountZero", "wrapperSource", "connection", "resetConnection", "subject", "refCount", "hasCompleted", "hasErrored", "cancelReset", "reset", "resetAndUnsubscribe", "conn", "source", "subscriber", "dest", "handleReset", "value", "err", "exports", "on", "args", "_i", "onSubscriber", "__spreadArray", "__read", "ReplaySubject_1", "share_1", "shareReplay", "configOrBufferSize", "windowTime", "scheduler", "bufferSize", "refCount", "_a", "_b", "_c", "exports", "EmptyError_1", "SequenceError_1", "NotFoundError_1", "lift_1", "OperatorSubscriber_1", "single", "predicate", "source", "subscriber", "hasValue", "singleValue", "seenValue", "index", "value", "exports", "filter_1", "skip", "count", "_", "index", "exports", "identity_1", "lift_1", "OperatorSubscriber_1", "skipLast", "skipCount", "source", "subscriber", "ring", "seen", "value", "valueIndex", "index", "oldValue", "exports", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "noop_1", "skipUntil", "notifier", "source", "subscriber", "taking", "skipSubscriber", "value", "exports", "lift_1", "OperatorSubscriber_1", "skipWhile", "predicate", "source", "subscriber", "taking", "index", "value", "exports", "concat_1", "args_1", "lift_1", "startWith", "values", "_i", "scheduler", "source", "subscriber", "exports", "innerFrom_1", "lift_1", "OperatorSubscriber_1", "switchMap", "project", "resultSelector", "source", "subscriber", "innerSubscriber", "index", "isComplete", "checkComplete", "value", "innerIndex", "outerIndex", "innerValue", "exports", "switchMap_1", "identity_1", "switchAll", "exports", "switchMap_1", "isFunction_1", "switchMapTo", "innerObservable", "resultSelector", "exports", "switchMap_1", "lift_1", "switchScan", "accumulator", "seed", "source", "subscriber", "state", "value", "index", "_", "innerValue", "exports", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "noop_1", "takeUntil", "notifier", "source", "subscriber", "exports", "lift_1", "OperatorSubscriber_1", "takeWhile", "predicate", "inclusive", "source", "subscriber", "index", "value", "result", "exports", "isFunction_1", "lift_1", "OperatorSubscriber_1", "identity_1", "tap", "observerOrNext", "error", "complete", "tapObserver", "source", "subscriber", "_a", "isUnsub", "value", "err", "_b", "exports", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "throttle", "durationSelector", "config", "source", "subscriber", "_a", "_b", "leading", "_c", "trailing", "hasValue", "sendValue", "throttled", "isComplete", "endThrottling", "send", "cleanupThrottling", "startThrottle", "value", "exports", "async_1", "throttle_1", "timer_1", "throttleTime", "duration", "scheduler", "config", "duration$", "exports", "async_1", "lift_1", "OperatorSubscriber_1", "timeInterval", "scheduler", "source", "subscriber", "last", "value", "now", "interval", "TimeInterval", "exports", "async_1", "isDate_1", "timeout_1", "timeoutWith", "due", "withObservable", "scheduler", "first", "each", "_with", "exports", "dateTimestampProvider_1", "map_1", "timestamp", "timestampProvider", "value", "exports", "Subject_1", "lift_1", "OperatorSubscriber_1", "noop_1", "innerFrom_1", "window", "windowBoundaries", "source", "subscriber", "windowSubject", "errorHandler", "err", "value", "exports", "Subject_1", "lift_1", "OperatorSubscriber_1", "windowCount", "windowSize", "startWindowEvery", "startEvery", "source", "subscriber", "windows", "starts", "count", "value", "windows_1", "__values", "windows_1_1", "window_1", "c", "window_2", "err", "exports", "Subject_1", "async_1", "Subscription_1", "lift_1", "OperatorSubscriber_1", "arrRemove_1", "args_1", "executeSchedule_1", "windowTime", "windowTimeSpan", "otherArgs", "_i", "scheduler", "_a", "windowCreationInterval", "_b", "maxWindowSize", "source", "subscriber", "windowRecords", "restartOnClose", "closeWindow", "record", "window", "subs", "startWindow", "window_1", "record_1", "loop", "cb", "terminate", "value", "consumer", "err", "exports", "Subject_1", "Subscription_1", "lift_1", "innerFrom_1", "OperatorSubscriber_1", "noop_1", "arrRemove_1", "windowToggle", "openings", "closingSelector", "source", "subscriber", "windows", "handleError", "err", "openValue", "window", "closingSubscription", "closeWindow", "closingNotifier", "value", "windowsCopy", "windowsCopy_1", "__values", "windowsCopy_1_1", "window_1", "exports", "Subject_1", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "windowWhen", "closingSelector", "source", "subscriber", "window", "closingSubscriber", "handleError", "err", "openWindow", "closingNotifier", "value", "exports", "lift_1", "OperatorSubscriber_1", "innerFrom_1", "identity_1", "noop_1", "args_1", "withLatestFrom", "inputs", "_i", "project", "source", "subscriber", "len", "otherValues", "hasValue", "ready", "i", "value", "values", "__spreadArray", "__read", "exports", "zip_1", "joinAllInternals_1", "zipAll", "project", "exports", "zip_1", "lift_1", "zip", "sources", "_i", "source", "subscriber", "__spreadArray", "__read", "exports", "zip_1", "zipWith", "otherInputs", "_i", "__spreadArray", "__read", "exports", "Observable_1", "exports", "ConnectableObservable_1", "observable_1", "animationFrames_1", "Subject_1", "BehaviorSubject_1", "ReplaySubject_1", "AsyncSubject_1", "asap_1", "async_1", "queue_1", "animationFrame_1", "VirtualTimeScheduler_1", "Scheduler_1", "Subscription_1", "Subscriber_1", "Notification_1", "pipe_1", "noop_1", "identity_1", "isObservable_1", "lastValueFrom_1", "firstValueFrom_1", "ArgumentOutOfRangeError_1", "EmptyError_1", "NotFoundError_1", "ObjectUnsubscribedError_1", "SequenceError_1", "timeout_1", "UnsubscriptionError_1", "bindCallback_1", "bindNodeCallback_1", "combineLatest_1", "concat_1", "connectable_1", "defer_1", "empty_1", "forkJoin_1", "from_1", "fromEvent_1", "fromEventPattern_1", "generate_1", "iif_1", "interval_1", "merge_1", "never_1", "of_1", "onErrorResumeNext_1", "pairs_1", "partition_1", "race_1", "range_1", "throwError_1", "timer_1", "using_1", "zip_1", "scheduled_1", "empty_2", "never_2", "__exportStar", "config_1", "audit_1", "auditTime_1", "buffer_1", "bufferCount_1", "bufferTime_1", "bufferToggle_1", "bufferWhen_1", "catchError_1", "combineAll_1", "combineLatestAll_1", "combineLatestWith_1", "concatAll_1", "concatMap_1", "concatMapTo_1", "concatWith_1", "connect_1", "count_1", "debounce_1", "debounceTime_1", "defaultIfEmpty_1", "delay_1", "delayWhen_1", "dematerialize_1", "distinct_1", "distinctUntilChanged_1", "distinctUntilKeyChanged_1", "elementAt_1", "endWith_1", "every_1", "exhaust_1", "exhaustAll_1", "exhaustMap_1", "expand_1", "filter_1", "finalize_1", "find_1", "findIndex_1", "first_1", "groupBy_1", "ignoreElements_1", "isEmpty_1", "last_1", "map_1", "mapTo_1", "materialize_1", "max_1", "mergeAll_1", "flatMap_1", "mergeMap_1", "mergeMapTo_1", "mergeScan_1", "mergeWith_1", "min_1", "multicast_1", "observeOn_1", "onErrorResumeNextWith_1", "pairwise_1", "pluck_1", "publish_1", "publishBehavior_1", "publishLast_1", "publishReplay_1", "raceWith_1", "reduce_1", "repeat_1", "repeatWhen_1", "retry_1", "retryWhen_1", "refCount_1", "sample_1", "sampleTime_1", "scan_1", "sequenceEqual_1", "share_1", "shareReplay_1", "single_1", "skip_1", "skipLast_1", "skipUntil_1", "skipWhile_1", "startWith_1", "subscribeOn_1", "switchAll_1", "switchMap_1", "switchMapTo_1", "switchScan_1", "take_1", "takeLast_1", "takeUntil_1", "takeWhile_1", "tap_1", "throttle_1", "throttleTime_1", "throwIfEmpty_1", "timeInterval_1", "timeout_2", "timeoutWith_1", "timestamp_1", "toArray_1", "window_1", "windowCount_1", "windowTime_1", "windowToggle_1", "windowWhen_1", "withLatestFrom_1", "zipAll_1", "zipWith_1", "uuid_1", "agents_activity_1", "rxjs_1", "logger_1", "logger", "CopilotStudioWebChat", "client", "settings", "sequence", "activitySubscriber", "conversation", "connectionStatus$", "activity$", "createObservable", "subscriber", "notifyTyping", "activity", "notifyActivity", "newActivity", "from", "processAttachments", "responseActivity", "error", "exports", "_a", "attachments", "attachment", "processed", "processBlobAttachment", "newContentUrl", "response", "blob", "arrayBuffer", "base64", "arrayBufferToBase64", "buffer", "BufferClass", "binary", "byte", "fn", "ExecuteTurnRequest", "activity", "exports", "PowerPlatformCloud", "exports", "exports", "getCopilotStudioConnectionUrl", "getTokenAudience", "agentType_1", "logger_1", "powerPlatformCloud_1", "prebuiltBotStrategy_1", "publishedBotStrategy_1", "logger", "settings", "conversationId", "_a", "isValidUri", "createURL", "cloudSetting", "_b", "agentType", "_c", "_d", "_e", "_f", "host", "getEnvironmentEndpoint", "url", "cloud", "cloudBaseAddress", "directConnectUrl", "getEndpointSuffix", "decodeCloudFromURI", "cloudToTest", "uri", "absoluteUrl", "base", "environmentId", "normalizedResourceId", "idSuffixLength", "getIdSuffixLength", "hexPrefix", "hexSuffix", "category", "index_exports", "__reExport"]
}
